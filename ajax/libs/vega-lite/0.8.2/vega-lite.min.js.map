{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","vega-lite.js","node_modules/colorbrewer/colorbrewer.js","node_modules/colorbrewer/index.js","node_modules/d3-color/build/color.js","node_modules/d3-format/build/format.js","node_modules/d3-time-format/build/timeFormat.js","node_modules/datalib/node_modules/d3-dsv/build/dsv.js","node_modules/datalib/node_modules/d3-time-format/build/timeFormat.js","node_modules/datalib/node_modules/d3-time/build/time.js","node_modules/datalib/src/aggregate/aggregator.js","node_modules/datalib/src/aggregate/collector.js","node_modules/datalib/src/aggregate/groupby.js","node_modules/datalib/src/aggregate/measures.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/bins/histogram.js","node_modules/datalib/src/format.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/formats/dsv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/import/readers.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/index.js","node_modules/datalib/src/print.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/template.js","node_modules/datalib/src/time.js","node_modules/datalib/src/util.js","node_modules/vega-logging/index.js","node_modules/vega/node_modules/vega-dataflow/src/ChangeSet.js","node_modules/vega/node_modules/vega-dataflow/src/Collector.js","node_modules/vega/node_modules/vega-dataflow/src/DataSource.js","node_modules/vega/node_modules/vega-dataflow/src/Dependencies.js","node_modules/vega/node_modules/vega-dataflow/src/Graph.js","node_modules/vega/node_modules/vega-dataflow/src/Heap.js","node_modules/vega/node_modules/vega-dataflow/src/Node.js","node_modules/vega/node_modules/vega-dataflow/src/Signal.js","node_modules/vega/node_modules/vega-dataflow/src/Tuple.js","node_modules/vega/node_modules/vega-dataflow/src/index.js","node_modules/vega/node_modules/vega-expression/src/codegen.js","node_modules/vega/node_modules/vega-expression/src/constants.js","node_modules/vega/node_modules/vega-expression/src/functions.js","node_modules/vega/node_modules/vega-expression/src/index.js","node_modules/vega/node_modules/vega-expression/src/parser.js","node_modules/vega/src/parse/expr.js","node_modules/vega/src/transforms/Aggregate.js","node_modules/vega/src/transforms/Facetor.js","node_modules/vega/src/transforms/Parameter.js","node_modules/vega/src/transforms/Transform.js","src/Encoding.js","src/compiler/axis.js","src/compiler/compiler.js","src/compiler/data.js","src/compiler/facet.js","src/compiler/layout.js","src/compiler/legend.js","src/compiler/marks.js","src/compiler/scale.js","src/compiler/stack.js","src/compiler/style.js","src/compiler/subfacet.js","src/compiler/time.js","src/consts.js","src/data.js","src/enc.js","src/encdef.js","src/globals.js","src/logger.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js","src/vl"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,2,"colorbrewer","YlGn",3,4,5,6,7,8,9,"YlGnBu","GnBu","BuGn","PuBuGn","PuBu","BuPu","RdPu","PuRd","OrRd","YlOrRd","YlOrBr","Purples","Blues","Greens","Oranges","Reds","Greys","PuOr",10,11,"BrBG","PRGn","PiYG","RdBu","RdGy","RdYlBu","Spectral","RdYlGn","Accent","Dark2","Paired",12,"Pastel1","Pastel2","Set1","Set2","Set3","./colorbrewer.js","factory","color","deltaHue","h1","h0","delta","Math","round","Color","format","m","trim","toLowerCase","reHex3","exec","parseInt","rgb","reHex6","rgbn","reRgbInteger","reRgbPercent","reHslPercent","hsl","named","hasOwnProperty","b","arguments","NaN","Rgb","_format","isNaN","max","toString","min","h","Hsl","range","hsl2rgb","m1","m2","lab","Lab","Hcl","deg2rad","sin","c","cos","rgb2xyz","x","xyz2lab","Xn","y","Yn","z","Zn","t3","pow","t2","t0","lab2xyz","t1","xyz2rgb","hcl","sqrt","atan2","rad2deg","cubehelix","Cubehelix","BC_DA","ED","EB","bl","k","E","C","D","interpolateCubehelixGamma","gamma","ah","as","al","bh","bs","interpolateCubehelixGammaLong","interpolateHclLong","ac","bc","interpolateHcl","interpolateLab","aa","ab","ba","bb","interpolateHslLong","interpolateHsl","interpolateRgb","ar","ag","br","bg","prototype","displayable","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","darker","brighter","____prototype","___prototype","Kn","__prototype","PI","_prototype","A","B","cosh","sinh","interpolateCubehelix","interpolateCubehelixLong","Map","clear","set","v","_","get","has","delete","Object","create",{"end":{"file":"?","comments_before":[],"nlb":false,"endpos":38757,"endcol":12,"endline":980,"pos":38753,"col":8,"line":980,"value":"size","type":"name"},"start":{"file":"?","comments_before":[],"nlb":false,"endpos":38757,"endcol":12,"endline":980,"pos":38753,"col":8,"line":980,"value":"size","type":"name"},"name":"size"},"size","forEach","apply","formatDecimal","p","toExponential","indexOf","coefficient","slice","exponent","abs","formatPrefixAuto","d","prefixExponent","floor","Array","join","formatRounded","formatDefault","toPrecision","out","i1","i0","formatSpecifier","specifier","FormatSpecifier","match","re","fill","align","sign","symbol","zero","width","comma","precision","type","formatTypes","formatGroup","grouping","thousands","value","j","push","substring","reverse","identity","locale","prefix","currency","test","suffix","formatType","maybeSuffix","valuePrefix","valueSuffix","valueNegative","prefixes","charCodeAt","decimal","group","Infinity","padding","formatPrefix","precisionRound","step","precisionPrefix","precisionFixed","localeFormat","definition","localeDefinitions","zhCn","ruRu","ptBr","plPl","nlNl","mkMk","jaJp","itIt","heIl","frFr","frCa","fiFi","esEs","enUs","enGb","enCa","deDe","caEs","%","toFixed","X","toUpperCase","defaultLocale","timeFormat","newInterval","floori","offseti","count","interval","date","Date","d0","d1","ceil","offset","start","stop","filter","setTime","end","weekday","setHours","setDate","getDate","getDay","getTimezoneOffset","utcWeekday","setUTCHours","setUTCDate","getUTCDate","getUTCDay","localDate","H","M","S","L","setFullYear","utcDate","UTC","setUTCFullYear","newYear","newFormat","formats","pad","string","pads","charAt","newParse","newDate","parseSpecifier","day","U","W","w","Z","parse","parses","parseShortWeekday","shortWeekdayRe","shortWeekdayLookup","parseWeekday","weekdayRe","weekdayLookup","parseShortMonth","shortMonthRe","shortMonthLookup","parseMonth","monthRe","monthLookup","parseLocaleDateTime","locale_dateTime","parseLocaleDate","locale_date","parseLocaleTime","locale_time","parsePeriod","periodLookup","formatShortWeekday","locale_shortWeekdays","formatWeekday","locale_weekdays","formatShortMonth","locale_shortMonths","getMonth","formatMonth","locale_months","formatPeriod","locale_periods","getHours","formatUTCShortWeekday","formatUTCWeekday","formatUTCShortMonth","getUTCMonth","formatUTCMonth","formatUTCPeriod","getUTCHours","dateTime","time","periods","days","shortDays","months","shortMonths","formatLookup","formatRe","formatDayOfMonth","formatHour24","I","formatHour12","formatDayOfYear","formatMilliseconds","formatMonthNumber","formatMinutes","formatSeconds","formatWeekNumberSunday","formatWeekdayNumber","formatWeekNumberMonday","formatYear","Y","formatFullYear","formatZone","formatLiteralPercent","utcFormats","formatUTCDayOfMonth","formatUTCHour24","formatUTCHour12","formatUTCDayOfYear","formatUTCMilliseconds","formatUTCMonthNumber","formatUTCMinutes","formatUTCSeconds","formatUTCWeekNumberSunday","formatUTCWeekdayNumber","formatUTCWeekNumberMonday","formatUTCYear","formatUTCFullYear","formatUTCZone","parseDayOfMonth","parseHour24","parseDayOfYear","parseMilliseconds","parseMonthNumber","parseMinutes","parseSeconds","parseWeekNumberSunday","parseWeekdayNumber","parseWeekNumberMonday","parseYear","parseFullYear","parseZone","parseLiteralPercent","utcFormat","requote","replace","requoteRe","names","RegExp","map","numberRe","percentRe","year","getMilliseconds","getMinutes","getSeconds","sunday","monday","getFullYear","utcDay","utcYear","getUTCMilliseconds","getUTCMinutes","getUTCSeconds","utcSunday","utcMonday","getUTCFullYear","formatIsoNative","toISOString","setMonth","setUTCMonth","-","0","isoSpecifier","formatIso","isoFormat","dsv","delimiter","text","parseRows","row","Function","name","JSON","stringify","token","N","EOF","eol","EOL","delimiterCode","rows","isArray","formatRows","fieldSet","fields","field","formatValue","concat","formatRow","reFormat","csv","tsv","second","setMilliseconds","seconds","minute","setSeconds","minutes","hour","setMinutes","hours","sundays","mondays","tuesday","tuesdays","wednesday","wednesdays","thursday","thursdays","friday","fridays","saturday","saturdays","week","weeks","month","years","utcSecond","setUTCMilliseconds","utcSeconds","utcMinute","setUTCSeconds","utcMinutes","utcHour","setUTCMinutes","utcHours","utcDays","utcSundays","utcMondays","utcTuesday","utcTuesdays","utcWednesday","utcWednesdays","utcThursday","utcThursdays","utcFriday","utcFridays","utcSaturday","utcSaturdays","utcWeek","utcWeeks","utcMonth","utcMonths","utcYears","Aggregator","_cells","_aggr","_stream","summarize_args","util","ops","array","Measures","Collector","Flags","ADD_CELL","MOD_CELL","proto","stream","key","_key","$","groupby","dims","_dims","isString","isFunction","summarize","_count","op","aggr","measures","_assign","*","object","_cellkey","String","_cell","_newcell","cell","num","tuple","_newtuple","flag","aggs","collect","data","_ingest","_add","add","_on_add","_rem","rem","_on_rem","_mod","curr","prev","cell0","cell1","isObject","_on_mod","result","values","_rems","changes","output","mod","_on_drop","_on_keep","execute","input","insert","_consolidate","remove","../util","./collector","./measures","_last","stats","REM","_get","toMap","extent","_ext","index","argmin","argmax","quartile","_q","q1","q2","q3","../stats","args","reduce","./aggregator",13,"measure","base","extend","init","idx","resolve","agg","helper","types","req","str","vals","sort","accessor","mutator","all","ctr","assign","distinct","isValid","missing","valid","sum","mean","average","variance","variancep","stdev","stdevp","median","modeskew",14,"bins","opt","level","minstep","eps","maxb","maxbins","logb","log","div","span","steps","bisect","unit","lo","hi","mid","cmp","EPSILON","date_value","date_index","units","utc","dmin","dmax","minb","minbins","find","spec","raw","../time",15,"$bin","options","$func","histogram","numerical","categorical","qtype","ext","gen","isFinite","unique","comparator","integer","number","../generate","../import/type","./bins",16,"numberLocale","d3_numberF","numberF","timeLocale","d3_timeF","timeF","intervals","domain","error","LN10","e10","e5","e2","numberAutoFormat","timeAutoFormat","formatMillisecond","formatSecond","formatMinute","formatHour","formatDay","formatWeek","d3_time","utcAutoFormat","numberPrefix","auto","d3-format","d3-time","d3-time-format",17,"repeat","val","zeros","random","uniform","undefined","samples","normal","next","rds",18,"header","d3_dsv","delim","fmt","../../util","d3-dsv",19,"json","topojson","treejson","./dsv","./json","./topojson","./treejson",20,"isBuffer","property",21,"reader","obj","feature","objects","features","mesh",22,"toTable","root","childrenField","visit","node","table","children",23,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","startsWith","load","useXHR","defaultProtocol","domainWhiteList","origin","document","createElement","href","host","hostname","location","parts","whiteListed","some","lastIndexOf","callback","err","xhr","http","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","filename","fs","readFile","readFileSync","getBody","encoding","gzip","body","statusCode","searchString","sync-request",24,"read","cols","parsers","clen","len","inferAll","duplicate","keys","annotation","./formats","./type",25,"./load","./read",26,"TYPES","isDate","isNumber","isBoolean","typeAll","infer","TESTS","splice","PARSERS","boolean",27,"dl","version","print","template","./aggregate/aggregator","./aggregate/groupby","./bins/bins","./bins/histogram","./format","./generate","./import/load","./import/read","./import/readers","./import/type","./print","./stats","./template","./time","./util",28,"printQuantitativeProfile","printCategoricalProfile","list","top","FMT","POS","separator","minwidth","maxwidth","limit","lens","head","truncate","tmpl","summary","__summary__",29,"results","quantile","q","M2","avg","med","std","dot","rank","mu","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","mat","exp","L2","R","entropy","counts","LN2","mutual","px","py","info","profile","sd",30,"src","source","bind","context","variable","properties","regex","template_re","interpolate","template_escaper","template_escapeChar","template_var","strcall","stringCast","number_format","template_format","time_format","filters","filter_re","prop","shift","pidx","args_re","template_escapes","pattern","format_map","clearFormatCache","'","\\","\r","\n"," "," ",31,"tempDate","entry","STEPS","toUnitMap","baseDate","utcBaseDate",32,"util_escape_str","escape_str_re","strrep","truncateOnWord","rev","cnt","tok","split","truncate_word_re","buffer","FNAME","namedfunc","equal","keystr","Buffer","field_re","$valid","$length","$in","$year","$month","$date","dates","$day","weekdays","$hour","$minute","$second","$utcYear","$utcMonth","$utcDate","$utcDay","$utcHour","$utcMinute","$utcSecond","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","pos","padchar","word","ellipsis","l1","l2",33,"write","msg","console","debug","enable","state","prevTime","now","ts","stamp","reflow",34,"cs","copy","facet","trans","dirty","DEPS","ALL","./Dependencies",35,"graph","Base","_data","router","collector","Tuple","constructor","evaluate","idFilter","./Node","./Tuple","vega-logging",36,"DataSource","_graph","_name","_source","_facet","_input","ChangeSet","_output","_inputNode","_outputNode","_pipeline","_collector","_mutates","DataSourceInput","ds","Node","DataSourceOutput","reflows","DataSourceListener","mutates","_srcMap","_id","derive","rederive","tuples","ingest","where","update","func","ids","idMap","last","fire","propagate","pipeline","unshift","preprocess","connect","synchronize","listener","addListener","removeListener","listeners","./ChangeSet","./Collector",37,"deps",38,"Graph","Heap","Signal","Deps","_stamp","_rank","_signals","doNotPropagate","hash","SIGNALS","dataValues","DATA","signalValues","db","signal","signalRef","ref","pulse","nplse","tpls","ntpls","pulses","pq","_qrank","qrank","peek","pop","_listeners","branch","collects","batch","produces","signals","dependency","disconnect","id","prev_update","reevaluate","reflowed","run","./DataSource","./Heap","./Signal","datalib",39,"nodes","_siftdown","item","parent","_siftup","ridx","cidx","retval","pushpop",40,"nodeID","Router","Produces","Mutates","Reflows","Batch","_ids","_deps","_flags","_setf","_names","dep","cur","reset",41,"initialValue","_value","_verbose","_handlers","verbose","on","handler","off",42,"datum","tupleID","_prev","prev_init",43,"Dependencies","./Graph",44,"codegen_wrap","ast","codegen","globals","lookupGlobal","GLOBAL_VAR","generator","CODEGEN_TYPES","constants","functions","idWhiteList","idBlackList","memberDepth","FIELD_VAR","fieldVar","globalVar","Literal","Identifier","Program","MemberExpression","computed","CallExpression","callee","ArrayExpression","elements","BinaryExpression","left","operator","right","UnaryExpression","argument","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","Property","ExpressionStatement","expression","./constants","./functions",45,"LOG2E","LOG10E","SQRT1_2","SQRT2",46,"fncall","cast","DATE","STRING","REGEXP","acos","asin","atan","clamp","datetime","milliseconds","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","parseFloat","upper","lower","regexp","if",47,"parser","expr","compiler","compile","./codegen","./parser",48,"assert","condition","message","isDecimalDigit","ch","isHexDigit","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isKeyword","strict","skipComment","lineNumber","lineStart","scanHexEscape","scanUnicodeCodePointEscape","cu1","cu2","throwError","Messages","UnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Keyword","NullLiteral","BooleanLiteral","scanPunctuator","code2","ch2","ch3","ch4","ch1","extra","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","NumericLiteral","scanOctalLiteral","octal","scanNumericLiteral","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","StringLiteral","testRegExp","flags","tmp","$0","$1","InvalidRegExp","exception","scanRegExpBody","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","lookahead","RegularExpression","collectRegex","loc","line","column","isIdentifierName","advanceSlash","prevToken","checkToken","advance","collectToken","TokenName","lex","Position","SourceLocation","WrappingSourceLocation","startToken","WrappingNode","peekLineTerminator","found","messageFormat","whole","description","errors","throwUnexpected","UnexpectedEOS","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","StrictReservedWord","expect","expectTolerant","matchKeyword","keyword","consumeSemicolon","parseArrayInitialiser","parseAssignmentExpression","finishArrayExpression","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseObjectInitialiser","kind","Syntax","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","parenthesisCount","parseExpression","parsePrimaryExpression","legalKeywords","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","parseConditionalExpression","finishConditionalExpression","oldParenthesisCount","parseExpressionStatement","finishExpressionStatement","parseStatement","parseSourceElement","parseSourceElements","sourceElement","directive","firstRestricted","sourceElements","parseProgram","finishProgram","filterTokenLocation","labelSet","inFunctionBody","inIteration","inSwitch","lastCommentStart","tolerant","lexError","program","AssignmentExpression","NewlineAfterThrow","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","finish","finishAssignmentExpression",49,"eventItem","eventGroup","eventX","eventY","vega-expression",50,"Aggregate","Transform","addParameters","sg","signalDeps","tx","_transform","_fields","_args","_out","_type","TUPLE","_acc","getFields","meas","df","Facetor","VALUE","MULTI","VALID_OPS","accessors","acc","hasGetter","param","transform","reeval","gby","./Facetor","./Transform","vega-dataflow",51,"_facetID","facetID","disconnect_cell",52,"Parameter","_accessors","_resolution","arrayType","isData","dataType","isField","fieldType","valType","exprType","isExpr","FIELDS","../parse/expr",53,"params","_parameters","./Parameter",54,"consts","vlEncDef","vlenc","schema","Encoding","theme","defaults","instantiate","specExtended","merge","_marktype","marktype","_enc","_config","config","fromShorthand","shorthand","enc","fromSpec","toShorthand","specFromShorthand","excludeConfig","toSpec","excludeData","subtract","is","encType","encDef","et","fieldRef","fieldTitle","isCount","displayName","aggregate","timeUnit","bin","scale","axis","bandSize","useSmallBand","ROW","COL","band","MAXBINS_DEFAULT","numberFormat","fieldStats","formatConfig","isTypes","toggleSort","support","Q","qField","O","isType","isOrdinalScale","isDimension","isMeasure","isAggregate","dataTable","AGGREGATE","RAW","alwaysNoOcclusion","isStack","COLOR","DETAIL","isXMeasure","isYMeasure","details","refs","facets","cardinality","isRaw","hasValues","transpose","oldenc","col","./consts","./enc","./encdef","./globals","./schema/schema",55,"setter","getter","def","layout","isCol","isRow","layer","orient","labels","angle","T","ticks","rotate","titleOffset","grid","title","hideTicks","cellPadding","_grid","yOffset","cellWidth","y2","stroke","strokeOpacity","xOffset","cellHeight","x2","mult","opacity","majorTicks","ax","maxLength","titleMaxLength","baseline","dy","height","hasScale","maxLabelLength","labelAngle","../globals",56,"legend","marks","style","subfacet","compileEncoding","scales","enter","mdefs","mdef","lineType","from","by","singleScaleNames","markProps","legends","defs","axes","../Encoding","./axis","./data","./facet","./layout","./legend","./marks","./scale","./stack","./style","./subfacet","datalib/src/stats",57,"filterNonPositive","formatParse","nullFilter","formula","nofn","filteredFields","fieldList","fieldName","containsType","formulas","hasAggregate","fnDictSet","dim","stacked","STACKED","prefn","../encdef",58,"groupdef","faceting","axesGrp","facetKeys","cellAxes","hasRow","hasCol","mark",59,"vllayout","box","hasX","hasY","xCardinality","yCardinality","TEXT","colCardinality","rowCardinality","getMaxNumberLength","d3_format","getMaxLength","extraOffset",60,"SIZE","SHAPE","shape","symbols","filled","strokeWidth","leg",61,"bar_props","xc","yc","point_props","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","font","placeholder","family","fontWeight","weight","fontStyle","bar","supportedEncoding","requiredEncoding","detail","area","tick","circle","square","point",62,"props","scaleDef","fieldStat","getbins","numbins","useRawDomain","_useRawDomain","noAggregate","order","scaleUseRawDomain","useRawDomainEnabled","notCountOrSum","isOrdinalFn","bandWidth","nice","outerPadding","points","colorScale","ordinalPalette","quantitativeRange","c10palette","c20palette","palette","ps","to","interpolator","../schema/schema","d3-color",63,"stacking","valName","startField","endField","sortby",64,"estimateOpacity","numPoints","numMultiples",65,"subfaceting",66,"d3_time_format","LONG_DATE","filterNull","stat","yearstat","scaleLabel","labelLength","isColor",67,"encodingTypes",68,"vldata",69,"encTypes","countRetinal","fieldDef","arr","enctype",70,"vlfield","shorthands","timefns","tu","./compiler/time",71,"INDEX",72,"METHODS","logger","cfn",73,"VALID_AGG_OPS","enum","supportedEnums","supportedTypes","getSupportedRole","supportedRole","timeUnits","defaultTimeFn","scale_type","default","clone","minimum","typicalField","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","maximum","sortMixin","oneOf","required","bandMixin","legendMixin","textMixin","role","margin","sizeMixin","colorMixin","minItems","maxItems","items","stackMixin","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","quantitativeField","onlyQuantitativeField","additionalProperties","viewport","gridColor","gridOpacity","autoSortLine","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellGridOpacity","cellGridOffset","cellBackgroundColor","textCellWidth","singleBarOffset","timeScaleLabelLength","dayScaleLabel","monthScaleLabel","characterWidth","maxSmallNumber","smallNumberFormat","largeNumberFormat","$schema","./schemautil","vega/src/transforms/Aggregate",74,"dest","schemautil","isEmpty","instance","ins",75,"isin","thisArg","any","noaugment","./logger","datalib/src/bins/bins","datalib/src/generate","datalib/src/util",76,"./Encoding","./compiler/compiler"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n\n},{}],3:[function(require,module,exports){\nmodule.exports = require('./colorbrewer.js');\n\n},{\"./colorbrewer.js\":2}],4:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.hasOwnProperty(format) ? rgbn(named[format])\n        : null;\n  }function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n  };\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }var ____prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.rgb = function() {\n    return this;\n  };\n\n  ____prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  ____prototype.toString = function() {\n    return _format(this.r, this.g, this.b);\n  };\n\n  function _format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var ___prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  ___prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }var __prototype = lab.prototype = Lab.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }var _prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return _format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  var interpolateCubehelix = interpolateCubehelixGamma(1);\n  var interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.interpolateCubehelix = interpolateCubehelix;\n  exports.interpolateCubehelixLong = interpolateCubehelixLong;\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));\n},{}],5:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"¥\", \"\"]\n  };\n\n  var ruRu = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0руб.\"]\n  };\n\n  var ptBr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  };\n\n  var plPl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"zł\"]\n  };\n\n  var nlNl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"€\\xa0\", \"\"]\n  };\n\n  var mkMk = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0ден.\"]\n  };\n\n  var jaJp = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"円\"]\n  };\n\n  var itIt = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"€\", \"\"]\n  };\n\n  var heIl = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"₪\", \"\"]\n  };\n\n  var frFr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var frCa = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  };\n\n  var fiFi = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var esEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var enUs = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var enGb = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"£\", \"\"]\n  };\n\n  var enCa = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var deDe = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var caEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer “value” part that can be\n          // grouped, and fractional or exponential “suffix” part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"ja-JP\", jaJp)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.formatPrefix = defaultLocale.formatPrefix;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));\n},{}],6:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"上午\", \"下午\"],\n    days: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    shortDays: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    months: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"],\n    shortMonths: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"воскресенье\", \"понедельник\", \"вторник\", \"среда\", \"четверг\", \"пятница\", \"суббота\"],\n    shortDays: [\"вс\", \"пн\", \"вт\", \"ср\", \"чт\", \"пт\", \"сб\"],\n    months: [\"января\", \"февраля\", \"марта\", \"апреля\", \"мая\", \"июня\", \"июля\", \"августа\", \"сентября\", \"октября\", \"ноября\", \"декабря\"],\n    shortMonths: [\"янв\", \"фев\", \"мар\", \"апр\", \"май\", \"июн\", \"июл\", \"авг\", \"сен\", \"окт\", \"ноя\", \"дек\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Terça\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sábado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sáb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Março\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziałek\", \"Wtorek\", \"Środa\", \"Czwartek\", \"Piątek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"Śr.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Styczeń\", \"Luty\", \"Marzec\", \"Kwiecień\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpień\", \"Wrzesień\", \"Październik\", \"Listopad\", \"Grudzień\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Paźdz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"недела\", \"понеделник\", \"вторник\", \"среда\", \"четврток\", \"петок\", \"сабота\"],\n    shortDays: [\"нед\", \"пон\", \"вто\", \"сре\", \"чет\", \"пет\", \"саб\"],\n    months: [\"јануари\", \"февруари\", \"март\", \"април\", \"мај\", \"јуни\", \"јули\", \"август\", \"септември\", \"октомври\", \"ноември\", \"декември\"],\n    shortMonths: [\"јан\", \"фев\", \"мар\", \"апр\", \"мај\", \"јун\", \"јул\", \"авг\", \"сеп\", \"окт\", \"ное\", \"дек\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Lunedì\", \"Martedì\", \"Mercoledì\", \"Giovedì\", \"Venerdì\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e ב%B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"ראשון\", \"שני\", \"שלישי\", \"רביעי\", \"חמישי\", \"שישי\", \"שבת\"],\n    shortDays: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"],\n    months: [\"ינואר\", \"פברואר\", \"מרץ\", \"אפריל\", \"מאי\", \"יוני\", \"יולי\", \"אוגוסט\", \"ספטמבר\", \"אוקטובר\", \"נובמבר\", \"דצמבר\"],\n    shortMonths: [\"ינו׳\", \"פבר׳\", \"מרץ\", \"אפר׳\", \"מאי\", \"יוני\", \"יולי\", \"אוג׳\", \"ספט׳\", \"אוק׳\", \"נוב׳\", \"דצמ׳\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"janv.\", \"févr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"août\", \"sept.\", \"oct.\", \"nov.\", \"déc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"jan\", \"fév\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"aoû\", \"sep\", \"oct\", \"nov\", \"déc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"kesäkuu\", \"heinäkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kesä\", \"Heinä\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"miércoles\", \"jueves\", \"viernes\", \"sábado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mié\", \"jue\", \"vie\", \"sáb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"März\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"març\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"març\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));\n},{}],7:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.dsv = {}));\n}(this, function (exports) { 'use strict';\n\n  var dsv = function(delimiter) {\n    var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n\n    function parse(text, f) {\n      var o;\n      return parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function(\"d\", \"return {\" + row.map(function(name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n        o = f ? function(row, i) { return f(a(row), i); } : a;\n      });\n    }\n\n    function parseRows(text, f) {\n      var EOL = {}, // sentinel value for end-of-line\n          EOF = {}, // sentinel value for end-of-file\n          rows = [], // output rows\n          N = text.length,\n          I = 0, // current character index\n          n = 0, // the current line number\n          t, // the current token\n          eol; // is the current token followed by EOL?\n\n      function token() {\n        if (I >= N) return EOF; // special case: end of file\n        if (eol) return eol = false, EOL; // special case: end of line\n\n        // special case: quotes\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n        }\n\n        // common case: find next delimiter or newline\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; // \\n\n          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n          else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n\n        // special case: last token before EOF\n        return text.slice(j);\n      }\n\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n\n      return rows;\n    }\n\n    function format(rows) {\n      if (Array.isArray(rows[0])) return formatRows(rows); // deprecated; use formatRows\n      var fieldSet = Object.create(null), fields = [];\n\n      // Compute unique fields in order of discovery.\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!((field += \"\") in fieldSet)) {\n            fields.push(fieldSet[field] = field);\n          }\n        }\n      });\n\n      return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    }\n\n    function formatRows(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    }\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(text) {\n      return reFormat.test(text) ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n    }\n\n    return {\n      parse: parse,\n      parseRows: parseRows,\n      format: format,\n      formatRows: formatRows\n    };\n  }\n\n  exports.csv = dsv(\",\");\n  exports.tsv = dsv(\"\\t\");\n\n  exports.dsv = dsv;\n\n}));\n},{}],8:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"上午\", \"下午\"],\n    days: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    shortDays: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    months: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"],\n    shortMonths: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"воскресенье\", \"понедельник\", \"вторник\", \"среда\", \"четверг\", \"пятница\", \"суббота\"],\n    shortDays: [\"вс\", \"пн\", \"вт\", \"ср\", \"чт\", \"пт\", \"сб\"],\n    months: [\"января\", \"февраля\", \"марта\", \"апреля\", \"мая\", \"июня\", \"июля\", \"августа\", \"сентября\", \"октября\", \"ноября\", \"декабря\"],\n    shortMonths: [\"янв\", \"фев\", \"мар\", \"апр\", \"май\", \"июн\", \"июл\", \"авг\", \"сен\", \"окт\", \"ноя\", \"дек\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Terça\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sábado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sáb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Março\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziałek\", \"Wtorek\", \"Środa\", \"Czwartek\", \"Piątek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"Śr.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Styczeń\", \"Luty\", \"Marzec\", \"Kwiecień\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpień\", \"Wrzesień\", \"Październik\", \"Listopad\", \"Grudzień\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Paźdz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"недела\", \"понеделник\", \"вторник\", \"среда\", \"четврток\", \"петок\", \"сабота\"],\n    shortDays: [\"нед\", \"пон\", \"вто\", \"сре\", \"чет\", \"пет\", \"саб\"],\n    months: [\"јануари\", \"февруари\", \"март\", \"април\", \"мај\", \"јуни\", \"јули\", \"август\", \"септември\", \"октомври\", \"ноември\", \"декември\"],\n    shortMonths: [\"јан\", \"фев\", \"мар\", \"апр\", \"мај\", \"јун\", \"јул\", \"авг\", \"сеп\", \"окт\", \"ное\", \"дек\"]\n  };\n\n  var jaJp = {\n    dateTime: \"%Y %b %e %a %X\",\n    date: \"%Y/%m/%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"日曜日\", \"月曜日\", \"火曜日\", \"水曜日\", \"木曜日\", \"金曜日\", \"土曜日\"],\n    shortDays: [\"日\", \"月\", \"火\", \"水\", \"木\", \"金\", \"土\"],\n    months: [\"睦月\", \"如月\", \"弥生\", \"卯月\", \"皐月\", \"水無月\", \"文月\", \"葉月\", \"長月\", \"神無月\", \"霜月\", \"師走\"],\n    shortMonths: [\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Lunedì\", \"Martedì\", \"Mercoledì\", \"Giovedì\", \"Venerdì\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e ב%B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"ראשון\", \"שני\", \"שלישי\", \"רביעי\", \"חמישי\", \"שישי\", \"שבת\"],\n    shortDays: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"],\n    months: [\"ינואר\", \"פברואר\", \"מרץ\", \"אפריל\", \"מאי\", \"יוני\", \"יולי\", \"אוגוסט\", \"ספטמבר\", \"אוקטובר\", \"נובמבר\", \"דצמבר\"],\n    shortMonths: [\"ינו׳\", \"פבר׳\", \"מרץ\", \"אפר׳\", \"מאי\", \"יוני\", \"יולי\", \"אוג׳\", \"ספט׳\", \"אוק׳\", \"נוב׳\", \"דצמ׳\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"janv.\", \"févr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"août\", \"sept.\", \"oct.\", \"nov.\", \"déc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"jan\", \"fév\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"aoû\", \"sep\", \"oct\", \"nov\", \"déc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"kesäkuu\", \"heinäkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kesä\", \"Heinä\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"miércoles\", \"jueves\", \"viernes\", \"sábado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mié\", \"jue\", \"vie\", \"sáb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"März\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"març\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"març\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"ja-JP\", jaJp)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));\n},{}],9:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));\n},{}],10:[function(require,module,exports){\nvar util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x, key));\n};\n\nproto._newcell = function(x, key) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x, key),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_add) this._on_add(x, cell);\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_rem) this._on_rem(x, cell);\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      // consolidate collector values\n      if (cell.collect) {\n        cell.data.values();\n      }\n      // update tuple properties\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      // add output tuple\n      result.push(cell.tuple);\n    } else {\n      delete this._cells[k];\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function(output) {\n  var changes = output || {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??\n      delete this._cells[k];\n      if (this._on_drop) this._on_drop(cell);\n    } else {\n      if (this._on_keep) this._on_keep(cell);\n      if (flag & Flags.ADD_CELL) {\n        changes.add.push(cell.tuple);\n      } else if (flag & Flags.MOD_CELL) {\n        changes.mod.push(cell.tuple);\n      }\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;\n},{\"../util\":32,\"./collector\":11,\"./measures\":13}],11:[function(require,module,exports){\nvar util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m ? get(m) : +Infinity;\n};\n\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;\n\n},{\"../stats\":29,\"../util\":32}],12:[function(require,module,exports){\nvar util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n\n},{\"../util\":32,\"./aggregator\":10}],13:[function(require,module,exports){\nvar util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.valid > 1 ? this.dev / this.valid : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  ctr.fields = agg.map(util.$('out'));\n  return ctr;\n}\n\ntypes.create = create;\nmodule.exports = types;\n},{\"../stats\":29,\"../util\":32}],14:[function(require,module,exports){\nvar util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time\":31,\"../util\":32}],15:[function(require,module,exports){\nvar bins = require('./bins'),\n    gen  = require('../generate'),\n    type = require('../import/type'),\n    util = require('../util'),\n    stats = require('../stats');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};\n},{\"../generate\":17,\"../import/type\":26,\"../stats\":29,\"../util\":32,\"./bins\":14}],16:[function(require,module,exports){\nvar d3_time = require('d3-time'),\n    d3_timeF = require('d3-time-format'),\n    d3_numberF = require('d3-format'),\n    numberF = d3_numberF, // defaults to EN-US\n    timeF = d3_timeF;     // defaults to EN-US\n\nfunction numberLocale(l) {\n  var f = d3_numberF.localeFormat(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  numberF = f;\n}\n\nfunction timeLocale(l) {\n  var f = d3_timeF.localeFormat(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  timeF = f;\n}\n\nmodule.exports = {\n  // Update number formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-format\n  numberLocale: numberLocale,\n  number:       function(f) { return numberF.format(f); },\n  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },\n\n  // Update time formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-time-format\n  timeLocale:   timeLocale,\n  time:         function(f) { return timeF.format(f); },  \n  utc:          function(f) { return timeF.utcFormat(f); },\n\n  // Set number and time locale simultaneously.\n  locale:       function(l) { numberLocale(l); timeLocale(l); },\n\n  // automatic formatting functions\n  auto: {\n    number:   numberAutoFormat,\n    time:     function() { return timeAutoFormat(); },\n    utc:      function() { return utcAutoFormat(); }\n  }\n};\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction intervals(domain, count) {\n  if (!domain.length) domain = [0];\n  if (count == null) count = 10;\n\n  var start = domain[0],\n      stop = domain[domain.length - 1];\n\n  if (stop < start) { error = stop; stop = start; start = error; }\n\n  var span = (stop - start) || (count = 1, start || stop || 1),\n      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),\n      error = span / count / step;\n\n  // Filter ticks to get closer to the desired count.\n  if (error >= e10) step *= 10;\n  else if (error >= e5) step *= 5;\n  else if (error >= e2) step *= 2;\n\n  // Round start and stop values to step interval.\n  return [\n    Math.ceil(start / step) * step,\n    Math.floor(stop / step) * step + step / 2, // inclusive\n    step\n  ];\n}\n\nfunction numberAutoFormat(domain, count, f) {\n  var range = intervals(domain, count);\n  if (f == null) {\n    f = ',.' + d3_numberF.precisionFixed(range[2]) + 'f';\n  } else {\n    switch (f = d3_numberF.formatSpecifier(f), f.type) {\n      case 's': {\n        var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));\n        if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);\n        return numberF.formatPrefix(f, value);\n      }\n      case '':\n      case 'e':\n      case 'g':\n      case 'p':\n      case 'r': {\n        if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');\n        break;\n      }\n      case 'f':\n      case '%': {\n        if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - (f.type === '%') * 2;\n        break;\n      }\n    }\n  }\n  return numberF.format(f);\n}\n\nfunction timeAutoFormat() {\n  var f = timeF.format,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.second(date) < d ? formatMillisecond\n        : d3_time.minute(date) < d ? formatSecond\n        : d3_time.hour(date) < d ? formatMinute\n        : d3_time.day(date) < d ? formatHour\n        : d3_time.month(date) < d ?\n          (d3_time.week(date) < d ? formatDay : formatWeek)\n        : d3_time.year(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n\nfunction utcAutoFormat() {\n  var f = timeF.utcFormat,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.utcSecond(date) < d ? formatMillisecond\n        : d3_time.utcMinute(date) < d ? formatSecond\n        : d3_time.utcHour(date) < d ? formatMinute\n        : d3_time.utcDay(date) < d ? formatHour\n        : d3_time.utcMonth(date) < d ?\n          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)\n        : d3_time.utcYear(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n\n},{\"d3-format\":5,\"d3-time\":9,\"d3-time-format\":8}],17:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],18:[function(require,module,exports){\nvar util = require('../../util');\nvar d3_dsv = require('d3-dsv');\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3_dsv.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;\n},{\"../../util\":32,\"d3-dsv\":7}],19:[function(require,module,exports){\nvar dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};\n},{\"./dsv\":18,\"./json\":20,\"./topojson\":21,\"./treejson\":22}],20:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":32}],21:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\n\nvar reader = function(data, format) {\n  var topojson = reader.topojson;\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n};\n\nreader.topojson = (typeof window !== \"undefined\" ? window['topojson'] : typeof global !== \"undefined\" ? global['topojson'] : null);\nmodule.exports = reader;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":20}],22:[function(require,module,exports){\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n},{\"./json\":20}],23:[function(require,module,exports){\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (!load.useXHR && startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (load.useXHR) {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    } else {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + opt.url);\n  } else if (load.useXHR) {\n    // on client, use xhr\n    return xhr(url, callback);\n  } else if (startsWith(url, fileProtocol)) {\n    // on server, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // on server, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs on server\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  fs.readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  \n  var options = {url: url, encoding: null, gzip: true};\n  require('request')(options, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      error = error ||\n        'Load failed with response code ' + response.statusCode + '.';\n      callback(error, null);\n    }\n  });\n}\n\nfunction startsWith(string, searchString) {\n  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nload.useXHR = (typeof XMLHttpRequest !== 'undefined');\n\nmodule.exports = load;\n\n},{\"fs\":1,\"request\":1,\"sync-request\":1,\"url\":1}],24:[function(require,module,exports){\nvar util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n\n},{\"../util\":32,\"./formats\":19,\"./type\":26}],25:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) { callback(error, null); return; }\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (!callback) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":32,\"./load\":23,\"./read\":24}],26:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":32}],27:[function(require,module,exports){\nvar util = require('./util');\n\nvar dl = {\n  version:    '1.4.6',\n  load:       require('./import/load'),\n  read:       require('./import/read'),\n  type:       require('./import/type'),\n  Aggregator: require('./aggregate/aggregator'),\n  groupby:    require('./aggregate/groupby'),\n  bins:       require('./bins/bins'),\n  $bin:       require('./bins/histogram').$bin,\n  histogram:  require('./bins/histogram').histogram,\n  format:     require('./format'),\n  print:      require('./print'),\n  template:   require('./template'),\n  time:       require('./time')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;\n},{\"./aggregate/aggregator\":10,\"./aggregate/groupby\":12,\"./bins/bins\":14,\"./bins/histogram\":15,\"./format\":16,\"./generate\":17,\"./import/load\":23,\"./import/read\":24,\"./import/readers\":25,\"./import/type\":26,\"./print\":28,\"./stats\":29,\"./template\":30,\"./time\":31,\"./util\":32}],28:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}\n},{\"./import/type\":26,\"./stats\":29,\"./template\":30,\"./util\":32}],29:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":17,\"./import/type\":26,\"./util\":32}],30:[function(require,module,exports){\nvar util = require('./util'),\n    format = require('./format');\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  /* jshint evil: true */\n  return (new Function('d', src)).bind(context);\n}\n\ntemplate.source = source;\ntemplate.context = context;\nmodule.exports = template;\n\n// Clear cache of format objects.\n// This can *break* prior template functions, so invoke with care!\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\n// Generate property access code for use within template source.\n// object: the name of the object (variable) containing template data\n// property: the property access string, verbatim from template tag\ntemplate.property = function(object, property) {\n  var src = util.field(property).map(util.str).join('][');\n  return object + '[' + src + ']';\n};\n\n// Generate source code for a template function.\n// text: the template text\n// variable: the name of the data object variable ('obj' by default)\n// properties: optional hash for collecting all accessed properties\nfunction source(text, variable, properties) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable, properties) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable, properties) {\n  var filters = text.match(filter_re);\n  var prop = filters.shift().trim();\n  var stringCast = true;\n\n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n\n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n\n  function number_format(fmt, key) {\n    a = template_format(args[0], key, fmt);\n    stringCast = false;\n    src = 'this.formats['+a+']('+src+')';\n  }\n  \n  function time_format(fmt, key) {\n    a = template_format(args[0], key, fmt);\n    stringCast = false;\n    src = 'this.formats['+a+']('+date()+')';\n  }\n\n  if (properties) properties[prop] = 1;\n  var src = template.property(variable, prop);\n\n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1)\n        .match(args_re)\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        number_format(format.number, 'number');\n        break;\n      case 'time':\n        time_format(format.time, 'time');\n        break;\n      case 'time-utc':\n        time_format(format.utc, 'time-utc');\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g,\n    filter_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^\\|\"]+|[^\\|\\']+)+/g,\n    args_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^,\"]+|[^,\\']+)+/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, key, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  key = key + ':' + pattern;\n  if (!context.format_map[key]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[key] = i;\n  }\n  return context.format_map[key];\n}\n\n},{\"./format\":16,\"./util\":32}],31:[function(require,module,exports){\nvar d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n},{\"d3-time\":9}],32:[function(require,module,exports){\nvar buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{\"./time\":31,\"buffer\":1}],33:[function(require,module,exports){\nvar ts = Date.now();\n\nfunction write(msg) {\n  msg = '[Vega Log] ' + msg;\n  console.log(msg);\n}\n\nfunction error(msg) {\n  msg = '[Vega Err] ' + msg;\n  console.error(msg);\n}\n\nfunction debug(input, args) {\n  if (!debug.enable) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  var state = {\n    prevTime:  Date.now() - ts,\n    stamp: input.stamp\n  };\n\n  if (input.add) {\n    state.add = input.add.length;\n    state.mod = input.mod.length;\n    state.rem = input.rem.length;\n    state.reflow = !!input.reflow;\n  }\n\n  log.apply(console, (args.push(JSON.stringify(state)), args));\n  ts = Date.now();\n}\n\nmodule.exports = {\n  log:   write,\n  error: error,\n  debug: (debug.enable = false, debug)\n};\n\n},{}],34:[function(require,module,exports){\nvar DEPS = require('./Dependencies').ALL;\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.dirty = a ? a.dirty : [];\n  b.request = a ? a.request : null;\n  for (var d, i=0, n=DEPS.length; i<n; ++i) {\n    b[d=DEPS[i]] = a ? a[d] : {};\n  }\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy\n};\n},{\"./Dependencies\":37}],35:[function(require,module,exports){\nvar log = require('vega-logging'),\n    Tuple = require('./Tuple'),\n    Base = require('./Node').prototype;\n\nfunction Collector(graph) {\n  Base.init.call(this, graph);\n  this._data = [];\n  this.router(true).collector(true);\n}\n\nvar prototype = (Collector.prototype = Object.create(Base));\nprototype.constructor = Collector;\n\nprototype.data = function() {\n  return this._data;\n};\n\nprototype.evaluate = function(input) {\n  log.debug(input, [\"collecting\"]);\n\n  if (input.rem.length) {\n    this._data = Tuple.idFilter(this._data, input.rem);\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  if (input.reflow) {\n    input.mod = input.mod.concat(\n      Tuple.idFilter(this._data, input.add, input.mod, input.rem));\n    input.reflow = false;\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;\n},{\"./Node\":40,\"./Tuple\":42,\"vega-logging\":33}],36:[function(require,module,exports){\nvar log = require('vega-logging'),\n    ChangeSet = require('./ChangeSet'), \n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Node = require('./Node'); // jshint ignore:line\n\nfunction DataSource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet  = facet;\n  this._input  = ChangeSet.create();\n  this._output = null; // Output changeset\n\n  this._inputNode  = null;\n  this._outputNode = null;\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline.\n  this._mutates = false;  // Does any pipeline operator mutate tuples?\n}\n\nvar prototype = DataSource.prototype;\n\nprototype.name = function(name) {\n  if (!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nprototype.source = function(src) {\n  if (!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nprototype.insert = function(tuples) {\n  this._input.add = this._input.add.concat(tuples.map(Tuple.ingest));\n  return this;\n};\n\nprototype.remove = function(where) {\n  var remove = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(remove);\n  return this;\n};\n\nprototype.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = Tuple.idMap(mod);\n\n  this._input.fields[field] = 1;\n\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      Tuple.set(x, field, next);\n      if (ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n\n  return this;\n};\n\nprototype.values = function(data) {\n  if (!arguments.length) return this._collector.data();\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nprototype.mutates = function(m) {\n  if (!arguments.length) return this._mutates;\n  this._mutates = this._mutates || m;\n  return this;\n};\n\nprototype.last = function() {\n  return this._output;\n};\n\nprototype.fire = function(input) {\n  if (input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nprototype.pipeline = function(pipeline) {\n  if (!arguments.length) return this._pipeline;\n\n  var graph = this._graph,\n      status;\n\n  pipeline.unshift(this._inputNode = DataSourceInput(this));\n  status = graph.preprocess(pipeline);\n\n  if (status.router) {\n    pipeline.push(status.collector = new Collector(graph));\n  }\n\n  pipeline.push(this._outputNode = DataSourceOutput(this));\n  this._collector = status.collector;\n  this._mutates = !!status.mutates;\n  graph.connect(this._pipeline = pipeline);\n\n  return this;\n};\n\nprototype.synchronize = function() {\n  this._graph.synchronize(this._pipeline);\n  return this;\n};\n\nprototype.listener = function() { \n  return DataSourceListener(this).addListener(this._inputNode);\n};\n\nprototype.addListener = function(l) {\n  if (l instanceof DataSource) {\n    this._collector.addListener(l.listener());\n  } else {\n    this._outputNode.addListener(l);      \n  }\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  this._outputNode.removeListener(l);\n};\n\nprototype.listeners = function(ds) {\n  return (ds ? this._collector : this._outputNode).listeners();\n};\n\n// Input node applies the datasource's delta, and propagates it to \n// the rest of the pipeline. It receives touches to reflow data.\nfunction DataSourceInput(ds) {\n  var input = new Node(ds._graph)\n    .router(true)\n    .collector(true);\n\n  input.data = function() {\n    return ds._data;\n  };\n\n  input.evaluate = function(input) {\n    log.debug(input, ['input', ds._name]);\n\n    var delta = ds._input, \n        out = ChangeSet.create(input), f;\n\n    // Delta might contain fields updated through API\n    for (f in delta.fields) {\n      out.fields[f] = 1;\n    }\n\n    // update data\n    if (delta.rem.length) {\n      ds._data = Tuple.idFilter(ds._data, delta.rem);\n    }\n\n    if (delta.add.length) {\n      ds._data = ds._data.concat(delta.add);\n    }\n\n    if (delta.sort) {\n      ds._data.sort(delta.sort);\n    }\n\n    // if reflowing, add any other tuples not currently in changeset\n    if (input.reflow) {\n      delta.mod = delta.mod.concat(\n        Tuple.idFilter(ds._data, delta.add, delta.mod, delta.rem));\n    }\n\n    // reset change list\n    ds._input = ChangeSet.create();\n\n    out.add = delta.add; \n    out.mod = delta.mod;\n    out.rem = delta.rem;\n    out.facet = ds._facet;\n    return out;\n  };\n\n  return input;\n}\n\n// Output node captures the last changeset seen by this datasource\n// (needed for joins and builds) and materializes any nested data.\n// If this datasource is faceted, materializes the values in the facet.\nfunction DataSourceOutput(ds) {\n  var output = new Node(ds._graph)\n    .router(true)\n    .reflows(true)\n    .collector(true);\n\n  output.data = function() {\n    return ds._collector ? ds._collector.data() : ds._data;\n  };\n\n  output.evaluate = function(input) {\n    log.debug(input, ['output', ds._name]);\n\n    var out = ChangeSet.create(input, true);\n\n    if (ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    out.data[ds._name] = 1;\n    return out;\n  };\n\n  return output;\n}\n\nfunction DataSourceListener(ds) {\n  var l = new Node(ds._graph).router(true);\n\n  l.evaluate = function(input) {\n    // Tuple derivation carries a cost. So only derive if the pipeline has\n    // operators that mutate, and thus would override the source data.\n    if (ds.mutates()) {  \n      var map = ds._srcMap || (ds._srcMap = {}), // to propagate tuples correctly\n          output = ChangeSet.create(input);\n\n      output.add = input.add.map(function(t) {\n        return (map[t._id] = Tuple.derive(t));\n      });\n\n      output.mod = input.mod.map(function(t) {\n        return Tuple.rederive(t, map[t._id]);\n      });\n\n      output.rem = input.rem.map(function(t) { \n        var o = map[t._id];\n        return (map[t._id] = null, o);\n      });\n\n      return (ds._input = output);\n    } else {\n      return (ds._input = input);\n    }\n  };\n\n  return l;\n}\n\nmodule.exports = DataSource;\n\n},{\"./ChangeSet\":34,\"./Collector\":35,\"./Node\":40,\"./Tuple\":42,\"vega-logging\":33}],37:[function(require,module,exports){\nvar deps = module.exports = {\n  ALL: ['data', 'fields', 'scales', 'signals']\n};\ndeps.ALL.forEach(function(k) { deps[k.toUpperCase()] = k; });\n\n},{}],38:[function(require,module,exports){\nvar dl = require('datalib'),\n    Heap = require('./Heap'),\n    ChangeSet = require('./ChangeSet'),\n    DataSource = require('./DataSource'),\n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Signal = require('./Signal'),\n    Deps = require('./Dependencies');\n\nfunction Graph() {\n}\n\nvar prototype = Graph.prototype;\n\nprototype.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nprototype.rank = function() {\n  return ++this._rank;\n};\n\nprototype.values = function(type, names, hash) {\n  var data = (type === Deps.SIGNALS ? this._signals : this._data),\n      n = (names !== undefined ? names : dl.keys(data)),\n      vals, i;\n\n  if (Array.isArray(n)) {\n    vals = hash || {};\n    for (i=0; i<n.length; ++i) {\n      vals[n[i]] = data[n[i]].values();\n    }\n    return vals;\n  } else {\n    return data[n].values();\n  }\n};\n\n// Retain for backwards-compatibility\nprototype.dataValues = function(names) {\n  return this.values(Deps.DATA, names);\n};\n\n// Retain for backwards-compatibility\nprototype.signalValues = function(names) {\n  return this.values(Deps.SIGNALS, names);\n};\n\nprototype.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if (!arguments.length) {\n    var all = [], key;\n    for (key in db) { all.push(db[key]); }\n    return all;\n  } else if (arguments.length === 1) {\n    return db[name];\n  } else {\n    return (db[name] = new DataSource(this, name, facet).pipeline(pipeline));\n  }\n};\n\nprototype.signal = function(name, init) {\n  if (arguments.length === 1) {\n    var m = this;\n    return Array.isArray(name) ?\n      name.map(function(n) { return m._signals[n]; }) :\n      this._signals[name];\n  } else {\n    return (this._signals[name] = new Signal(this, name, init));\n  }\n};\n\nprototype.signalRef = function(ref) {\n  if (!Array.isArray(ref)) {\n    ref = dl.field(ref);\n  }\n\n  var value = this.signal(ref[0]).value();\n  if (ref.length > 1) {\n    for (var i=1, n=ref.length; i<n; ++i) {\n      value = value[ref[i]];\n    }\n  }\n  return value;\n};\n\n// Stamp should be specified with caution. It is necessary for inline datasources,\n// which need to be populated during the same cycle even though propagation has\n// passed that part of the dataflow graph.  \nprototype.propagate = function(pulse, node, stamp) {\n  var pulses = {},\n      listeners, next, nplse, tpls, ntpls, i, len;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(function(a, b) {\n    // Sort on qrank (queue-rank).\n    // Rank can change during propagation due to rewiring.\n    return a._qrank - b._qrank;\n  });\n\n  if (pulse.stamp) throw Error('Pulse already has a non-zero stamp.');\n\n  pulse.stamp = stamp || ++this._stamp;\n  pulses[node._id] = pulse;\n  pq.push(node.qrank(true));\n\n  while (pq.size() > 0) {\n    node  = pq.peek();\n    pulse = pulses[node._id];\n\n    if (node.rank() !== node.qrank()) {\n      // A node's rank might change during a propagation. Re-queue if so.\n      pq.replace(node.qrank(true));\n    } else {\n      // Evaluate node and propagate pulse.\n      pq.pop();\n      pulses[node._id] = null;\n      listeners = node._listeners;\n      pulse = this.evaluate(pulse, node);\n\n      // Propagate the pulse. \n      if (pulse !== this.doNotPropagate) {\n        // Ensure reflow pulses always send reflow pulses even if skipped.\n        if (!pulse.reflow && node.reflows()) {\n          pulse = ChangeSet.create(pulse, true);\n        }\n\n        for (i=0, len=listeners.length; i<len; ++i) {\n          next = listeners[i];\n\n          if ((nplse = pulses[next._id]) !== undefined) {\n            if (nplse === null) throw Error('Already propagated to node.');\n            if (nplse === pulse) continue;  // Re-queueing the same pulse.\n\n            // We've already queued this node. Ensure there should be at most one\n            // pulse with tuples (add/mod/rem), and the remainder will be reflows. \n            tpls  = pulse.add.length || pulse.mod.length || pulse.rem.length;\n            ntpls = nplse.add.length || nplse.mod.length || nplse.rem.length;\n\n            if (tpls && ntpls) throw Error('Multiple changeset pulses to same node');\n\n            // Combine reflow and tuples into a single pulse. \n            pulses[next._id] = tpls ? pulse : nplse;\n            pulses[next._id].reflow = pulse.reflow || nplse.reflow;\n          } else {\n            // First time we're seeing this node, queue it for propagation.\n            pq.push(next.qrank(true));\n            pulses[next._id] = pulse;\n          }\n        }\n      }\n    }\n  }\n};\n\n// Process a new branch of the dataflow graph prior to connection:\n// (1) Insert new Collector nodes as needed. \n// (2) Track + return mutation/routing status of the branch.\nprototype.preprocess = function(branch) {\n  var graph = this,\n      mutates = 0,\n      node, router, collector, collects;\n\n  for (var i=0; i<branch.length; ++i) {\n    node = branch[i];\n\n    // Batch nodes need access to a materialized dataset. \n    if (node.batch() && !node._collector) {\n      if (router || !collector) {\n        node = new Collector(graph);\n        branch.splice(i, 0, node);\n        router = false;\n      } else {\n        node._collector = collector;\n      }\n    }\n\n    if ((collects = node.collector())) collector = node;\n    router  = router  || node.router() && !collects;\n    mutates = mutates || node.mutates();\n\n    // A collector needs to be inserted after tuple-producing\n    // nodes for correct previous value tracking.\n    if (node.produces()) {\n      branch.splice(i+1, 0, new Collector(graph));\n      router = false;\n    }\n  }\n\n  return {router: router, collector: collector, mutates: mutates};\n};\n\nprototype.connect = function(branch) {\n  var collector, node, data, signals, i, n, j, m, x, y;\n\n  // connect the pipeline\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      if (!(x=this.data(y=data[j]))) {\n        throw new Error('Unknown data source ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      if (!(x=this.signal(y=signals[j]))) {\n        throw new Error('Unknown signal ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    if (i > 0) branch[i-1].addListener(node);\n  }\n\n  return branch;\n};\n\nprototype.disconnect = function(branch) {\n  var collector, node, data, signals, i, n, j, m;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      this.data(data[j]).removeListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      this.signal(signals[j]).removeListener(collector);\n    }\n\n    node.disconnect();\n  }\n\n  return branch;\n};\n\nprototype.synchronize = function(branch) {\n  var ids = {},\n      node, data, i, n, j, m, d, id;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (!node.collector()) continue;\n\n    for (j=0, data=node.data(), m=data.length; j<m; ++j) {\n      id = (d = data[j])._id;\n      if (ids[id]) continue; \n      Tuple.prev_update(d);\n      ids[id] = 1; \n    }\n  }\n\n  return this;\n};\n\nprototype.reevaluate = function(pulse, node) {\n  var reflowed = pulse.reflow && node.last() >= pulse.stamp,\n      run = node.router() || pulse.add.length || pulse.rem.length;\n\n  return run || !reflowed || node.reevaluate(pulse);\n};\n\nprototype.evaluate = function(pulse, node) {\n  if (!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse;\n};\n\nmodule.exports = Graph;\n\n},{\"./ChangeSet\":34,\"./Collector\":35,\"./DataSource\":36,\"./Dependencies\":37,\"./Heap\":39,\"./Signal\":41,\"./Tuple\":42,\"datalib\":27}],39:[function(require,module,exports){\nfunction Heap(comparator) {\n  this.cmp = comparator;\n  this.nodes = [];\n}\n\nvar prototype = Heap.prototype;\n\nprototype.size = function() {\n  return this.nodes.length;\n};\n\nprototype.clear = function() {\n  return (this.nodes = [], this);\n};\n\nprototype.peek = function() {\n  return this.nodes[0];\n};\n\nprototype.push = function(x) {\n  var array = this.nodes;\n  array.push(x);\n  return _siftdown(array, 0, array.length-1, this.cmp);\n};\n\nprototype.pop = function() {\n  var array = this.nodes,\n      last = array.pop(),\n      item;\n\n  if (array.length) {\n    item = array[0];\n    array[0] = last;\n    _siftup(array, 0, this.cmp);\n  } else {\n    item = last;\n  }\n  return item;\n};\n\nprototype.replace = function(item) {\n  var array = this.nodes,\n      retval = array[0];\n  array[0] = item;\n  _siftup(array, 0, this.cmp);\n  return retval;\n};\n\nprototype.pushpop = function(item) {\n  var array = this.nodes, ref = array[0];\n  if (array.length && this.cmp(ref, item) < 0) {\n    array[0] = item;\n    item = ref;\n    _siftup(array, 0, this.cmp);\n  }\n  return item;\n};\n\nfunction _siftdown(array, start, idx, cmp) {\n  var item, parent, pidx;\n\n  item = array[idx];\n  while (idx > start) {\n    pidx = (idx - 1) >> 1;\n    parent = array[pidx];\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n    break;\n  }\n  return (array[idx] = item);\n}\n\nfunction _siftup(array, idx, cmp) {\n  var start = idx,\n      end = array.length,\n      item = array[idx],\n      cidx = 2 * idx + 1, ridx;\n\n  while (cidx < end) {\n    ridx = cidx + 1;\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = 2 * idx + 1;\n  }\n  array[idx] = item;\n  return _siftdown(array, start, idx, cmp);\n}\n\nmodule.exports = Heap;\n\n},{}],40:[function(require,module,exports){\nvar DEPS = require('./Dependencies').ALL,\n    nodeID = 0;\n\nfunction Node(graph) {\n  if (graph) this.init(graph);\n}\n\nvar Flags = Node.Flags = {\n  Router:     0x01, // Responsible for propagating tuples, cannot be skipped.\n  Collector:  0x02, // Holds a materialized dataset, pulse node to reflow.\n  Produces:   0x04, // Produces new tuples. \n  Mutates:    0x08, // Sets properties of incoming tuples.\n  Reflows:    0x10, // Forwards a reflow pulse.\n  Batch:      0x20  // Performs batch data processing, needs collector.\n};\n\nvar prototype = Node.prototype;\n\nprototype.init = function(graph) {\n  this._id = ++nodeID;\n  this._graph = graph;\n  this._rank  = graph.rank(); // Topological sort by rank\n  this._qrank = null; // Rank when enqueued for propagation\n  this._stamp = 0;    // Last stamp seen\n\n  this._listeners = [];\n  this._listeners._ids = {}; // To prevent duplicate listeners\n\n  // Initialize dependencies.\n  this._deps = {};\n  for (var i=0, n=DEPS.length; i<n; ++i) {\n    this._deps[DEPS[i]] = [];\n  }\n\n  // Initialize status flags.\n  this._flags = 0;\n\n  return this;\n};\n\nprototype.rank = function() {\n  return this._rank;\n};\n\nprototype.qrank = function(/* set */) {\n  if (!arguments.length) return this._qrank;\n  return (this._qrank = this._rank, this);\n};\n\nprototype.last = function(stamp) { \n  if (!arguments.length) return this._stamp;\n  return (this._stamp = stamp, this);\n};\n\n// -- status flags ---\n\nprototype._setf = function(v, b) {\n  if (b) { this._flags |= v; } else { this._flags &= ~v; }\n  return this;\n};\n\nprototype.router = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Router);\n  return this._setf(Flags.Router, state);\n};\n\nprototype.collector = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Collector);\n  return this._setf(Flags.Collector, state);\n};\n\nprototype.produces = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Produces);\n  return this._setf(Flags.Produces, state);\n};\n\nprototype.mutates = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Mutates);\n  return this._setf(Flags.Mutates, state);\n};\n\nprototype.reflows = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Reflows);\n  return this._setf(Flags.Reflows, state);\n};\n\nprototype.batch = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Batch);\n  return this._setf(Flags.Batch, state);\n};\n\nprototype.dependency = function(type, deps) {\n  var d = this._deps[type],\n      n = d._names || (d._names = {});  // To prevent dupe deps\n\n  // Get dependencies of the given type\n  if (arguments.length === 1) {\n    return d;\n  }\n\n  if (deps === null) {\n    // Clear dependencies of the given type\n    d.splice(0, d.length);\n    d._names = {};\n  } else if (!Array.isArray(deps)) {\n    // Separate this case to avoid cost of array creation\n    if (n[deps]) return this;\n    d.push(deps);\n    n[deps] = 1;\n  } else {\n    for (var i=0, len=deps.length, dep; i<len; ++i) {\n      dep = deps[i];\n      if (n[dep]) continue;\n      d.push(dep);\n      n[dep] = 1;\n    }\n  }\n\n  return this;\n};\n\nprototype.listeners = function() {\n  return this._listeners;\n};\n\nprototype.addListener = function(l) {\n  if (!(l instanceof Node)) {\n    throw Error('Listener is not a Node');\n  }\n  if (this._listeners._ids[l._id]) return this;\n\n  this._listeners.push(l);\n  this._listeners._ids[l._id] = 1;\n  if (this._rank > l._rank) {\n    var q = [l],\n        g = this._graph, cur;\n    while (q.length) {\n      cur = q.shift();\n      cur._rank = g.rank();\n      q.unshift.apply(q, cur.listeners());\n    }\n  }\n\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  if (!this._listeners._ids[l._id]) return false;\n  \n  var idx = this._listeners.indexOf(l),\n      b = idx >= 0;\n\n  if (b) {\n    this._listeners.splice(idx, 1);\n    this._listeners._ids[l._id] = null;\n  }\n  return b;\n};\n\nprototype.disconnect = function() {\n  this._listeners = [];\n  this._listeners._ids = {};\n};\n\n// Evaluate this dataflow node for the current pulse.\n// Subclasses should override to perform custom processing.\nprototype.evaluate = function(pulse) {\n  return pulse;\n};\n\n// Should this node be re-evaluated for the current pulse?\n// Searches pulse to see if any dependencies have updated.\nprototype.reevaluate = function(pulse) {\n  var prop, dep, i, n, j, m;\n\n  for (i=0, n=DEPS.length; i<n; ++i) {\n    prop = DEPS[i];\n    dep = this._deps[prop];\n    for (j=0, m=dep.length; j<m; ++j) {\n      if (pulse[prop][dep[j]]) return true;\n    }\n  }\n\n  return false;\n};\n\nNode.reset = function() { nodeID = 0; };\n\nmodule.exports = Node;\n\n},{\"./Dependencies\":37}],41:[function(require,module,exports){\nvar ChangeSet = require('./ChangeSet'),\n    Node = require('./Node'), // jshint ignore:line\n    Base = Node.prototype;\n\nfunction Signal(graph, name, initialValue) {\n  Base.init.call(this, graph);\n  this._name  = name;\n  this._value = initialValue;\n  this._verbose = false; // Verbose signals re-pulse the graph even if prev === val.\n  this._handlers = [];\n  return this;\n}\n\nvar prototype = (Signal.prototype = Object.create(Base));\nprototype.constructor = Signal;\n\nprototype.name = function() {\n  return this._name;\n};\n\nprototype.value = function(val) {\n  if (!arguments.length) return this._value;\n  return (this._value = val, this);\n};\n\n// Alias to value, for shared API with DataSource\nprototype.values = prototype.value;\n\nprototype.verbose = function(v) {\n  if (!arguments.length) return this._verbose;\n  return (this._verbose = !!v, this);\n};\n\nprototype.evaluate = function(input) {\n  return input.signals[this._name] ? input : this._graph.doNotPropagate;\n};\n\nprototype.fire = function(cs) {\n  if (!cs) cs = ChangeSet.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nprototype.on = function(handler) {\n  var signal = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    handler(signal.name(), signal.value());\n    return input;\n  };\n\n  this._handlers.push({\n    handler: handler,\n    node: node\n  });\n\n  return this.addListener(node);\n};\n\nprototype.off = function(handler) {\n  var h = this._handlers, i, x;\n\n  for (i=h.length; --i>=0;) {\n    if (!handler || h[i].handler === handler) {\n      x = h.splice(i, 1)[0];\n      this.removeListener(x.node);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = Signal;\n\n},{\"./ChangeSet\":34,\"./Node\":40}],42:[function(require,module,exports){\nvar tupleID = 0;\n\nfunction ingest(datum) {\n  datum = (datum === Object(datum)) ? datum : {data: datum};\n  datum._id = ++tupleID;\n  if (datum._prev) datum._prev = null;\n  return datum;\n}\n\nfunction idMap(a, ids) {\n  ids = ids || {};\n  for (var i=0, n=a.length; i<n; ++i) {\n    ids[a[i]._id] = 1;\n  }\n  return ids;\n}\n\nfunction copy(t, c) {\n  c = c || {};\n  for (var k in t) {\n    if (k !== '_prev' && k !== '_id') c[k] = t[k];\n  }\n  return c;\n}\n\nmodule.exports = {\n  ingest: ingest,\n  idMap: idMap,\n\n  derive: function(d) {\n    return ingest(copy(d));\n  },\n\n  rederive: function(d, t) {\n    return copy(d, t);\n  },\n\n  set: function(t, k, v) {\n    return t[k] === v ? 0 : (t[k] = v, 1);\n  },\n\n  prev: function(t) {\n    return t._prev || t;\n  },\n\n  prev_init: function(t) {\n    if (!t._prev) { t._prev = {_id: t._id}; }\n  },\n\n  prev_update: function(t) {\n    var p = t._prev, k, v;\n    if (p) for (k in t) {\n      if (k !== '_prev' && k !== '_id') {\n        p[k] = ((v=t[k]) instanceof Object && v._prev) ? v._prev : v;\n      }\n    }\n  },\n\n  reset: function() { tupleID = 0; },\n\n  idFilter: function(data) {\n    var ids = {};\n    for (var i=arguments.length; --i>0;) {\n      idMap(arguments[i], ids);\n    }\n    return data.filter(function(x) { return !ids[x._id]; });\n  }\n};\n\n},{}],43:[function(require,module,exports){\nmodule.exports = {\n  ChangeSet:    require('./ChangeSet'),\n  Collector:    require('./Collector'),\n  DataSource:   require('./DataSource'),\n  Dependencies: require('./Dependencies'),\n  Graph:        require('./Graph'),\n  Node:         require('./Node'),\n  Signal:       require('./Signal'),\n  Tuple:        require('./Tuple'),\n  debug:        require('vega-logging').debug\n};\n\n},{\"./ChangeSet\":34,\"./Collector\":35,\"./DataSource\":36,\"./Dependencies\":37,\"./Graph\":38,\"./Node\":40,\"./Signal\":41,\"./Tuple\":42,\"vega-logging\":33}],44:[function(require,module,exports){\nfunction toMap(list) {\n  var map = {}, i, n;\n  for (i=0, n=list.length; i<n; ++i) map[list[i]] = 1;\n  return map;\n}\n\nfunction keys(object) {\n  var list = [], k;\n  for (k in object) list.push(k);\n  return list;\n}\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants'),\n      functions = (opt.functions || require('./functions'))(codegen),\n      idWhiteList = opt.idWhiteList ? toMap(opt.idWhiteList) : null,\n      idBlackList = opt.idBlackList ? toMap(opt.idBlackList) : null,\n      memberDepth = 0,\n      FIELD_VAR = opt.fieldVar || 'datum',\n      GLOBAL_VAR = opt.globalVar || 'signals',\n      globals = {},\n      fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      code: codegen(ast),\n      globals: keys(globals),\n      fields: keys(fields)\n    };\n    globals = {};\n    fields = {};\n    return retval;\n  }\n\n  function lookupGlobal(id) {\n    return GLOBAL_VAR + '[\"' + id + '\"]';\n  }\n\n  function codegen(ast) {\n    if (typeof ast === 'string') return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error('Unsupported type: ' + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    'Literal': function(n) {\n        return n.raw;\n      },\n    'Identifier': function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            globals[id] = 1;\n            return lookupGlobal(id);\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error('Illegal identifier: ' + id);\n        }\n        return id;\n      },\n    'Program': function(n) {\n        return n.body.map(codegen).join('\\n');\n      },\n    'MemberExpression': function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === FIELD_VAR) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? '.'+p : '['+p+']');\n      },\n    'CallExpression': function(n) {\n        if (n.callee.type !== 'Identifier') {\n          throw new Error('Illegal callee type: ' + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error('Unrecognized function: ' + callee);\n        return fn instanceof Function ?\n          fn(args) :\n          fn + '(' + args.map(codegen).join(',') + ')';\n      },\n    'ArrayExpression': function(n) {\n        return '[' + n.elements.map(codegen).join(',') + ']';\n      },\n    'BinaryExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'UnaryExpression': function(n) {\n        return '(' + n.operator + codegen(n.argument) + ')';\n      },\n    'ConditionalExpression': function(n) {\n        return '(' + codegen(n.test) +\n          '?' + codegen(n.consequent) +\n          ':' + codegen(n.alternate) +\n          ')';\n      },\n    'LogicalExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'ObjectExpression': function(n) {\n        return '{' + n.properties.map(codegen).join(',') + '}';\n      },\n    'Property': function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + ':' + codegen(n.value);\n      },\n    'ExpressionStatement': function(n) {\n        return codegen(n.expression);\n      }\n  };\n\n  codegen_wrap.functions = functions;\n  codegen_wrap.constants = constants;\n  return codegen_wrap;\n};\n\n},{\"./constants\":45,\"./functions\":46}],45:[function(require,module,exports){\nmodule.exports = {\n  'NaN':     'NaN',\n  'E':       'Math.E',\n  'LN2':     'Math.LN2',\n  'LN10':    'Math.LN10',\n  'LOG2E':   'Math.LOG2E',\n  'LOG10E':  'Math.LOG10E',\n  'PI':      'Math.PI',\n  'SQRT1_2': 'Math.SQRT1_2',\n  'SQRT2':   'Math.SQRT2'\n};\n},{}],46:[function(require,module,exports){\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + '(' + obj + ')';\n      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';\n    }\n    return obj + '.' + name + (type < 0 ? '' : type === 0 ?\n      '()' :\n      '(' + args.slice(1).map(codegen).join(',') + ')');\n  }\n\n  function fn(name, cast, type) {\n    return function(args) {\n      return fncall(name, args, cast, type);\n    };\n  }\n\n  var DATE = 'new Date',\n      STRING = 'String',\n      REGEXP = 'RegExp';\n\n  return {\n    // MATH functions\n    'isNaN':    'isNaN',\n    'isFinite': 'isFinite',\n    'abs':      'Math.abs',\n    'acos':     'Math.acos',\n    'asin':     'Math.asin',\n    'atan':     'Math.atan',\n    'atan2':    'Math.atan2',\n    'ceil':     'Math.ceil',\n    'cos':      'Math.cos',\n    'exp':      'Math.exp',\n    'floor':    'Math.floor',\n    'log':      'Math.log',\n    'max':      'Math.max',\n    'min':      'Math.min',\n    'pow':      'Math.pow',\n    'random':   'Math.random',\n    'round':    'Math.round',\n    'sin':      'Math.sin',\n    'sqrt':     'Math.sqrt',\n    'tan':      'Math.tan',\n\n    'clamp': function(args) {\n      if (args.length < 3)\n        throw new Error('Missing arguments to clamp function.');\n      if (args.length > 3)\n      throw new Error('Too many arguments to clamp function.');\n      var a = args.map(codegen);\n      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';\n    },\n\n    // DATE functions\n    'now':             'Date.now',\n    'datetime':        DATE,\n    'date':            fn('getDate', DATE, 0),\n    'day':             fn('getDay', DATE, 0),\n    'year':            fn('getFullYear', DATE, 0),\n    'month':           fn('getMonth', DATE, 0),\n    'hours':           fn('getHours', DATE, 0),\n    'minutes':         fn('getMinutes', DATE, 0),\n    'seconds':         fn('getSeconds', DATE, 0),\n    'milliseconds':    fn('getMilliseconds', DATE, 0),\n    'time':            fn('getTime', DATE, 0),\n    'timezoneoffset':  fn('getTimezoneOffset', DATE, 0),\n    'utcdate':         fn('getUTCDate', DATE, 0),\n    'utcday':          fn('getUTCDay', DATE, 0),\n    'utcyear':         fn('getUTCFullYear', DATE, 0),\n    'utcmonth':        fn('getUTCMonth', DATE, 0),\n    'utchours':        fn('getUTCHours', DATE, 0),\n    'utcminutes':      fn('getUTCMinutes', DATE, 0),\n    'utcseconds':      fn('getUTCSeconds', DATE, 0),\n    'utcmilliseconds': fn('getUTCMilliseconds', DATE, 0),\n\n    // shared sequence functions\n    'length':      fn('length', null, -1),\n    'indexof':     fn('indexOf', null),\n    'lastindexof': fn('lastIndexOf', null),\n\n    // STRING functions\n    'parseFloat':  'parseFloat',\n    'parseInt':    'parseInt',\n    'upper':       fn('toUpperCase', STRING, 0),\n    'lower':       fn('toLowerCase', STRING, 0),\n    'slice':       fn('slice', STRING),\n    'substring':   fn('substring', STRING),\n\n    // REGEXP functions\n    'regexp':  REGEXP,\n    'test':    fn('test', REGEXP),\n\n    // Control Flow functions\n    'if': function(args) {\n        if (args.length < 3)\n          throw new Error('Missing arguments to if function.');\n        if (args.length > 3)\n        throw new Error('Too many arguments to if function.');\n        var a = args.map(codegen);\n        return a[0]+'?'+a[1]+':'+a[2];\n      }\n  };\n};\n},{}],47:[function(require,module,exports){\nvar parser = require('./parser'),\n    codegen = require('./codegen');\n    \nvar expr = module.exports = {\n  parse: function(input, opt) {\n      return parser.parse('('+input+')', opt);\n    },\n  code: function(opt) {\n      return codegen(opt);\n    },\n  compiler: function(args, opt) {\n      args = args.slice();\n      var generator = codegen(opt),\n          len = args.length,\n          compile = function(str) {\n            var value = generator(expr.parse(str));\n            args[len] = '\"use strict\"; return (' + value.code + ');';\n            value.fn = Function.apply(null, args);\n            return value;\n          };\n      compile.codegen = generator;\n      return compile;\n    },\n  functions: require('./functions'),\n  constants: require('./constants')\n};\n\n},{\"./codegen\":44,\"./constants\":45,\"./functions\":46,\"./parser\":48}],48:[function(require,module,exports){\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* istanbul ignore next */\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n},{}],49:[function(require,module,exports){\nvar expr = require('vega-expression'),\n    args = ['datum', 'event', 'signals'];\n\nmodule.exports = expr.compiler(args, {\n  idWhiteList: args,\n  fieldVar:    args[0],\n  globalVar:   args[2],\n  functions:   function(codegen) {\n    var fn = expr.functions(codegen);\n    fn.eventItem = function() { return 'event.vg.item'; };\n    fn.eventGroup = 'event.vg.getGroup';\n    fn.eventX = 'event.vg.getX';\n    fn.eventY = 'event.vg.getY';\n    fn.open = 'window.open';\n    return fn;\n  }\n});\n},{\"vega-expression\":47}],50:[function(require,module,exports){\nvar dl = require('datalib'),\n    df = require('vega-dataflow'),\n    log = require('vega-logging'),\n    ChangeSet = df.ChangeSet,\n    Tuple = df.Tuple,\n    Deps = df.Dependencies,\n    Transform = require('./Transform'),\n    Facetor = require('./Facetor');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph);\n\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    summarize: {\n      type: 'custom', \n      set: function(summarize) {\n        var signalDeps = {},\n            tx = this._transform,\n            i, len, f, fields, name, ops;\n\n        if (!dl.isArray(fields = summarize)) { // Object syntax from dl\n          fields = [];\n          for (name in summarize) {\n            ops = dl.array(summarize[name]);\n            fields.push({field: name, ops: ops});\n          }\n        }\n\n        function sg(x) { if (x.signal) signalDeps[x.signal] = 1; }\n\n        for (i=0, len=fields.length; i<len; ++i) {\n          f = fields[i];\n          if (f.field.signal) { signalDeps[f.field.signal] = 1; }\n          dl.array(f.ops).forEach(sg);\n          dl.array(f.as).forEach(sg);\n        }\n\n        tx._fields = fields;\n        tx._aggr = null;\n        tx.dependency(Deps.SIGNALS, dl.keys(signalDeps));\n        return tx;\n      }\n    }\n  });\n\n  this._aggr  = null; // dl.Aggregator\n  this._input = null; // Used by Facetor._on_keep.\n  this._args  = null; // To cull re-computation.\n  this._fields = [];\n  this._out = [];\n\n  this._type = TYPES.TUPLE; \n  this._acc = {groupby: dl.true, value: dl.true};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Aggregate.prototype = Object.create(Transform.prototype));\nprototype.constructor = Aggregate;\n\nvar TYPES = Aggregate.TYPES = {\n  VALUE: 1, \n  TUPLE: 2, \n  MULTI: 3\n};\n\nAggregate.VALID_OPS = [\n  'values', 'count', 'valid', 'missing', 'distinct', \n  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev', \n  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max', \n  'argmin', 'argmax'\n];\n\nprototype.type = function(type) { \n  return (this._type = type, this); \n};\n\nprototype.accessors = function(groupby, value) {\n  var acc = this._acc;\n  acc.groupby = dl.$(groupby) || dl.true;\n  acc.value = dl.$(value) || dl.true;\n};\n\nprototype.aggr = function() {\n  if (this._aggr) return this._aggr;\n\n  var g = this._graph,\n      hasGetter = false,\n      args = [],\n      groupby = this.param('groupby').field,\n      value = function(x) { return x.signal ? g.signalRef(x.signal) : x; };\n\n  // Prepare summarize fields.\n  var fields = this._fields.map(function(f) {\n    var field = {\n      name: value(f.field),\n      as:   dl.array(f.as),\n      ops:  dl.array(value(f.ops)).map(value),\n      get:  f.get\n    };\n    hasGetter = hasGetter || field.get != null;\n    args.push(field.name);\n    return field;\n  });\n\n  // If there is an arbitrary getter, all bets are off.\n  // Otherwise, we can check argument fields to cull re-computation.\n  groupby.forEach(function(g) {\n    if (g.get) hasGetter = true;\n    args.push(g.name || g);\n  });\n  this._args = hasGetter || !fields.length ? null : args;\n\n  if (!fields.length) fields = {'*': 'values'};\n\n  // Instatiate our aggregator instance.\n  // Facetor is a special subclass that can facet into data pipelines.\n  var aggr = this._aggr = new Facetor()\n    .groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  // Collect output fields sets by this aggregate.\n  this._out = getFields(aggr);\n\n  // If we are processing tuples, key them by '_id'.\n  if (this._type !== TYPES.VALUE) { aggr.key('_id'); }\n\n  return aggr;\n};\n\nfunction getFields(aggr) {\n  // Collect the output fields set by this aggregate.\n  var f = [], i, n, j, m, dims, vals, meas;\n\n  dims = aggr._dims;\n  for (i=0, n=dims.length; i<n; ++i) {\n    f.push(dims[i].name);\n  }\n\n  vals = aggr._aggr;\n  for (i=0, n=vals.length; i<n; ++i) {\n    meas = vals[i].measures.fields;\n    for (j=0, m=meas.length; j<m; ++j) {\n      f.push(meas[j]);\n    }\n  }\n\n  return f;\n}\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['aggregate']);\n\n  var output = ChangeSet.create(input),\n      aggr = this.aggr(),\n      out = this._out,\n      args = this._args,\n      reeval = true,\n      p = Tuple.prev,\n      add, rem, mod, i;\n\n  // Upon reset, retract prior tuples and re-initialize.\n  if (reset) {\n    output.rem.push.apply(output.rem, aggr.result());\n    aggr.clear();\n    this._aggr = null;\n    aggr = this.aggr();\n  }\n\n  // Get update methods according to input type.\n  if (this._type === TYPES.TUPLE) {\n    add = function(x) { aggr._add(x); Tuple.prev_init(x); };\n    rem = function(x) { aggr._rem(p(x)); };\n    mod = function(x) { aggr._mod(x, p(x)); };\n  } else {\n    var gby = this._acc.groupby,\n        val = this._acc.value,\n        get = this._type === TYPES.VALUE ? val : function(x) {\n          return { _id: x._id, groupby: gby(x), value: val(x) };\n        };\n    add = function(x) { aggr._add(get(x)); Tuple.prev_init(x); };\n    rem = function(x) { aggr._rem(get(p(x))); };\n    mod = function(x) { aggr._mod(get(x), get(p(x))); };\n  }\n\n  input.add.forEach(add);\n  if (reset) {\n    // A signal change triggered reflow. Add everything.\n    // No need for rem, we cleared the aggregator.\n    input.mod.forEach(add);\n  } else {\n    input.rem.forEach(rem);\n\n    // If possible, check argument fields to see if we need to re-process mods.\n    if (args) for (i=0, reeval=false; i<args.length; ++i) {\n      if (input.fields[args[i]]) { reeval = true; break; }\n    }\n    if (reeval) input.mod.forEach(mod);\n  }\n\n  // Indicate output fields and return aggregate tuples.\n  for (i=0; i<out.length; ++i) {\n    output.fields[out[i]] = 1;\n  }\n  return (aggr._input = input, aggr.changes(output));\n};\n\nmodule.exports = Aggregate;\n},{\"./Facetor\":51,\"./Transform\":53,\"datalib\":27,\"vega-dataflow\":43,\"vega-logging\":33}],51:[function(require,module,exports){\nvar dl = require('datalib'),\n    Aggregator = dl.Aggregator,\n    Base = Aggregator.prototype,\n    df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    facetID = 0;\n\nfunction Facetor() {\n  Aggregator.call(this);\n  this._facet = null;\n  this._facetID = ++facetID;\n}\n\nvar prototype = (Facetor.prototype = Object.create(Base));\nprototype.constructor = Facetor;\n\nprototype.facet = function(f) {\n  return arguments.length ? (this._facet = f, this) : this._facet;\n};\n\nprototype._ingest = function(t) { \n  return Tuple.ingest(t, null);\n};\n\nprototype._assign = Tuple.set;\n\nfunction disconnect_cell(facet) {\n  log.debug({}, ['disconnecting cell', this.tuple._id]);\n  var pipeline = this.ds.pipeline();\n  facet.removeListener(pipeline[0]);\n  facet._graph.removeListener(pipeline[0]);\n  facet._graph.disconnect(pipeline);\n}\n\nprototype._newcell = function(x, key) {\n  var cell  = Base._newcell.call(this, x, key),\n      facet = this._facet;\n\n  if (facet) {\n    var graph = facet._graph,\n        tuple = cell.tuple,\n        pipeline = facet.param('transform');\n    cell.ds = graph.data(tuple._facetID, pipeline, tuple);\n    cell.disconnect = disconnect_cell;\n    facet.addListener(pipeline[0]);\n  }\n\n  return cell;\n};\n\nprototype._newtuple = function(x, key) {\n  var t = Base._newtuple.call(this, x);\n  if (this._facet) {\n    Tuple.set(t, 'key', key);\n    Tuple.set(t, '_facetID', this._facetID + '_' + key);\n  }\n  return t;\n};\n\nprototype.clear = function() {\n  if (this._facet) {\n    for (var k in this._cells) {\n      this._cells[k].disconnect(this._facet);\n    }\n  }\n  return Base.clear.call(this);\n};\n\nprototype._on_add = function(x, cell) {\n  if (this._facet) cell.ds._input.add.push(x);\n};\n\nprototype._on_rem = function(x, cell) {\n  if (this._facet) cell.ds._input.rem.push(x);\n};\n\nprototype._on_mod = function(x, prev, cell0, cell1) {\n  if (this._facet) { // Propagate tuples\n    if (cell0 === cell1) {\n      cell0.ds._input.mod.push(x);\n    } else {\n      cell0.ds._input.rem.push(x);\n      cell1.ds._input.add.push(x);\n    }\n  }\n};\n\nprototype._on_drop = function(cell) {\n  if (this._facet) cell.disconnect(this._facet);\n};\n\nprototype._on_keep = function(cell) {\n  // propagate sort, signals, fields, etc.\n  if (this._facet) df.ChangeSet.copy(this._input, cell.ds._input);\n};\n\nmodule.exports = Facetor;\n},{\"datalib\":27,\"vega-dataflow\":43,\"vega-logging\":33}],52:[function(require,module,exports){\nvar dl = require('datalib'),\n    Deps = require('vega-dataflow').Dependencies,\n    expr = require('../parse/expr');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i,\n    valType   = /value/i;\n\nfunction Parameter(name, type, transform) {\n  this._name = name;\n  this._type = type;\n  this._transform = transform;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar prototype = Parameter.prototype;\n\nfunction get() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  var val = isArray ? this._value : this._value[0],\n      acc = isArray ? this._accessors : this._accessors[0];\n\n  if (!dl.isValid(acc) && valType.test(this._type)) {\n    return val;\n  } else {\n    return isData ? { name: val, source: acc } :\n    isField ? { field: val, accessor: acc } : val;\n  }\n}\n\nprototype.get = function() {\n  var graph = this._transform._graph, \n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return get.call(this);\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return get.call(this); // TODO: support signal as dataTypes\n  }\n\n  for (s in this._signals) {\n    idx = this._signals[s];\n    val = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return get.call(this);\n};\n\nprototype.set = function(value) {\n  var p = this,\n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        p._transform.dependency(Deps.FIELDS,  e.fields);\n        p._transform.dependency(Deps.SIGNALS, e.globals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        p._accessors[i] = dl.accessor(v);\n        p._transform.dependency(Deps.FIELDS, dl.field(v));\n      } else if (isData) {\n        p._resolution = true;\n        p._transform.dependency(Deps.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      p._accessors[i] = dl.accessor(v.field);\n      p._transform.dependency(Deps.FIELDS, dl.field(v.field));\n      return v.field;\n    } else if (v.signal !== undefined) {\n      p._resolution = true;\n      p._signals[v.signal] = i;\n      p._transform.dependency(Deps.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return p._transform;\n};\n\nmodule.exports = Parameter;\n},{\"../parse/expr\":49,\"datalib\":27,\"vega-dataflow\":43}],53:[function(require,module,exports){\nvar df = require('vega-dataflow'),\n    Base = df.Node.prototype, // jshint ignore:line\n    Deps = df.Dependencies,\n    Parameter = require('./Parameter');\n\nfunction Transform(graph) {\n  if (graph) Base.init.call(this, graph);\n}\n\nTransform.addParameters = function(proto, params) {\n  proto._parameters = proto._parameters || {};\n  for (var name in params) {\n    var p = params[name],\n        param = new Parameter(name, p.type, proto);\n\n    proto._parameters[name] = param;\n\n    if (p.type === 'custom') {\n      if (p.set) param.set = p.set.bind(param);\n      if (p.get) param.get = p.get.bind(param);\n    }\n\n    if (p.hasOwnProperty('default')) param.set(p.default);\n  }\n};\n\nvar prototype = (Transform.prototype = Object.create(Base));\nprototype.constructor = Transform;\n\nprototype.param = function(name, value) {\n  var param = this._parameters[name];\n  return (param === undefined) ? this :\n    (arguments.length === 1) ? param.get() : param.set(value);\n};\n\n// Perform transformation. Subclasses should override.\nprototype.transform = function(input/*, reset */) {\n  return input;\n};\n\nprototype.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp &&\n    this.dependency(Deps.SIGNALS).reduce(function(c, s) {\n      return c += input.signals[s] ? 1 : 0;\n    }, 0);\n  return this.transform(input, reset);\n};\n\nprototype.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n},{\"./Parameter\":52,\"vega-dataflow\":43}],54:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlEncDef = require('./encdef'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.encDef = function(et) {\n    return this._enc[et];\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    return vlEncDef.fieldRef(this._enc[et], opt);\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlEncDef.isCount(this._enc[et])) {\n      return vlEncDef.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.encDef(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlEncDef.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var encDef = this.encDef(et);\n    return encDef && vlEncDef.isType(encDef, type);\n  };\n\n\n  proto.isTypes = function(et, type) {\n    var encDef = this.encDef(et);\n    return encDef && vlEncDef.isTypes(encDef, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlEncDef.isOrdinalScale(encoding.encDef(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlEncDef.isDimension(encoding.encDef(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlEncDef.isMeasure(encoding.encDef(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  proto.dataTable = function() {\n    return this.isAggregate() ? AGGREGATE : RAW;\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  /**\n   * Check if the encoding should be stacked and return the stack dimenstion and value fields.\n   * @return {Object} An object containing two properties:\n   * - dimension - the dimension field\n   * - value - the value field\n   */\n  proto.stack = function() {\n    var stack = (this.has(COLOR) && this.encDef(COLOR).stack) ? COLOR :\n          (this.has(DETAIL) && this.encDef(DETAIL).stack) ? DETAIL :\n          null;\n\n    var properties = stack && this.encDef(stack).stack !== true ?\n                       this.encDef(stack).stack :\n                       {};\n\n    if ((this.is('bar') || this.is('area')) && stack && this.isAggregate()) {\n\n      var isXMeasure = this.isMeasure(X);\n      var isYMeasure = this.isMeasure(Y);\n\n      if (isXMeasure && !isYMeasure) {\n        return {\n          groupby: Y,\n          value: X,\n          stack: stack,\n          properties: properties\n        };\n      } else if (isYMeasure && !isXMeasure) {\n        return {\n          groupby: X,\n          value: Y,\n          stack: stack,\n          properties: properties\n        };\n      }\n    }\n    return null; // no stack encoding\n  };\n\n\n\n  proto.details = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType !== X && encType !== Y)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.facets = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType == ROW || encType == COL)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlEncDef.cardinality(this.encDef(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function() {\n    return this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data().values;\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  return Encoding;\n})();\n\n},{\"./consts\":67,\"./enc\":69,\"./encdef\":70,\"./globals\":71,\"./schema/schema\":73,\"./util\":75}],55:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  // TODO: rename def to axisDef and avoid side effects where possible.\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.encDef(name).axis.layer\n  };\n\n  var orient = axis.orient(encoding, name, stats);\n  if (orient) {\n    def.orient = orient;\n  }\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, encoding, name, stats);\n  def = axis.labels.angle(def, encoding, name);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if ((encoding.isDimension(X) || encoding.isType(X, T)) &&\n        !('angle' in getter(def, ['properties', 'labels']))) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.encDef(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, encoding, name, layout);\n  def = axis.title(def, encoding, name, layout, opt);\n\n  if (isRow || isCol) {\n    def = axis.hideTicks(def);\n  }\n\n  return def;\n};\n\naxis.orient = function(encoding, name, stats) {\n  var orient = encoding.encDef(name).axis.orient;\n  if (orient) {\n    return orient;\n  } else if (name === COL) {\n    return 'top';\n  } else if (name === X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    // x-axis for long y - put on top\n    return 'top';\n  }\n  return undefined;\n};\n\naxis.grid = function(def, encoding, name, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  var _grid = encoding.axis(name).grid;\n\n  // If `grid` is unspecified, the default value is `true` for ROW and COL. For X\n  // and Y, the default value is `true` for quantitative and time fields and `false` otherwise.\n  var grid = _grid === undefined ?\n    (name === ROW || name === COL || encoding.isTypes(name, [Q, T])) :\n    _grid;\n\n  if (grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      var yOffset = encoding.config('cellGridOffset');\n\n      // TODO(#677): this should depend on orient\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col',\n          field: 'data'\n        },\n        y: {\n          value: -yOffset,\n        },\n        y2: {\n          field: {group: 'mark.group.height'},\n          offset: yOffset\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        strokeOpacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      var xOffset = encoding.config('cellGridOffset');\n\n      // TODO(#677): this should depend on orient\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row',\n          field: 'data'\n        },\n        x: {\n          value: def.offset - xOffset\n        },\n        x2: {\n          field: {group: 'mark.group.width'},\n          offset: def.offset + xOffset,\n          // default value(s) -- vega doesn't do recursive merge\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        strokeOpacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        strokeOpacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, encoding, name, layout) {\n  var ax = encoding.encDef(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.encDef(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, encoding, name, stats) {\n  var fieldStats = stats[encoding.encDef(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.encDef(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{ datum.data | truncate:' +\n      encoding.axis(name).maxLabelLength + '}}'\n    );\n  }\n\n  return def;\n};\n\naxis.labels.angle = function(def, encoding, name) {\n  var angle = encoding.axis(name).labelAngle;\n  if (typeof angle === 'undefined') return def;\n\n  setter(def, ['properties', 'labels', 'angle', 'value'], angle);\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n\n},{\"../globals\":71,\"../util\":75,\"./time\":66}],56:[function(require,module,exports){\n'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\n/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.data = require('./data');\ncompiler.facet = require('./facet');\ncompiler.layout = require('./layout');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\n/**\n * Create a Vega specification from a Vega-lite Encoding object.\n */\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats) {\n    if (encoding.hasValues()) {\n        stats = summary(encoding.data().values).reduce(function(s, p) {\n        s[p.field] = p;\n        return s;\n      }, {});\n    } else {\n      console.error('No stats provided and data is not embedded.');\n    }\n  }\n\n  var layout = compiler.layout(encoding, stats);\n\n  var spec = {\n      width: layout.width,\n      height: layout.height,\n      padding: 'auto',\n      data: compiler.data(encoding),\n      // global scales contains only time unit scales\n      scales: compiler.time.scales(encoding),\n      marks: [{\n        name: 'cell',\n        type: 'group',\n        properties: {\n          enter: {\n            width: layout.cellWidth ?\n                     {value: layout.cellWidth} :\n                     {field: {group: 'width'}},\n            height: layout.cellHeight ?\n                    {value: layout.cellHeight} :\n                    {field: {group: 'height'}}\n          }\n        }\n      }]\n    };\n\n  var group = spec.marks[0];\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    mdefs = group.marks = marks.def(encoding, layout, style, stats),\n    mdef = mdefs[mdefs.length - 1];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  var stack = encoding.stack();\n  if (stack) {\n    // modify mdef.{from,properties}\n    compiler.stack(encoding, mdef, stack);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n  var details = encoding.details();\n\n  if (details.length > 0 && lineType) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, encoding);\n  }\n\n  // auto-sort line/area values\n  if (lineType && encoding.config('autoSortLine')) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) {\n      mdef.from = {};\n    }\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // get a flattened list of all scale names that are used in the vl spec\n  var singleScaleNames = [].concat.apply([], mdefs.map(function(markProps) {\n    return scale.names(markProps.properties.update);\n  }));\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, spec, singleScaleNames, stats);\n    spec.legends = legend.defs(encoding, style);\n  } else {\n    group.scales = scale.defs(singleScaleNames, encoding, layout, stats);\n    group.axes = [];\n    if (encoding.has(X)) {\n      group.axes.push(axis.def(X, encoding, layout, stats));\n    }\n    if (encoding.has(Y)) {\n      group.axes.push(axis.def(Y, encoding, layout, stats));\n    }\n\n    group.legends = legend.defs(encoding, style);\n  }\n\n  return spec;\n};\n\n},{\"../Encoding\":54,\"../globals\":71,\"./axis\":55,\"./data\":57,\"./facet\":58,\"./layout\":59,\"./legend\":60,\"./marks\":61,\"./scale\":62,\"./stack\":63,\"./style\":64,\"./subfacet\":65,\"./time\":66,\"datalib/src/stats\":29}],57:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = data;\n\nvar vlEncDef = require('../encdef'),\n  util = require('../util'),\n  time = require('./time');\n\n/**\n * Create Vega's data array from a given encoding.\n *\n * @param  {Encoding} encoding\n * @return {Array} Array of Vega data.\n *                 This always includes a \"raw\" data table.\n *                 If the encoding contains aggregate value, this will also create\n *                 aggregate table as well.\n */\nfunction data(encoding) {\n  var def = [data.raw(encoding)];\n\n  var aggregate = data.aggregate(encoding);\n  if (aggregate) {\n    def.push(data.aggregate(encoding));\n  }\n\n  // TODO add \"having\" filter here\n\n  // append non-positive filter at the end for the data table\n  data.filterNonPositive(def[def.length - 1], encoding);\n\n  // Stack\n  var stack = encoding.stack();\n  if (stack) {\n    def.push(data.stack(encoding, stack));\n  }\n\n  return def;\n}\n\ndata.raw = function(encoding) {\n  var raw = {name: RAW};\n\n  // Data source (url or inline)\n  if (encoding.hasValues()) {\n    raw.values = encoding.data().values;\n    raw.format = {type: 'json'};\n  } else {\n    raw.url = encoding.data().url;\n    raw.format = {type: encoding.data().formatType};\n  }\n\n  // Set data's format.parse if needed\n  var parse = data.raw.formatParse(encoding);\n  if (parse) {\n    raw.format.parse = parse;\n  }\n\n  raw.transform = data.raw.transform(encoding);\n  return raw;\n};\n\ndata.raw.formatParse = function(encoding) {\n  var parse;\n\n  encoding.forEach(function(encDef) {\n    if (encDef.type == T) {\n      parse = parse || {};\n      parse[encDef.name] = 'date';\n    } else if (encDef.type == Q) {\n      if (vlEncDef.isCount(encDef)) return;\n      parse = parse || {};\n      parse[encDef.name] = 'number';\n    }\n  });\n\n  return parse;\n};\n\n/**\n * Generate Vega transforms for the raw data table.  This can include\n * transforms for time unit, binning and filtering.\n */\ndata.raw.transform = function(encoding) {\n  // null filter comes first so transforms are not performed on null values\n  // time and bin should come before filter so we can filter by time and bin\n  return data.raw.transform.nullFilter(encoding).concat(\n    data.raw.transform.formula(encoding),\n    data.raw.transform.time(encoding),\n    data.raw.transform.bin(encoding),\n    data.raw.transform.filter(encoding)\n  );\n};\n\ndata.raw.transform.time = function(encoding) {\n  return encoding.reduce(function(transform, encDef, encType) {\n    if (encDef.type === T && encDef.timeUnit) {\n      var fieldRef = encoding.fieldRef(encType, {nofn: true, datum: true});\n\n      transform.push({\n        type: 'formula',\n        field: encoding.fieldRef(encType),\n        expr: time.formula(encDef.timeUnit, fieldRef)\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.bin = function(encoding) {\n  return encoding.reduce(function(transform, encDef, encType) {\n    if (encoding.bin(encType)) {\n      transform.push({\n        type: 'bin',\n        field: encDef.name,\n        output: {start: encoding.fieldRef(encType)},\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n    return transform;\n  }, []);\n};\n\n/**\n * @return {Array} An array that might contain a filter transform for filtering null value based on filterNul config\n */\ndata.raw.transform.nullFilter = function(encoding) {\n  var filteredFields = util.reduce(encoding.fields(),\n    function(filteredFields, fieldList, fieldName) {\n      if (fieldName === '*') return filteredFields; //count\n\n      // TODO(#597) revise how filterNull is structured.\n      if ((encoding.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (encoding.config('filterNull').T && fieldList.containsType[T]) ||\n          (encoding.config('filterNull').O && fieldList.containsType[O]) ||\n          (encoding.config('filterNull').N && fieldList.containsType[N])) {\n        filteredFields.push(fieldName);\n      }\n      return filteredFields;\n    }, []);\n\n  return filteredFields.length > 0 ?\n    [{\n      type: 'filter',\n      test: filteredFields.map(function(fieldName) {\n        return 'datum.' + fieldName + '!==null';\n      }).join(' && ')\n    }] : [];\n};\n\ndata.raw.transform.filter = function(encoding) {\n  var filter = encoding.data().filter;\n  return filter ? [{\n      type: 'filter',\n      test: filter\n  }] : [];\n};\n\ndata.raw.transform.formula = function(encoding) {\n  var formulas = encoding.data().formulas;\n  if (formulas === undefined) {\n    return [];\n  }\n\n  return formulas.reduce(function(transform, formula) {\n    formula.type = 'formula';\n    transform.push(formula);\n    return transform;\n  }, []);\n};\n\ndata.aggregate = function(encoding) {\n  /* dict set for dimensions */\n  var dims = {};\n\n  /* dictionary mapping field name => dict set of aggregation functions */\n  var meas = {};\n\n  var hasAggregate = false;\n\n  encoding.forEach(function(encDef, encType) {\n    if (encDef.aggregate) {\n      hasAggregate = true;\n      if (encDef.aggregate === 'count') {\n        meas['*'] = meas['*'] || {};\n        meas['*'].count = true;\n      } else {\n        meas[encDef.name] = meas[encDef.name] || {};\n        meas[encDef.name][encDef.aggregate] = true;\n      }\n    } else {\n      dims[encDef.name] = encoding.fieldRef(encType);\n    }\n  });\n\n  var groupby = util.vals(dims);\n\n  // short-format summarize object for Vega's aggregate transform\n  // https://github.com/vega/vega/wiki/Data-Transforms#-aggregate\n  var summarize = util.reduce(meas, function(summarize, fnDictSet, field) {\n    summarize[field] = util.keys(fnDictSet);\n    return summarize;\n  }, {});\n\n  if (hasAggregate) {\n    return {\n      name: AGGREGATE,\n      source: RAW,\n      transform: [{\n        type: 'aggregate',\n        groupby: groupby,\n        summarize: summarize\n      }]\n    };\n  }\n\n  return null;\n};\n\n/**\n * Add stacked data source, for feeding the shared scale.\n */\ndata.stack = function(encoding, stack) {\n  var dim = stack.groupby;\n  var val = stack.value;\n  var facets = encoding.facets();\n\n  var stacked = {\n    name: STACKED,\n    source: encoding.dataTable(),\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      summarize: [{ops: ['sum'], field: encoding.fieldRef(val)}]\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      summarize: [{\n        ops: ['max'],\n        // we want max of sum from above transform\n        field: encoding.fieldRef(val, {prefn: 'sum_'})\n      }]\n    });\n  }\n  return stacked;\n};\n\ndata.filterNonPositive = function(dataTable, encoding) {\n  encoding.forEach(function(encDef, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: encoding.fieldRef(encType, {datum: 1}) + ' > 0'\n      });\n    }\n  });\n};\n\n},{\"../encdef\":70,\"../globals\":71,\"../util\":75,\"./time\":66}],58:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  var group = {\n    name: name || undefined,\n    type: 'group',\n    properties: {\n      enter: {\n        width: opt.width || {field: {group: 'width'}},\n        height: opt.height || {field: {group: 'height'}}\n      }\n    }\n  };\n\n  if (opt.from) {\n    group.from = opt.from;\n  }\n  if (opt.x) {\n    group.properties.enter.x = opt.x;\n  }\n  if (opt.y) {\n    group.properties.enter.y = opt.y;\n  }\n  if (opt.axes) {\n    group.axes = opt.axes;\n  }\n\n  return group;\n}\n\nfunction faceting(group, encoding, layout, spec, singleScaleNames, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: encoding.fieldRef(ROW)};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', groupby: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? [axis.def(X, encoding, layout, stats)] : undefined,\n        x: hasCol ? {scale: COL, field: encoding.fieldRef(COL)} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(ROW, encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push(axis.def(X, encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: encoding.fieldRef(COL)};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', groupby: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? [axis.def(Y, encoding, layout, stats)] : undefined,\n      y: hasRow && {scale: ROW, field: encoding.fieldRef(ROW)},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(COL, encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push(axis.def(Y, encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(singleScaleNames),\n    encoding,\n    layout,\n    stats,\n    true\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', groupby: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":71,\"../util\":75,\"./axis\":55,\"./scale\":62}],59:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.encDef(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.encDef(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.encDef(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.encDef(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\n// TODO(#600) revise this\nfunction getMaxLength(encoding, stats, et) {\n  var encDef = encoding.encDef(et),\n    fieldStats = stats[encDef.name];\n\n  if (encDef.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.encDef(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.encDef(et).aggregate === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n\n},{\"../globals\":71,\"../util\":75,\"./time\":66,\"d3-format\":5}],60:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar time = require('./time'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter;\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding, style) {\n  var defs = [];\n\n  if (encoding.has(COLOR) && encoding.encDef(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR\n    }, style));\n  }\n\n  if (encoding.has(SIZE) && encoding.encDef(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE\n    }, style));\n  }\n\n  if (encoding.has(SHAPE) && encoding.encDef(SHAPE).legend) {\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE\n    }, style));\n  }\n  return defs;\n};\n\nlegend.def = function(name, encoding, def, style) {\n  var timeUnit = encoding.encDef(name).timeUnit;\n\n  def.title = legend.title(name, encoding);\n  def.orient = encoding.encDef(name).legend.orient;\n\n  def = legend.style(name, encoding, def, style);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    setter(def, ['properties', 'labels', 'text', 'scale'], 'time-'+ timeUnit);\n  }\n\n  return def;\n};\n\nlegend.style = function(name, e, def, style) {\n  var symbols = getter(def, ['properties', 'symbols']),\n    marktype = e.marktype();\n\n  switch (marktype) {\n    case 'bar':\n    case 'tick':\n    case 'text':\n      symbols.stroke = {value: 'transparent'};\n      symbols.shape = {value: 'square'};\n      break;\n\n    case 'circle':\n    case 'square':\n      symbols.shape = {value: marktype};\n      /* fall through */\n    case 'point':\n      // fill or stroke\n      if (e.encDef(SHAPE).filled) {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.fill = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.fill = {value: e.value(COLOR)};\n        }\n        symbols.stroke = {value: 'transparent'};\n      } else {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.stroke = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.stroke = {value: e.value(COLOR)};\n        }\n        symbols.fill = {value: 'transparent'};\n        symbols.strokeWidth = {value: e.config('strokeWidth')};\n      }\n\n      break;\n    case 'line':\n    case 'area':\n      // TODO use shape here after implementing #508\n      break;\n  }\n\n  var opacity = e.encDef(COLOR).opacity || style.opacity;\n  if (opacity) {\n    symbols.opacity = {value: opacity};\n  }\n  return def;\n};\n\nlegend.title = function(name, encoding) {\n  var leg = encoding.encDef(name).legend;\n\n  if (leg.title) return leg.title;\n\n  return encoding.fieldTitle(name);\n};\n\n},{\"../globals\":71,\"../util\":75,\"./time\":66}],61:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(encoding, layout, style, stats) {\n\n  var defs = [],\n    mark = marks[encoding.marktype()],\n    from = encoding.dataTable();\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: from},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: from},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {field: {group: 'height'}};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {\n        field: {group: 'height'},\n        offset: -e.config('singleBarOffset')\n      };\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.encDef(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // fill or stroke\n  if (e.encDef(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.encDef(COLOR).opacity || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {field: {group: 'height'}};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.encDef(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {field: {group: 'height'}};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.encDef(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.encDef(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.encDef(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    encDef = e.encDef(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: encDef.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: encDef.color};\n\n  var opacity = e.encDef(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.encDef(TEXT).name],\n        numberFormat = encDef.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT, {datum: true}) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: encDef.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: encDef.placeholder};\n  }\n\n  p.font = {value: encDef.font.family};\n  p.fontWeight = {value: encDef.font.weight};\n  p.fontStyle = {value: encDef.font.style};\n  p.baseline = {value: encDef.baseline};\n\n  return p;\n}\n\n},{\"../globals\":71}],62:[function(require,module,exports){\n'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolate = require('d3-color').interpolateHsl,\n  schema = require('../schema/schema');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, facet) {\n  return names.reduce(function(a, name) {\n    var scaleDef = {};\n\n    scaleDef.name = name;\n    scaleDef.type = scale.type(name, encoding);\n    scaleDef.domain = scale.domain(encoding, name, scaleDef.type, stats, facet);\n\n    // add `reverse` if applicable\n    var reverse = scale.reverse(encoding, name);\n    if (reverse) {\n      scaleDef.reverse = reverse;\n    }\n\n    scaleDef = scale.range(scaleDef, encoding, layout, stats);\n\n    return (a.push(scaleDef), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.encDef(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        // TODO: revise this\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (encoding, name, type, stats, facet) {\n  var encDef = encoding.encDef(name);\n\n  // special case for temporal scale\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encDef.timeUnit, name);\n    if (range) return range;\n  }\n\n  // For binned, produce fixed stepped domain.\n  // TODO(#614): this must be changed in vg2\n  if (encDef.bin) {\n\n    var fieldStat = stats[encDef.name],\n      bins = util.getbins(fieldStat, encDef.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  // For stack, use STACKED data.\n  var stack = encoding.stack();\n  if (stack && name === stack.value) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        // If faceted, scale is determined by the max of sum in each facet.\n        prefn: (facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n\n  var useRawDomain = scale._useRawDomain(encoding, name);\n  var sort = scale.sort(encoding, name, type);\n\n  if (useRawDomain) {\n    return {\n      data: RAW,\n      field: encoding.fieldRef(name, {noAggregate:true})\n    };\n  } else if (sort) { // have sort\n    return {\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: sort.op ? RAW : encoding.dataTable(),\n      field: encoding.fieldRef(name),\n      sort: sort\n    };\n  } else {\n    return {\n      data: encoding.dataTable(),\n      field: encoding.fieldRef(name)\n    };\n  }\n};\n\nscale.sort = function(encoding, name, type) {\n  var sort = encoding.encDef(name).sort;\n  if (sort === 'ascending' || sort === 'descending') {\n    return true;\n  }\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (type === 'ordinal' && util.isObject(sort)) {\n    return {\n      op: sort.op,\n      field: sort.field\n    };\n  }\n  return undefined;\n};\n\nscale.reverse = function(encoding, name) {\n  var sort = encoding.encDef(name).sort;\n  return sort && (sort === 'descending' || (sort.order === 'descending'));\n};\n\n/**\n * Determine if useRawDomain should be activated for this scale.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `useRawDomain` is enabled either through scale or config\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nscale._useRawDomain = function (encoding, name) {\n  var encDef = encoding.encDef(name);\n\n  // scale value\n  var scaleUseRawDomain = encoding.scale(name).useRawDomain;\n\n  // Determine if useRawDomain is enabled. If scale value is specified, use scale value.\n  // Otherwise, use config value.\n  var useRawDomainEnabled = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain');\n\n  var notCountOrSum = !encDef.aggregate ||\n    (encDef.aggregate !=='count' && encDef.aggregate !== 'sum');\n\n  return  useRawDomainEnabled &&\n    notCountOrSum && (\n      // Q always uses quantitative scale except when it's binned and thus uses ordinal scale.\n      (\n        encoding.isType(name, Q) &&\n        !encDef.bin // TODO(#614): this must be changed once bin is reimplemented\n      ) ||\n      // TODO: revise this\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (\n        encoding.isType(name, T) &&\n        (!encDef.timeUnit || !time.isOrdinalFn(encDef.timeUnit))\n      )\n    );\n};\n\n\nscale.range = function (scaleDef, encoding, layout, stats) {\n  var spec = encoding.scale(scaleDef.name),\n    encDef = encoding.encDef(scaleDef.name),\n    timeUnit = encDef.timeUnit;\n\n  switch (scaleDef.name) {\n    case X:\n      scaleDef.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (scaleDef.type === 'ordinal') {\n        scaleDef.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(scaleDef.name,T) && timeUnit === 'year') {\n          scaleDef.zero = false;\n        } else {\n          scaleDef.zero = spec.zero === undefined ? true : spec.zero;\n        }\n      }\n      scaleDef.round = true;\n      if (scaleDef.type === 'time') {\n        scaleDef.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        scaleDef.nice = true;\n      }\n      break;\n    case Y:\n      if (scaleDef.type === 'ordinal') {\n        scaleDef.range = layout.cellHeight ?\n          (encDef.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        scaleDef.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        scaleDef.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(scaleDef.name,T) && timeUnit === 'year') {\n          scaleDef.zero = false;\n        } else {\n          scaleDef.zero = spec.zero === undefined ? true : spec.zero;\n        }\n      }\n\n      scaleDef.round = true;\n\n      if (scaleDef.type === 'time') {\n        scaleDef.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        scaleDef.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      scaleDef.bandWidth = layout.cellHeight;\n      scaleDef.round = true;\n      scaleDef.nice = true;\n      break;\n    case COL: // support only ordinal\n      scaleDef.bandWidth = layout.cellWidth;\n      scaleDef.round = true;\n      scaleDef.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        scaleDef.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        scaleDef.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        scaleDef.range = [10, 0.8 * bandSize*bandSize];\n      }\n      scaleDef.round = true;\n      scaleDef.zero = false;\n      break;\n    case SHAPE:\n      scaleDef.range = 'shapes';\n      break;\n    case COLOR:\n      scaleDef.range = scale.color(scaleDef, encoding, stats);\n      if (scaleDef.type !== 'ordinal') scaleDef.zero = false;\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ scaleDef.name);\n  }\n\n  // FIXME(kanitw): Jul 29, 2015 - consolidate this with above\n  switch (scaleDef.name) {\n    case ROW:\n    case COL:\n      scaleDef.padding = encoding.config('cellPadding');\n      scaleDef.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (scaleDef.type === 'ordinal') { //&& !s.bandWidth\n        scaleDef.points = true;\n        scaleDef.padding = encoding.encDef(scaleDef.name).band.padding;\n      }\n  }\n\n  return scaleDef;\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette,\n      quantitativeRange = colorScale.quantitativeRange;\n\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n        return scale.color.palette(range, cardinality, type);\n      } else {\n        if (ordinalPalette) {\n          return scale.color.palette(ordinalPalette, cardinality, type);\n        }\n        return scale.color.interpolate(quantitativeRange[0], quantitativeRange[1], cardinality);\n      }\n    } else { //time or quantitative\n      return [quantitativeRange[0], quantitativeRange[1]];\n    }\n  }\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  // FIXME(kanitw): Jul 29, 2015 - check range is string\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  // TODO add our own set of custom ordinal color palette\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range];\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    var ps = cardinality < 3 ? 3 : Math.max.apply(null, util.keys(palette)),\n      from = 0 , to = ps - 1;\n    // FIXME add config for from / to\n\n    return scale.color.interpolate(palette[ps][from], palette[ps][to], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n\n  var interpolator = interpolate(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n\n},{\"../globals\":71,\"../schema/schema\":73,\"../util\":75,\"./time\":66,\"colorbrewer\":3,\"d3-color\":4}],63:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = stacking;\n\nfunction stacking(encoding, mdef, stack) {\n  var groupby = stack.groupby;\n  var field = stack.value;\n\n  var valName = encoding.fieldRef(field);\n  var startField = valName + '_start';\n  var endField = valName + '_end';\n\n  // add stack transform to mark\n  var transform = {\n    type: 'stack',\n    groupby: [encoding.fieldRef(groupby)],\n    field: encoding.fieldRef(field),\n    sortby: [(stack.properties.reverse ? '-' : '') + encoding.fieldRef(stack.stack)],\n    output: {start: startField, end: endField}\n  };\n\n  if (stack.properties.offset) {\n    transform.offset = stack.properties.offset;\n  }\n\n  mdef.from.transform = [transform];\n\n  // TODO(#276): This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[field] = mdef.properties.enter[field] = {\n    scale: field,\n    field: startField\n  };\n  mdef.properties.update[field + '2'] = mdef.properties.enter[field + '2'] = {\n    scale: field,\n    field: endField\n  };\n\n  return field; //return stack encoding\n}\n\n},{\"../globals\":71}],64:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlEncDef = require('../encdef');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(encDef, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlEncDef.isOrdinalScale(encDef))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../encdef\":70,\"../globals\":71}],65:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, encoding) {\n  var m = group.marks;\n  var g = {\n    name: 'subfacet',\n    type: 'group',\n    from: mdef.from,\n    properties: {\n      enter: {\n        width: {field: {group: 'width'}},\n        height: {field: {group: 'height'}}\n      }\n    },\n    marks: m\n  };\n\n  group.marks = [g];\n  delete mdef.from; // (move to the new g)\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.push({type: 'facet', groupby: details});\n\n  // TODO: understand why we need this sort transform and write comment\n  var stack = encoding.stack();\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n\n},{\"../globals\":71}],66:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nvar time = module.exports = {};\n\n// 'Wednesday September 17 04:00:00 2014'\n// Wednesday is the longest date\n// September is the longest month (8 in javascript as it is zero-indexed).\nvar LONG_DATE = new Date(Date.UTC(2014, 8, 17));\n\ntime.cardinality = function(encDef, stats, filterNull, type) {\n  var timeUnit = encDef.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[encDef.name],\n        yearstat = stats['year_' + encDef.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.formula = function(timeUnit, fieldRef) {\n  // TODO(kanitw): add formula to other time format\n  var fn = 'utc' + timeUnit;\n  return fn + '(' + fieldRef + ')';\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // TODO(#600) revise this\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\n/**\n * @param  {Object} encoding\n * @return {Array}  scales for time unit names\n */\ntime.scales = function(encoding) {\n  var scales = encoding.reduce(function(scales, encDef) {\n    var timeUnit = encDef.timeUnit;\n    if (encDef.type === T && timeUnit && !scales[timeUnit]) {\n      var scale = time.scale.def(encDef.timeUnit, encoding);\n      if (scale) scales[timeUnit] = scale;\n    }\n    return scales;\n  }, {});\n\n  return util.vals(scales);\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n},{\"../util\":75,\"d3-time-format\":6}],67:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":71}],68:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};\n},{\"./globals\":71,\"datalib/src/stats\":29}],69:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlEncDef = require('./encdef'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlEncDef.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlEncDef.fromShorthand(field);\n    return m;\n  }, {});\n};\n\n},{\"./consts\":67,\"./encdef\":70,\"./schema/schema\":73,\"./util\":75}],70:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.noAggregate -- exclude aggregation function\n *   opt.datum - include 'datum.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.datum ? 'datum.' : '') + (opt.prefn || ''),\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else if (!opt.nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!opt.nofn && !opt.noAggregate && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!opt.nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  }  else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.missing > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compiler/time\":66,\"./consts\":67,\"./globals\":71,\"./schema/schema\":73,\"./util\":75}],71:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],72:[function(require,module,exports){\n'use strict';\n\n// TODO(kanitw): chat with Vega team and possibly move this to vega-logging\nmodule.exports = function(prefix) {\n  // Borrowed some ideas from http://stackoverflow.com/a/15653260/866989\n  // and https://github.com/patik/console.log-wrapper/blob/master/consolelog.js\n  var METHODS = ['error', 'info', 'debug', 'warn', 'log'];\n\n  return METHODS.reduce(function(logger, fn) {\n    var cfn = console[fn] ? fn : 'log';\n    if (console[cfn].bind === 'undefined') { // IE < 10\n        logger[fn] = Function.prototype.bind.call(console[cfn], console, prefix);\n    }\n    else {\n        logger[fn] = console[cfn].bind(console, prefix);\n    }\n    return logger;\n  }, {});\n};\n},{}],73:[function(require,module,exports){\n// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nvar VALID_AGG_OPS = require('vega/src/transforms/Aggregate').VALID_OPS;\n\n// TODO(#620) refer to vega schema\n// var vgStackSchema = require('vega/src/transforms/Stack').schema;\n\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: VALID_AGG_OPS,\n  supportedEnums: {\n    Q: VALID_AGG_OPS,\n    O: ['median','min','max'],\n    N: [],\n    T: ['mean', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        /* Common Scale Properties */\n        type: schema.scale_type,\n\n        /* Quantitative Scale Properties */\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n\n        /* Vega-lite only Properties */\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        /* Vega Axis Properties */\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        grid: {\n          type: 'boolean',\n          default: undefined,\n          description: 'A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks. One of \"front\" (default) or \"back\".'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks: {\n          type: 'integer',\n          default: 5,\n          minimum: 0,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        /* Vega Axis Properties that are automatically populated by Vega-lite */\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        /* Vega-lite only */\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        },\n        labelAngle: {\n          type: 'integer',\n          default: undefined, // auto\n          minimum: 0,\n          maximum: 360,\n          description: 'Angle by which to rotate labels. Set to 0 to force horizontal.'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          minimum: 0,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      default: 'ascending',\n      supportedTypes: toMap([N, O]),\n      oneOf: [\n        {\n          type: 'string',\n          enum: ['ascending', 'descending', 'unsorted']\n        },\n        { // sort by aggregation of another field\n          type: 'object',\n          required: ['field', 'op'],\n          properties: {\n            field: {\n              type: 'string',\n              description: 'The field name to aggregate over.'\n            },\n            op: {\n              type: 'string',\n              enum: VALID_AGG_OPS,\n              description: 'The field name to aggregate over.'\n            },\n            order: {\n              type: 'string',\n              enum: ['ascending', 'descending']\n            }\n          }\n        }\n      ]\n\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'object',\n      description: 'Properties of a legend.',\n      properties: {\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the legend. (Shows field name and its function by default.)'\n        },\n        orient: {\n          type: 'string',\n          default: 'right',\n          description: 'The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".'\n        }\n      }\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0,\n      description: 'Size of marks.'\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: '#4682b4',\n      description: 'Color to be used for marks.'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'Color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette.'\n            //FIXME\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: undefined,\n          description: 'Color palette to encode ordinal variables.',\n          enum: util.keys(colorbrewer)\n        },\n        quantitativeRange: {\n          type: 'array',\n          default: ['#AFC6A3', '#09622A'], // tableau greens\n          // default: ['#ccece6', '#00441b'], // BuGn.9 [2-8]\n          description: 'Color range to encode quantitative variables.',\n          minItems: 2,\n          maxItems: 2,\n          items: {\n            type: 'string',\n            role: 'color'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar stackMixin = {\n  type: 'object',\n  properties: {\n    stack: {\n      type: ['boolean', 'object'],\n      default: true,\n      description: 'Enable stacking (for bar and area marks only).',\n      properties: {\n        reverse: {\n          type: 'boolean',\n          default: false,\n          description: 'Whether to reverse the stack\\'s sortby.'\n        },\n        offset: {\n          type: 'string',\n          default: undefined,\n          enum: ['zero', 'center', 'normalize']\n          // TODO(#620) refer to Vega spec once it doesn't throw error\n          // enum: vgStackSchema.properties.offset.oneOf[0].enum\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle',\n      description: 'Mark to be used.'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, stackMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, stackMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    },\n    // we generate a vega filter transform\n    filter: {\n      type: 'string',\n      default: undefined,\n      description: 'A string containing the filter Vega expression. Use `datum` to refer to the current data object.'\n    },\n    // we generate a vega formula transform\n    formulas: {\n      type: 'array',\n      default: undefined,\n      description: 'Array of formula transforms. Formulas are applied before filter.',\n      items: {\n        type: 'object',\n        properties: {\n          field: {\n            type: 'string',\n            description: 'The property name in which to store the computed formula value.'\n          },\n          expr: {\n            type: 'string',\n            description: 'A string containing an expression for the formula. Use the variable `datum` to to refer to the current data object.'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    // TODO(#597) revise this config\n    filterNull: {\n      type: 'object',\n      properties: {\n        N: {type:'boolean', default: false},\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    autoSortLine: {\n      type: 'boolean',\n      default: true\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.25\n    },\n    cellGridOffset: {\n      type: 'number',\n      default: 6 // equal to tickSize\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'rgba(0,0,0,0)'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../globals\":71,\"../util\":75,\"./schemautil\":74,\"colorbrewer\":3,\"vega/src/transforms/Aggregate\":50}],74:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":75}],75:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.extend(util, require('./logger')('[VL Error]'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\n\n},{\"./logger\":72,\"datalib/src/bins/bins\":14,\"datalib/src/generate\":17,\"datalib/src/stats\":29,\"datalib/src/util\":32}],76:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.encDef = require('./encdef');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\nvl.format = require('d3-format').format;\n\nmodule.exports = vl;\n},{\"./Encoding\":54,\"./compiler/compiler\":56,\"./consts\":67,\"./data\":68,\"./enc\":69,\"./encdef\":70,\"./globals\":71,\"./schema/schema\":73,\"./util\":75,\"d3-format\":5}]},{},[76])(76)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2NvbG9yYnJld2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2J1aWxkL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvYnVpbGQvdGltZUZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL25vZGVfbW9kdWxlcy9kMy1kc3YvYnVpbGQvZHN2LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvbm9kZV9tb2R1bGVzL2QzLXRpbWUtZm9ybWF0L2J1aWxkL3RpbWVGb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9ub2RlX21vZHVsZXMvZDMtdGltZS9idWlsZC90aW1lLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9jb2xsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2dyb3VwYnkuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL21lYXN1cmVzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvYmlucy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW5zL2hpc3RvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvZ2VuZXJhdGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvZHN2LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdG9wb2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdHJlZWpzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2xvYWQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3JlYWQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3JlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3R5cGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvcHJpbnQuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvc3RhdHMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbG9nZ2luZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL25vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9DaGFuZ2VTZXQuanMiLCJub2RlX21vZHVsZXMvdmVnYS9ub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvQ29sbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evbm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL0RhdGFTb3VyY2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS9ub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvRGVwZW5kZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evbm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL0dyYXBoLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evbm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvc3JjL0hlYXAuanMiLCJub2RlX21vZHVsZXMvdmVnYS9ub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL25vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L3NyYy9TaWduYWwuanMiLCJub2RlX21vZHVsZXMvdmVnYS9ub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvVHVwbGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS9ub2RlX21vZHVsZXMvdmVnYS1kYXRhZmxvdy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS9ub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL3NyYy9jb2RlZ2VuLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evbm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evbm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9zcmMvZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2Evbm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVnYS9ub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL3NyYy9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvcGFyc2UvZXhwci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhL3NyYy90cmFuc2Zvcm1zL0ZhY2V0b3IuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9QYXJhbWV0ZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS9zcmMvdHJhbnNmb3Jtcy9UcmFuc2Zvcm0uanMiLCJzcmMvRW5jb2RpbmcuanMiLCJzcmMvY29tcGlsZXIvYXhpcy5qcyIsInNyYy9jb21waWxlci9jb21waWxlci5qcyIsInNyYy9jb21waWxlci9kYXRhLmpzIiwic3JjL2NvbXBpbGVyL2ZhY2V0LmpzIiwic3JjL2NvbXBpbGVyL2xheW91dC5qcyIsInNyYy9jb21waWxlci9sZWdlbmQuanMiLCJzcmMvY29tcGlsZXIvbWFya3MuanMiLCJzcmMvY29tcGlsZXIvc2NhbGUuanMiLCJzcmMvY29tcGlsZXIvc3RhY2suanMiLCJzcmMvY29tcGlsZXIvc3R5bGUuanMiLCJzcmMvY29tcGlsZXIvc3ViZmFjZXQuanMiLCJzcmMvY29tcGlsZXIvdGltZS5qcyIsInNyYy9jb25zdHMuanMiLCJzcmMvZGF0YS5qcyIsInNyYy9lbmMuanMiLCJzcmMvZW5jZGVmLmpzIiwic3JjL2dsb2JhbHMuanMiLCJzcmMvbG9nZ2VyLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyIsInNyYy92bCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Q1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0eEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3gwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCIvLyBUaGlzIHByb2R1Y3QgaW5jbHVkZXMgY29sb3Igc3BlY2lmaWNhdGlvbnMgYW5kIGRlc2lnbnMgZGV2ZWxvcGVkIGJ5IEN5bnRoaWEgQnJld2VyIChodHRwOi8vY29sb3JicmV3ZXIub3JnLykuXG4vLyBKYXZhU2NyaXB0IHNwZWNzIGFzIHBhY2thZ2VkIGluIHRoZSBEMyBsaWJyYXJ5IChkM2pzLm9yZykuIFBsZWFzZSBzZWUgbGljZW5zZSBhdCBodHRwOi8vY29sb3JicmV3ZXIub3JnL2V4cG9ydC9MSUNFTlNFLnR4dFxuIWZ1bmN0aW9uKCkge1xuXG52YXIgY29sb3JicmV3ZXIgPSB7WWxHbjoge1xuMzogW1wiI2Y3ZmNiOVwiLFwiI2FkZGQ4ZVwiLFwiIzMxYTM1NFwiXSxcbjQ6IFtcIiNmZmZmY2NcIixcIiNjMmU2OTlcIixcIiM3OGM2NzlcIixcIiMyMzg0NDNcIl0sXG41OiBbXCIjZmZmZmNjXCIsXCIjYzJlNjk5XCIsXCIjNzhjNjc5XCIsXCIjMzFhMzU0XCIsXCIjMDA2ODM3XCJdLFxuNjogW1wiI2ZmZmZjY1wiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzMxYTM1NFwiLFwiIzAwNjgzN1wiXSxcbjc6IFtcIiNmZmZmY2NcIixcIiNkOWYwYTNcIixcIiNhZGRkOGVcIixcIiM3OGM2NzlcIixcIiM0MWFiNWRcIixcIiMyMzg0NDNcIixcIiMwMDVhMzJcIl0sXG44OiBbXCIjZmZmZmU1XCIsXCIjZjdmY2I5XCIsXCIjZDlmMGEzXCIsXCIjYWRkZDhlXCIsXCIjNzhjNjc5XCIsXCIjNDFhYjVkXCIsXCIjMjM4NDQzXCIsXCIjMDA1YTMyXCJdLFxuOTogW1wiI2ZmZmZlNVwiLFwiI2Y3ZmNiOVwiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzQxYWI1ZFwiLFwiIzIzODQ0M1wiLFwiIzAwNjgzN1wiLFwiIzAwNDUyOVwiXVxufSxZbEduQnU6IHtcbjM6IFtcIiNlZGY4YjFcIixcIiM3ZmNkYmJcIixcIiMyYzdmYjhcIl0sXG40OiBbXCIjZmZmZmNjXCIsXCIjYTFkYWI0XCIsXCIjNDFiNmM0XCIsXCIjMjI1ZWE4XCJdLFxuNTogW1wiI2ZmZmZjY1wiLFwiI2ExZGFiNFwiLFwiIzQxYjZjNFwiLFwiIzJjN2ZiOFwiLFwiIzI1MzQ5NFwiXSxcbjY6IFtcIiNmZmZmY2NcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMyYzdmYjhcIixcIiMyNTM0OTRcIl0sXG43OiBbXCIjZmZmZmNjXCIsXCIjYzdlOWI0XCIsXCIjN2ZjZGJiXCIsXCIjNDFiNmM0XCIsXCIjMWQ5MWMwXCIsXCIjMjI1ZWE4XCIsXCIjMGMyYzg0XCJdLFxuODogW1wiI2ZmZmZkOVwiLFwiI2VkZjhiMVwiLFwiI2M3ZTliNFwiLFwiIzdmY2RiYlwiLFwiIzQxYjZjNFwiLFwiIzFkOTFjMFwiLFwiIzIyNWVhOFwiLFwiIzBjMmM4NFwiXSxcbjk6IFtcIiNmZmZmZDlcIixcIiNlZGY4YjFcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMxZDkxYzBcIixcIiMyMjVlYThcIixcIiMyNTM0OTRcIixcIiMwODFkNThcIl1cbn0sR25CdToge1xuMzogW1wiI2UwZjNkYlwiLFwiI2E4ZGRiNVwiLFwiIzQzYTJjYVwiXSxcbjQ6IFtcIiNmMGY5ZThcIixcIiNiYWU0YmNcIixcIiM3YmNjYzRcIixcIiMyYjhjYmVcIl0sXG41OiBbXCIjZjBmOWU4XCIsXCIjYmFlNGJjXCIsXCIjN2JjY2M0XCIsXCIjNDNhMmNhXCIsXCIjMDg2OGFjXCJdLFxuNjogW1wiI2YwZjllOFwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzQzYTJjYVwiLFwiIzA4NjhhY1wiXSxcbjc6IFtcIiNmMGY5ZThcIixcIiNjY2ViYzVcIixcIiNhOGRkYjVcIixcIiM3YmNjYzRcIixcIiM0ZWIzZDNcIixcIiMyYjhjYmVcIixcIiMwODU4OWVcIl0sXG44OiBbXCIjZjdmY2YwXCIsXCIjZTBmM2RiXCIsXCIjY2NlYmM1XCIsXCIjYThkZGI1XCIsXCIjN2JjY2M0XCIsXCIjNGViM2QzXCIsXCIjMmI4Y2JlXCIsXCIjMDg1ODllXCJdLFxuOTogW1wiI2Y3ZmNmMFwiLFwiI2UwZjNkYlwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzRlYjNkM1wiLFwiIzJiOGNiZVwiLFwiIzA4NjhhY1wiLFwiIzA4NDA4MVwiXVxufSxCdUduOiB7XG4zOiBbXCIjZTVmNWY5XCIsXCIjOTlkOGM5XCIsXCIjMmNhMjVmXCJdLFxuNDogW1wiI2VkZjhmYlwiLFwiI2IyZTJlMlwiLFwiIzY2YzJhNFwiLFwiIzIzOGI0NVwiXSxcbjU6IFtcIiNlZGY4ZmJcIixcIiNiMmUyZTJcIixcIiM2NmMyYTRcIixcIiMyY2EyNWZcIixcIiMwMDZkMmNcIl0sXG42OiBbXCIjZWRmOGZiXCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjMmNhMjVmXCIsXCIjMDA2ZDJjXCJdLFxuNzogW1wiI2VkZjhmYlwiLFwiI2NjZWNlNlwiLFwiIzk5ZDhjOVwiLFwiIzY2YzJhNFwiLFwiIzQxYWU3NlwiLFwiIzIzOGI0NVwiLFwiIzAwNTgyNFwiXSxcbjg6IFtcIiNmN2ZjZmRcIixcIiNlNWY1ZjlcIixcIiNjY2VjZTZcIixcIiM5OWQ4YzlcIixcIiM2NmMyYTRcIixcIiM0MWFlNzZcIixcIiMyMzhiNDVcIixcIiMwMDU4MjRcIl0sXG45OiBbXCIjZjdmY2ZkXCIsXCIjZTVmNWY5XCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjNDFhZTc2XCIsXCIjMjM4YjQ1XCIsXCIjMDA2ZDJjXCIsXCIjMDA0NDFiXCJdXG59LFB1QnVHbjoge1xuMzogW1wiI2VjZTJmMFwiLFwiI2E2YmRkYlwiLFwiIzFjOTA5OVwiXSxcbjQ6IFtcIiNmNmVmZjdcIixcIiNiZGM5ZTFcIixcIiM2N2E5Y2ZcIixcIiMwMjgxOGFcIl0sXG41OiBbXCIjZjZlZmY3XCIsXCIjYmRjOWUxXCIsXCIjNjdhOWNmXCIsXCIjMWM5MDk5XCIsXCIjMDE2YzU5XCJdLFxuNjogW1wiI2Y2ZWZmN1wiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzFjOTA5OVwiLFwiIzAxNmM1OVwiXSxcbjc6IFtcIiNmNmVmZjdcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM2N2E5Y2ZcIixcIiMzNjkwYzBcIixcIiMwMjgxOGFcIixcIiMwMTY0NTBcIl0sXG44OiBbXCIjZmZmN2ZiXCIsXCIjZWNlMmYwXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNjdhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDI4MThhXCIsXCIjMDE2NDUwXCJdLFxuOTogW1wiI2ZmZjdmYlwiLFwiI2VjZTJmMFwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzM2OTBjMFwiLFwiIzAyODE4YVwiLFwiIzAxNmM1OVwiLFwiIzAxNDYzNlwiXVxufSxQdUJ1OiB7XG4zOiBbXCIjZWNlN2YyXCIsXCIjYTZiZGRiXCIsXCIjMmI4Y2JlXCJdLFxuNDogW1wiI2YxZWVmNlwiLFwiI2JkYzllMVwiLFwiIzc0YTljZlwiLFwiIzA1NzBiMFwiXSxcbjU6IFtcIiNmMWVlZjZcIixcIiNiZGM5ZTFcIixcIiM3NGE5Y2ZcIixcIiMyYjhjYmVcIixcIiMwNDVhOGRcIl0sXG42OiBbXCIjZjFlZWY2XCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMmI4Y2JlXCIsXCIjMDQ1YThkXCJdLFxuNzogW1wiI2YxZWVmNlwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzc0YTljZlwiLFwiIzM2OTBjMFwiLFwiIzA1NzBiMFwiLFwiIzAzNGU3YlwiXSxcbjg6IFtcIiNmZmY3ZmJcIixcIiNlY2U3ZjJcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM3NGE5Y2ZcIixcIiMzNjkwYzBcIixcIiMwNTcwYjBcIixcIiMwMzRlN2JcIl0sXG45OiBbXCIjZmZmN2ZiXCIsXCIjZWNlN2YyXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDU3MGIwXCIsXCIjMDQ1YThkXCIsXCIjMDIzODU4XCJdXG59LEJ1UHU6IHtcbjM6IFtcIiNlMGVjZjRcIixcIiM5ZWJjZGFcIixcIiM4ODU2YTdcIl0sXG40OiBbXCIjZWRmOGZiXCIsXCIjYjNjZGUzXCIsXCIjOGM5NmM2XCIsXCIjODg0MTlkXCJdLFxuNTogW1wiI2VkZjhmYlwiLFwiI2IzY2RlM1wiLFwiIzhjOTZjNlwiLFwiIzg4NTZhN1wiLFwiIzgxMGY3Y1wiXSxcbjY6IFtcIiNlZGY4ZmJcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4ODU2YTdcIixcIiM4MTBmN2NcIl0sXG43OiBbXCIjZWRmOGZiXCIsXCIjYmZkM2U2XCIsXCIjOWViY2RhXCIsXCIjOGM5NmM2XCIsXCIjOGM2YmIxXCIsXCIjODg0MTlkXCIsXCIjNmUwMTZiXCJdLFxuODogW1wiI2Y3ZmNmZFwiLFwiI2UwZWNmNFwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzhjNmJiMVwiLFwiIzg4NDE5ZFwiLFwiIzZlMDE2YlwiXSxcbjk6IFtcIiNmN2ZjZmRcIixcIiNlMGVjZjRcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4YzZiYjFcIixcIiM4ODQxOWRcIixcIiM4MTBmN2NcIixcIiM0ZDAwNGJcIl1cbn0sUmRQdToge1xuMzogW1wiI2ZkZTBkZFwiLFwiI2ZhOWZiNVwiLFwiI2M1MWI4YVwiXSxcbjQ6IFtcIiNmZWViZTJcIixcIiNmYmI0YjlcIixcIiNmNzY4YTFcIixcIiNhZTAxN2VcIl0sXG41OiBbXCIjZmVlYmUyXCIsXCIjZmJiNGI5XCIsXCIjZjc2OGExXCIsXCIjYzUxYjhhXCIsXCIjN2EwMTc3XCJdLFxuNjogW1wiI2ZlZWJlMlwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2M1MWI4YVwiLFwiIzdhMDE3N1wiXSxcbjc6IFtcIiNmZWViZTJcIixcIiNmY2M1YzBcIixcIiNmYTlmYjVcIixcIiNmNzY4YTFcIixcIiNkZDM0OTdcIixcIiNhZTAxN2VcIixcIiM3YTAxNzdcIl0sXG44OiBbXCIjZmZmN2YzXCIsXCIjZmRlMGRkXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjZGQzNDk3XCIsXCIjYWUwMTdlXCIsXCIjN2EwMTc3XCJdLFxuOTogW1wiI2ZmZjdmM1wiLFwiI2ZkZTBkZFwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2RkMzQ5N1wiLFwiI2FlMDE3ZVwiLFwiIzdhMDE3N1wiLFwiIzQ5MDA2YVwiXVxufSxQdVJkOiB7XG4zOiBbXCIjZTdlMWVmXCIsXCIjYzk5NGM3XCIsXCIjZGQxYzc3XCJdLFxuNDogW1wiI2YxZWVmNlwiLFwiI2Q3YjVkOFwiLFwiI2RmNjViMFwiLFwiI2NlMTI1NlwiXSxcbjU6IFtcIiNmMWVlZjZcIixcIiNkN2I1ZDhcIixcIiNkZjY1YjBcIixcIiNkZDFjNzdcIixcIiM5ODAwNDNcIl0sXG42OiBbXCIjZjFlZWY2XCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZGQxYzc3XCIsXCIjOTgwMDQzXCJdLFxuNzogW1wiI2YxZWVmNlwiLFwiI2Q0YjlkYVwiLFwiI2M5OTRjN1wiLFwiI2RmNjViMFwiLFwiI2U3Mjk4YVwiLFwiI2NlMTI1NlwiLFwiIzkxMDAzZlwiXSxcbjg6IFtcIiNmN2Y0ZjlcIixcIiNlN2UxZWZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNlNzI5OGFcIixcIiNjZTEyNTZcIixcIiM5MTAwM2ZcIl0sXG45OiBbXCIjZjdmNGY5XCIsXCIjZTdlMWVmXCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZTcyOThhXCIsXCIjY2UxMjU2XCIsXCIjOTgwMDQzXCIsXCIjNjcwMDFmXCJdXG59LE9yUmQ6IHtcbjM6IFtcIiNmZWU4YzhcIixcIiNmZGJiODRcIixcIiNlMzRhMzNcIl0sXG40OiBbXCIjZmVmMGQ5XCIsXCIjZmRjYzhhXCIsXCIjZmM4ZDU5XCIsXCIjZDczMDFmXCJdLFxuNTogW1wiI2ZlZjBkOVwiLFwiI2ZkY2M4YVwiLFwiI2ZjOGQ1OVwiLFwiI2UzNGEzM1wiLFwiI2IzMDAwMFwiXSxcbjY6IFtcIiNmZWYwZDlcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlMzRhMzNcIixcIiNiMzAwMDBcIl0sXG43OiBbXCIjZmVmMGQ5XCIsXCIjZmRkNDllXCIsXCIjZmRiYjg0XCIsXCIjZmM4ZDU5XCIsXCIjZWY2NTQ4XCIsXCIjZDczMDFmXCIsXCIjOTkwMDAwXCJdLFxuODogW1wiI2ZmZjdlY1wiLFwiI2ZlZThjOFwiLFwiI2ZkZDQ5ZVwiLFwiI2ZkYmI4NFwiLFwiI2ZjOGQ1OVwiLFwiI2VmNjU0OFwiLFwiI2Q3MzAxZlwiLFwiIzk5MDAwMFwiXSxcbjk6IFtcIiNmZmY3ZWNcIixcIiNmZWU4YzhcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlZjY1NDhcIixcIiNkNzMwMWZcIixcIiNiMzAwMDBcIixcIiM3ZjAwMDBcIl1cbn0sWWxPclJkOiB7XG4zOiBbXCIjZmZlZGEwXCIsXCIjZmViMjRjXCIsXCIjZjAzYjIwXCJdLFxuNDogW1wiI2ZmZmZiMlwiLFwiI2ZlY2M1Y1wiLFwiI2ZkOGQzY1wiLFwiI2UzMWExY1wiXSxcbjU6IFtcIiNmZmZmYjJcIixcIiNmZWNjNWNcIixcIiNmZDhkM2NcIixcIiNmMDNiMjBcIixcIiNiZDAwMjZcIl0sXG42OiBbXCIjZmZmZmIyXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZjAzYjIwXCIsXCIjYmQwMDI2XCJdLFxuNzogW1wiI2ZmZmZiMlwiLFwiI2ZlZDk3NlwiLFwiI2ZlYjI0Y1wiLFwiI2ZkOGQzY1wiLFwiI2ZjNGUyYVwiLFwiI2UzMWExY1wiLFwiI2IxMDAyNlwiXSxcbjg6IFtcIiNmZmZmY2NcIixcIiNmZmVkYTBcIixcIiNmZWQ5NzZcIixcIiNmZWIyNGNcIixcIiNmZDhkM2NcIixcIiNmYzRlMmFcIixcIiNlMzFhMWNcIixcIiNiMTAwMjZcIl0sXG45OiBbXCIjZmZmZmNjXCIsXCIjZmZlZGEwXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZmM0ZTJhXCIsXCIjZTMxYTFjXCIsXCIjYmQwMDI2XCIsXCIjODAwMDI2XCJdXG59LFlsT3JCcjoge1xuMzogW1wiI2ZmZjdiY1wiLFwiI2ZlYzQ0ZlwiLFwiI2Q5NWYwZVwiXSxcbjQ6IFtcIiNmZmZmZDRcIixcIiNmZWQ5OGVcIixcIiNmZTk5MjlcIixcIiNjYzRjMDJcIl0sXG41OiBbXCIjZmZmZmQ0XCIsXCIjZmVkOThlXCIsXCIjZmU5OTI5XCIsXCIjZDk1ZjBlXCIsXCIjOTkzNDA0XCJdLFxuNjogW1wiI2ZmZmZkNFwiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2Q5NWYwZVwiLFwiIzk5MzQwNFwiXSxcbjc6IFtcIiNmZmZmZDRcIixcIiNmZWUzOTFcIixcIiNmZWM0NGZcIixcIiNmZTk5MjlcIixcIiNlYzcwMTRcIixcIiNjYzRjMDJcIixcIiM4YzJkMDRcIl0sXG44OiBbXCIjZmZmZmU1XCIsXCIjZmZmN2JjXCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZWM3MDE0XCIsXCIjY2M0YzAyXCIsXCIjOGMyZDA0XCJdLFxuOTogW1wiI2ZmZmZlNVwiLFwiI2ZmZjdiY1wiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2VjNzAxNFwiLFwiI2NjNGMwMlwiLFwiIzk5MzQwNFwiLFwiIzY2MjUwNlwiXVxufSxQdXJwbGVzOiB7XG4zOiBbXCIjZWZlZGY1XCIsXCIjYmNiZGRjXCIsXCIjNzU2YmIxXCJdLFxuNDogW1wiI2YyZjBmN1wiLFwiI2NiYzllMlwiLFwiIzllOWFjOFwiLFwiIzZhNTFhM1wiXSxcbjU6IFtcIiNmMmYwZjdcIixcIiNjYmM5ZTJcIixcIiM5ZTlhYzhcIixcIiM3NTZiYjFcIixcIiM1NDI3OGZcIl0sXG42OiBbXCIjZjJmMGY3XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjNzU2YmIxXCIsXCIjNTQyNzhmXCJdLFxuNzogW1wiI2YyZjBmN1wiLFwiI2RhZGFlYlwiLFwiI2JjYmRkY1wiLFwiIzllOWFjOFwiLFwiIzgwN2RiYVwiLFwiIzZhNTFhM1wiLFwiIzRhMTQ4NlwiXSxcbjg6IFtcIiNmY2ZiZmRcIixcIiNlZmVkZjVcIixcIiNkYWRhZWJcIixcIiNiY2JkZGNcIixcIiM5ZTlhYzhcIixcIiM4MDdkYmFcIixcIiM2YTUxYTNcIixcIiM0YTE0ODZcIl0sXG45OiBbXCIjZmNmYmZkXCIsXCIjZWZlZGY1XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjODA3ZGJhXCIsXCIjNmE1MWEzXCIsXCIjNTQyNzhmXCIsXCIjM2YwMDdkXCJdXG59LEJsdWVzOiB7XG4zOiBbXCIjZGVlYmY3XCIsXCIjOWVjYWUxXCIsXCIjMzE4MmJkXCJdLFxuNDogW1wiI2VmZjNmZlwiLFwiI2JkZDdlN1wiLFwiIzZiYWVkNlwiLFwiIzIxNzFiNVwiXSxcbjU6IFtcIiNlZmYzZmZcIixcIiNiZGQ3ZTdcIixcIiM2YmFlZDZcIixcIiMzMTgyYmRcIixcIiMwODUxOWNcIl0sXG42OiBbXCIjZWZmM2ZmXCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjMzE4MmJkXCIsXCIjMDg1MTljXCJdLFxuNzogW1wiI2VmZjNmZlwiLFwiI2M2ZGJlZlwiLFwiIzllY2FlMVwiLFwiIzZiYWVkNlwiLFwiIzQyOTJjNlwiLFwiIzIxNzFiNVwiLFwiIzA4NDU5NFwiXSxcbjg6IFtcIiNmN2ZiZmZcIixcIiNkZWViZjdcIixcIiNjNmRiZWZcIixcIiM5ZWNhZTFcIixcIiM2YmFlZDZcIixcIiM0MjkyYzZcIixcIiMyMTcxYjVcIixcIiMwODQ1OTRcIl0sXG45OiBbXCIjZjdmYmZmXCIsXCIjZGVlYmY3XCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjNDI5MmM2XCIsXCIjMjE3MWI1XCIsXCIjMDg1MTljXCIsXCIjMDgzMDZiXCJdXG59LEdyZWVuczoge1xuMzogW1wiI2U1ZjVlMFwiLFwiI2ExZDk5YlwiLFwiIzMxYTM1NFwiXSxcbjQ6IFtcIiNlZGY4ZTlcIixcIiNiYWU0YjNcIixcIiM3NGM0NzZcIixcIiMyMzhiNDVcIl0sXG41OiBbXCIjZWRmOGU5XCIsXCIjYmFlNGIzXCIsXCIjNzRjNDc2XCIsXCIjMzFhMzU0XCIsXCIjMDA2ZDJjXCJdLFxuNjogW1wiI2VkZjhlOVwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzMxYTM1NFwiLFwiIzAwNmQyY1wiXSxcbjc6IFtcIiNlZGY4ZTlcIixcIiNjN2U5YzBcIixcIiNhMWQ5OWJcIixcIiM3NGM0NzZcIixcIiM0MWFiNWRcIixcIiMyMzhiNDVcIixcIiMwMDVhMzJcIl0sXG44OiBbXCIjZjdmY2Y1XCIsXCIjZTVmNWUwXCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjNDFhYjVkXCIsXCIjMjM4YjQ1XCIsXCIjMDA1YTMyXCJdLFxuOTogW1wiI2Y3ZmNmNVwiLFwiI2U1ZjVlMFwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzQxYWI1ZFwiLFwiIzIzOGI0NVwiLFwiIzAwNmQyY1wiLFwiIzAwNDQxYlwiXVxufSxPcmFuZ2VzOiB7XG4zOiBbXCIjZmVlNmNlXCIsXCIjZmRhZTZiXCIsXCIjZTY1NTBkXCJdLFxuNDogW1wiI2ZlZWRkZVwiLFwiI2ZkYmU4NVwiLFwiI2ZkOGQzY1wiLFwiI2Q5NDcwMVwiXSxcbjU6IFtcIiNmZWVkZGVcIixcIiNmZGJlODVcIixcIiNmZDhkM2NcIixcIiNlNjU1MGRcIixcIiNhNjM2MDNcIl0sXG42OiBbXCIjZmVlZGRlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZTY1NTBkXCIsXCIjYTYzNjAzXCJdLFxuNzogW1wiI2ZlZWRkZVwiLFwiI2ZkZDBhMlwiLFwiI2ZkYWU2YlwiLFwiI2ZkOGQzY1wiLFwiI2YxNjkxM1wiLFwiI2Q5NDgwMVwiLFwiIzhjMmQwNFwiXSxcbjg6IFtcIiNmZmY1ZWJcIixcIiNmZWU2Y2VcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNmMTY5MTNcIixcIiNkOTQ4MDFcIixcIiM4YzJkMDRcIl0sXG45OiBbXCIjZmZmNWViXCIsXCIjZmVlNmNlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZjE2OTEzXCIsXCIjZDk0ODAxXCIsXCIjYTYzNjAzXCIsXCIjN2YyNzA0XCJdXG59LFJlZHM6IHtcbjM6IFtcIiNmZWUwZDJcIixcIiNmYzkyNzJcIixcIiNkZTJkMjZcIl0sXG40OiBbXCIjZmVlNWQ5XCIsXCIjZmNhZTkxXCIsXCIjZmI2YTRhXCIsXCIjY2IxODFkXCJdLFxuNTogW1wiI2ZlZTVkOVwiLFwiI2ZjYWU5MVwiLFwiI2ZiNmE0YVwiLFwiI2RlMmQyNlwiLFwiI2E1MGYxNVwiXSxcbjY6IFtcIiNmZWU1ZDlcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNkZTJkMjZcIixcIiNhNTBmMTVcIl0sXG43OiBbXCIjZmVlNWQ5XCIsXCIjZmNiYmExXCIsXCIjZmM5MjcyXCIsXCIjZmI2YTRhXCIsXCIjZWYzYjJjXCIsXCIjY2IxODFkXCIsXCIjOTkwMDBkXCJdLFxuODogW1wiI2ZmZjVmMFwiLFwiI2ZlZTBkMlwiLFwiI2ZjYmJhMVwiLFwiI2ZjOTI3MlwiLFwiI2ZiNmE0YVwiLFwiI2VmM2IyY1wiLFwiI2NiMTgxZFwiLFwiIzk5MDAwZFwiXSxcbjk6IFtcIiNmZmY1ZjBcIixcIiNmZWUwZDJcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNlZjNiMmNcIixcIiNjYjE4MWRcIixcIiNhNTBmMTVcIixcIiM2NzAwMGRcIl1cbn0sR3JleXM6IHtcbjM6IFtcIiNmMGYwZjBcIixcIiNiZGJkYmRcIixcIiM2MzYzNjNcIl0sXG40OiBbXCIjZjdmN2Y3XCIsXCIjY2NjY2NjXCIsXCIjOTY5Njk2XCIsXCIjNTI1MjUyXCJdLFxuNTogW1wiI2Y3ZjdmN1wiLFwiI2NjY2NjY1wiLFwiIzk2OTY5NlwiLFwiIzYzNjM2M1wiLFwiIzI1MjUyNVwiXSxcbjY6IFtcIiNmN2Y3ZjdcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM2MzYzNjNcIixcIiMyNTI1MjVcIl0sXG43OiBbXCIjZjdmN2Y3XCIsXCIjZDlkOWQ5XCIsXCIjYmRiZGJkXCIsXCIjOTY5Njk2XCIsXCIjNzM3MzczXCIsXCIjNTI1MjUyXCIsXCIjMjUyNTI1XCJdLFxuODogW1wiI2ZmZmZmZlwiLFwiI2YwZjBmMFwiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzczNzM3M1wiLFwiIzUyNTI1MlwiLFwiIzI1MjUyNVwiXSxcbjk6IFtcIiNmZmZmZmZcIixcIiNmMGYwZjBcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM3MzczNzNcIixcIiM1MjUyNTJcIixcIiMyNTI1MjVcIixcIiMwMDAwMDBcIl1cbn0sUHVPcjoge1xuMzogW1wiI2YxYTM0MFwiLFwiI2Y3ZjdmN1wiLFwiIzk5OGVjM1wiXSxcbjQ6IFtcIiNlNjYxMDFcIixcIiNmZGI4NjNcIixcIiNiMmFiZDJcIixcIiM1ZTNjOTlcIl0sXG41OiBbXCIjZTY2MTAxXCIsXCIjZmRiODYzXCIsXCIjZjdmN2Y3XCIsXCIjYjJhYmQyXCIsXCIjNWUzYzk5XCJdLFxuNjogW1wiI2IzNTgwNlwiLFwiI2YxYTM0MFwiLFwiI2ZlZTBiNlwiLFwiI2Q4ZGFlYlwiLFwiIzk5OGVjM1wiLFwiIzU0Mjc4OFwiXSxcbjc6IFtcIiNiMzU4MDZcIixcIiNmMWEzNDBcIixcIiNmZWUwYjZcIixcIiNmN2Y3ZjdcIixcIiNkOGRhZWJcIixcIiM5OThlYzNcIixcIiM1NDI3ODhcIl0sXG44OiBbXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCJdLFxuOTogW1wiI2IzNTgwNlwiLFwiI2UwODIxNFwiLFwiI2ZkYjg2M1wiLFwiI2ZlZTBiNlwiLFwiI2Y3ZjdmN1wiLFwiI2Q4ZGFlYlwiLFwiI2IyYWJkMlwiLFwiIzgwNzNhY1wiLFwiIzU0Mjc4OFwiXSxcbjEwOiBbXCIjN2YzYjA4XCIsXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCIsXCIjMmQwMDRiXCJdLFxuMTE6IFtcIiM3ZjNiMDhcIixcIiNiMzU4MDZcIixcIiNlMDgyMTRcIixcIiNmZGI4NjNcIixcIiNmZWUwYjZcIixcIiNmN2Y3ZjdcIixcIiNkOGRhZWJcIixcIiNiMmFiZDJcIixcIiM4MDczYWNcIixcIiM1NDI3ODhcIixcIiMyZDAwNGJcIl1cbn0sQnJCRzoge1xuMzogW1wiI2Q4YjM2NVwiLFwiI2Y1ZjVmNVwiLFwiIzVhYjRhY1wiXSxcbjQ6IFtcIiNhNjYxMWFcIixcIiNkZmMyN2RcIixcIiM4MGNkYzFcIixcIiMwMTg1NzFcIl0sXG41OiBbXCIjYTY2MTFhXCIsXCIjZGZjMjdkXCIsXCIjZjVmNWY1XCIsXCIjODBjZGMxXCIsXCIjMDE4NTcxXCJdLFxuNjogW1wiIzhjNTEwYVwiLFwiI2Q4YjM2NVwiLFwiI2Y2ZThjM1wiLFwiI2M3ZWFlNVwiLFwiIzVhYjRhY1wiLFwiIzAxNjY1ZVwiXSxcbjc6IFtcIiM4YzUxMGFcIixcIiNkOGIzNjVcIixcIiNmNmU4YzNcIixcIiNmNWY1ZjVcIixcIiNjN2VhZTVcIixcIiM1YWI0YWNcIixcIiMwMTY2NWVcIl0sXG44OiBbXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCJdLFxuOTogW1wiIzhjNTEwYVwiLFwiI2JmODEyZFwiLFwiI2RmYzI3ZFwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzgwY2RjMVwiLFwiIzM1OTc4ZlwiLFwiIzAxNjY1ZVwiXSxcbjEwOiBbXCIjNTQzMDA1XCIsXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCIsXCIjMDAzYzMwXCJdLFxuMTE6IFtcIiM1NDMwMDVcIixcIiM4YzUxMGFcIixcIiNiZjgxMmRcIixcIiNkZmMyN2RcIixcIiNmNmU4YzNcIixcIiNmNWY1ZjVcIixcIiNjN2VhZTVcIixcIiM4MGNkYzFcIixcIiMzNTk3OGZcIixcIiMwMTY2NWVcIixcIiMwMDNjMzBcIl1cbn0sUFJHbjoge1xuMzogW1wiI2FmOGRjM1wiLFwiI2Y3ZjdmN1wiLFwiIzdmYmY3YlwiXSxcbjQ6IFtcIiM3YjMyOTRcIixcIiNjMmE1Y2ZcIixcIiNhNmRiYTBcIixcIiMwMDg4MzdcIl0sXG41OiBbXCIjN2IzMjk0XCIsXCIjYzJhNWNmXCIsXCIjZjdmN2Y3XCIsXCIjYTZkYmEwXCIsXCIjMDA4ODM3XCJdLFxuNjogW1wiIzc2MmE4M1wiLFwiI2FmOGRjM1wiLFwiI2U3ZDRlOFwiLFwiI2Q5ZjBkM1wiLFwiIzdmYmY3YlwiLFwiIzFiNzgzN1wiXSxcbjc6IFtcIiM3NjJhODNcIixcIiNhZjhkYzNcIixcIiNlN2Q0ZThcIixcIiNmN2Y3ZjdcIixcIiNkOWYwZDNcIixcIiM3ZmJmN2JcIixcIiMxYjc4MzdcIl0sXG44OiBbXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCJdLFxuOTogW1wiIzc2MmE4M1wiLFwiIzk5NzBhYlwiLFwiI2MyYTVjZlwiLFwiI2U3ZDRlOFwiLFwiI2Y3ZjdmN1wiLFwiI2Q5ZjBkM1wiLFwiI2E2ZGJhMFwiLFwiIzVhYWU2MVwiLFwiIzFiNzgzN1wiXSxcbjEwOiBbXCIjNDAwMDRiXCIsXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCIsXCIjMDA0NDFiXCJdLFxuMTE6IFtcIiM0MDAwNGJcIixcIiM3NjJhODNcIixcIiM5OTcwYWJcIixcIiNjMmE1Y2ZcIixcIiNlN2Q0ZThcIixcIiNmN2Y3ZjdcIixcIiNkOWYwZDNcIixcIiNhNmRiYTBcIixcIiM1YWFlNjFcIixcIiMxYjc4MzdcIixcIiMwMDQ0MWJcIl1cbn0sUGlZRzoge1xuMzogW1wiI2U5YTNjOVwiLFwiI2Y3ZjdmN1wiLFwiI2ExZDc2YVwiXSxcbjQ6IFtcIiNkMDFjOGJcIixcIiNmMWI2ZGFcIixcIiNiOGUxODZcIixcIiM0ZGFjMjZcIl0sXG41OiBbXCIjZDAxYzhiXCIsXCIjZjFiNmRhXCIsXCIjZjdmN2Y3XCIsXCIjYjhlMTg2XCIsXCIjNGRhYzI2XCJdLFxuNjogW1wiI2M1MWI3ZFwiLFwiI2U5YTNjOVwiLFwiI2ZkZTBlZlwiLFwiI2U2ZjVkMFwiLFwiI2ExZDc2YVwiLFwiIzRkOTIyMVwiXSxcbjc6IFtcIiNjNTFiN2RcIixcIiNlOWEzYzlcIixcIiNmZGUwZWZcIixcIiNmN2Y3ZjdcIixcIiNlNmY1ZDBcIixcIiNhMWQ3NmFcIixcIiM0ZDkyMjFcIl0sXG44OiBbXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCJdLFxuOTogW1wiI2M1MWI3ZFwiLFwiI2RlNzdhZVwiLFwiI2YxYjZkYVwiLFwiI2ZkZTBlZlwiLFwiI2Y3ZjdmN1wiLFwiI2U2ZjVkMFwiLFwiI2I4ZTE4NlwiLFwiIzdmYmM0MVwiLFwiIzRkOTIyMVwiXSxcbjEwOiBbXCIjOGUwMTUyXCIsXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCIsXCIjMjc2NDE5XCJdLFxuMTE6IFtcIiM4ZTAxNTJcIixcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNmN2Y3ZjdcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIixcIiMyNzY0MTlcIl1cbn0sUmRCdToge1xuMzogW1wiI2VmOGE2MlwiLFwiI2Y3ZjdmN1wiLFwiIzY3YTljZlwiXSxcbjQ6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiM5MmM1ZGVcIixcIiMwNTcxYjBcIl0sXG41OiBbXCIjY2EwMDIwXCIsXCIjZjRhNTgyXCIsXCIjZjdmN2Y3XCIsXCIjOTJjNWRlXCIsXCIjMDU3MWIwXCJdLFxuNjogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2QxZTVmMFwiLFwiIzY3YTljZlwiLFwiIzIxNjZhY1wiXSxcbjc6IFtcIiNiMjE4MmJcIixcIiNlZjhhNjJcIixcIiNmZGRiYzdcIixcIiNmN2Y3ZjdcIixcIiNkMWU1ZjBcIixcIiM2N2E5Y2ZcIixcIiMyMTY2YWNcIl0sXG44OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCJdLFxuOTogW1wiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzkyYzVkZVwiLFwiIzQzOTNjM1wiLFwiIzIxNjZhY1wiXSxcbjEwOiBbXCIjNjcwMDFmXCIsXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCIsXCIjMDUzMDYxXCJdLFxuMTE6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNmN2Y3ZjdcIixcIiNkMWU1ZjBcIixcIiM5MmM1ZGVcIixcIiM0MzkzYzNcIixcIiMyMTY2YWNcIixcIiMwNTMwNjFcIl1cbn0sUmRHeToge1xuMzogW1wiI2VmOGE2MlwiLFwiI2ZmZmZmZlwiLFwiIzk5OTk5OVwiXSxcbjQ6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiNiYWJhYmFcIixcIiM0MDQwNDBcIl0sXG41OiBbXCIjY2EwMDIwXCIsXCIjZjRhNTgyXCIsXCIjZmZmZmZmXCIsXCIjYmFiYWJhXCIsXCIjNDA0MDQwXCJdLFxuNjogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2UwZTBlMFwiLFwiIzk5OTk5OVwiLFwiIzRkNGQ0ZFwiXSxcbjc6IFtcIiNiMjE4MmJcIixcIiNlZjhhNjJcIixcIiNmZGRiYzdcIixcIiNmZmZmZmZcIixcIiNlMGUwZTBcIixcIiM5OTk5OTlcIixcIiM0ZDRkNGRcIl0sXG44OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCJdLFxuOTogW1wiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2ZmZmZmZlwiLFwiI2UwZTBlMFwiLFwiI2JhYmFiYVwiLFwiIzg3ODc4N1wiLFwiIzRkNGQ0ZFwiXSxcbjEwOiBbXCIjNjcwMDFmXCIsXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCIsXCIjMWExYTFhXCJdLFxuMTE6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNmZmZmZmZcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIixcIiMxYTFhMWFcIl1cbn0sUmRZbEJ1OiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTFiZmRiXCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2FiZDllOVwiLFwiIzJjN2JiNlwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhYmQ5ZTlcIixcIiMyYzdiYjZcIl0sXG42OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDkwXCIsXCIjZTBmM2Y4XCIsXCIjOTFiZmRiXCIsXCIjNDU3NWI0XCJdLFxuNzogW1wiI2Q3MzAyN1wiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA5MFwiLFwiI2ZmZmZiZlwiLFwiI2UwZjNmOFwiLFwiIzkxYmZkYlwiLFwiIzQ1NzViNFwiXSxcbjg6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIl0sXG45OiBbXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjYWJkOWU5XCIsXCIjNzRhZGQxXCIsXCIjNDU3NWI0XCJdLFxuMTA6IFtcIiNhNTAwMjZcIixcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIixcIiMzMTM2OTVcIl0sXG4xMTogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA5MFwiLFwiI2ZmZmZiZlwiLFwiI2UwZjNmOFwiLFwiI2FiZDllOVwiLFwiIzc0YWRkMVwiLFwiIzQ1NzViNFwiLFwiIzMxMzY5NVwiXVxufSxTcGVjdHJhbDoge1xuMzogW1wiI2ZjOGQ1OVwiLFwiI2ZmZmZiZlwiLFwiIzk5ZDU5NFwiXSxcbjQ6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNhYmRkYTRcIixcIiMyYjgzYmFcIl0sXG41OiBbXCIjZDcxOTFjXCIsXCIjZmRhZTYxXCIsXCIjZmZmZmJmXCIsXCIjYWJkZGE0XCIsXCIjMmI4M2JhXCJdLFxuNjogW1wiI2Q1M2U0ZlwiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2U2ZjU5OFwiLFwiIzk5ZDU5NFwiLFwiIzMyODhiZFwiXSxcbjc6IFtcIiNkNTNlNGZcIixcIiNmYzhkNTlcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNlNmY1OThcIixcIiM5OWQ1OTRcIixcIiMzMjg4YmRcIl0sXG44OiBbXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCJdLFxuOTogW1wiI2Q1M2U0ZlwiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2U2ZjU5OFwiLFwiI2FiZGRhNFwiLFwiIzY2YzJhNVwiLFwiIzMyODhiZFwiXSxcbjEwOiBbXCIjOWUwMTQyXCIsXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCIsXCIjNWU0ZmEyXCJdLFxuMTE6IFtcIiM5ZTAxNDJcIixcIiNkNTNlNGZcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNlNmY1OThcIixcIiNhYmRkYTRcIixcIiM2NmMyYTVcIixcIiMzMjg4YmRcIixcIiM1ZTRmYTJcIl1cbn0sUmRZbEduOiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTFjZjYwXCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2E2ZDk2YVwiLFwiIzFhOTY0MVwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhNmQ5NmFcIixcIiMxYTk2NDFcIl0sXG42OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDhiXCIsXCIjZDllZjhiXCIsXCIjOTFjZjYwXCIsXCIjMWE5ODUwXCJdLFxuNzogW1wiI2Q3MzAyN1wiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2Q5ZWY4YlwiLFwiIzkxY2Y2MFwiLFwiIzFhOTg1MFwiXSxcbjg6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIl0sXG45OiBbXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjYTZkOTZhXCIsXCIjNjZiZDYzXCIsXCIjMWE5ODUwXCJdLFxuMTA6IFtcIiNhNTAwMjZcIixcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIixcIiMwMDY4MzdcIl0sXG4xMTogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2Q5ZWY4YlwiLFwiI2E2ZDk2YVwiLFwiIzY2YmQ2M1wiLFwiIzFhOTg1MFwiLFwiIzAwNjgzN1wiXVxufSxBY2NlbnQ6IHtcbjM6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIl0sXG40OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCJdLFxuNTogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiXSxcbjY6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIixcIiNmZmZmOTlcIixcIiMzODZjYjBcIixcIiNmMDAyN2ZcIl0sXG43OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCIsXCIjMzg2Y2IwXCIsXCIjZjAwMjdmXCIsXCIjYmY1YjE3XCJdLFxuODogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiLFwiI2YwMDI3ZlwiLFwiI2JmNWIxN1wiLFwiIzY2NjY2NlwiXVxufSxEYXJrMjoge1xuMzogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiXSxcbjQ6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIl0sXG41OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCJdLFxuNjogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiLFwiI2U3Mjk4YVwiLFwiIzY2YTYxZVwiLFwiI2U2YWIwMlwiXSxcbjc6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIixcIiNlNmFiMDJcIixcIiNhNjc2MWRcIl0sXG44OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCIsXCIjZTZhYjAyXCIsXCIjYTY3NjFkXCIsXCIjNjY2NjY2XCJdXG59LFBhaXJlZDoge1xuMzogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiXSxcbjQ6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIl0sXG41OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCJdLFxuNjogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiXSxcbjc6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIl0sXG44OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCJdLFxuOTogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiXSxcbjEwOiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCIsXCIjY2FiMmQ2XCIsXCIjNmEzZDlhXCJdLFxuMTE6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIixcIiNjYWIyZDZcIixcIiM2YTNkOWFcIixcIiNmZmZmOTlcIl0sXG4xMjogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiLFwiIzZhM2Q5YVwiLFwiI2ZmZmY5OVwiLFwiI2IxNTkyOFwiXVxufSxQYXN0ZWwxOiB7XG4zOiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCJdLFxuNDogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiXSxcbjU6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIl0sXG42OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCJdLFxuNzogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiLFwiI2ZmZmZjY1wiLFwiI2U1ZDhiZFwiXSxcbjg6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIixcIiNmZmZmY2NcIixcIiNlNWQ4YmRcIixcIiNmZGRhZWNcIl0sXG45OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCIsXCIjZTVkOGJkXCIsXCIjZmRkYWVjXCIsXCIjZjJmMmYyXCJdXG59LFBhc3RlbDI6IHtcbjM6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIl0sXG40OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCJdLFxuNTogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiXSxcbjY6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIixcIiNmNGNhZTRcIixcIiNlNmY1YzlcIixcIiNmZmYyYWVcIl0sXG43OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCIsXCIjZmZmMmFlXCIsXCIjZjFlMmNjXCJdLFxuODogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiLFwiI2ZmZjJhZVwiLFwiI2YxZTJjY1wiLFwiI2NjY2NjY1wiXVxufSxTZXQxOiB7XG4zOiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCJdLFxuNDogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiXSxcbjU6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIl0sXG42OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCJdLFxuNzogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiLFwiI2ZmN2YwMFwiLFwiI2ZmZmYzM1wiLFwiI2E2NTYyOFwiXSxcbjg6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIixcIiNhNjU2MjhcIixcIiNmNzgxYmZcIl0sXG45OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCIsXCIjYTY1NjI4XCIsXCIjZjc4MWJmXCIsXCIjOTk5OTk5XCJdXG59LFNldDI6IHtcbjM6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIl0sXG40OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCJdLFxuNTogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiXSxcbjY6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIixcIiNlNzhhYzNcIixcIiNhNmQ4NTRcIixcIiNmZmQ5MmZcIl0sXG43OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCIsXCIjYTZkODU0XCIsXCIjZmZkOTJmXCIsXCIjZTVjNDk0XCJdLFxuODogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiLFwiI2ZmZDkyZlwiLFwiI2U1YzQ5NFwiLFwiI2IzYjNiM1wiXVxufSxTZXQzOiB7XG4zOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCJdLFxuNDogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiXSxcbjU6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIl0sXG42OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCJdLFxuNzogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiXSxcbjg6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIl0sXG45OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCJdLFxuMTA6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIixcIiNkOWQ5ZDlcIixcIiNiYzgwYmRcIl0sXG4xMTogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiLFwiI2ZjY2RlNVwiLFwiI2Q5ZDlkOVwiLFwiI2JjODBiZFwiLFwiI2NjZWJjNVwiXSxcbjEyOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCIsXCIjYmM4MGJkXCIsXCIjY2NlYmM1XCIsXCIjZmZlZDZmXCJdXG59fTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGNvbG9yYnJld2VyKTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gY29sb3JicmV3ZXI7XG59IGVsc2Uge1xuICAgIHRoaXMuY29sb3JicmV3ZXIgPSBjb2xvcmJyZXdlcjtcbn1cblxufSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbG9yYnJld2VyLmpzJyk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC5jb2xvciA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBkZWx0YUh1ZShoMSwgaDApIHtcbiAgICB2YXIgZGVsdGEgPSBoMSAtIGgwO1xuICAgIHJldHVybiBkZWx0YSA+IDE4MCB8fCBkZWx0YSA8IC0xODBcbiAgICAgICAgPyBkZWx0YSAtIDM2MCAqIE1hdGgucm91bmQoZGVsdGEgLyAzNjApXG4gICAgICAgIDogZGVsdGE7XG4gIH1cblxuICBmdW5jdGlvbiBDb2xvcigpIHt9dmFyIHJlSGV4MyA9IC9eIyhbMC05YS1mXXszfSkkLztcbiAgdmFyIHJlSGV4NiA9IC9eIyhbMC05YS1mXXs2fSkkLztcbiAgdmFyIHJlUmdiSW50ZWdlciA9IC9ecmdiXFwoXFxzKihbLStdP1xcZCspXFxzKixcXHMqKFstK10/XFxkKylcXHMqLFxccyooWy0rXT9cXGQrKVxccypcXCkkLztcbiAgdmFyIHJlUmdiUGVyY2VudCA9IC9ecmdiXFwoXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIHJlSHNsUGVyY2VudCA9IC9eaHNsXFwoXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuICBjb2xvci5wcm90b3R5cGUgPSBDb2xvci5wcm90b3R5cGUgPSB7XG4gICAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJnYigpICsgXCJcIjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29sb3IoZm9ybWF0KSB7XG4gICAgdmFyIG07XG4gICAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAobSA9IHJlSGV4My5leGVjKGZvcm1hdCkpID8gKG0gPSBwYXJzZUludChtWzFdLCAxNiksIHJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweDBmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkpIC8vICNmMDBcbiAgICAgICAgOiAobSA9IHJlSGV4Ni5leGVjKGZvcm1hdCkpID8gcmdibihwYXJzZUludChtWzFdLCAxNikpIC8vICNmZjAwMDBcbiAgICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiKG1bMV0sIG1bMl0sIG1bM10pIC8vIHJnYigyNTUsMCwwKVxuICAgICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2IobVsxXSAqIDIuNTUsIG1bMl0gKiAyLjU1LCBtWzNdICogMi41NSkgLy8gcmdiKDEwMCUsMCUsMCUpXG4gICAgICAgIDogKG0gPSByZUhzbFBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbChtWzFdLCBtWzJdICogLjAxLCBtWzNdICogLjAxKSAvLyBoc2woMTIwLDUwJSw1MCUpXG4gICAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSlcbiAgICAgICAgOiBudWxsO1xuICB9ZnVuY3Rpb24gcmdibihuKSB7XG4gICAgcmV0dXJuIHJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYpO1xuICB9XG5cbiAgdmFyIG5hbWVkID0ge1xuICAgIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gICAgYW50aXF1ZXdoaXRlOiAweGZhZWJkNyxcbiAgICBhcXVhOiAweDAwZmZmZixcbiAgICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgICBhenVyZTogMHhmMGZmZmYsXG4gICAgYmVpZ2U6IDB4ZjVmNWRjLFxuICAgIGJpc3F1ZTogMHhmZmU0YzQsXG4gICAgYmxhY2s6IDB4MDAwMDAwLFxuICAgIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgICBibHVlOiAweDAwMDBmZixcbiAgICBibHVldmlvbGV0OiAweDhhMmJlMixcbiAgICBicm93bjogMHhhNTJhMmEsXG4gICAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgICBjYWRldGJsdWU6IDB4NWY5ZWEwLFxuICAgIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICAgIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gICAgY29yYWw6IDB4ZmY3ZjUwLFxuICAgIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gICAgY3JpbXNvbjogMHhkYzE0M2MsXG4gICAgY3lhbjogMHgwMGZmZmYsXG4gICAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICAgIGRhcmtjeWFuOiAweDAwOGI4YixcbiAgICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgICBkYXJrZ3JheTogMHhhOWE5YTksXG4gICAgZGFya2dyZWVuOiAweDAwNjQwMCxcbiAgICBkYXJrZ3JleTogMHhhOWE5YTksXG4gICAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgICBkYXJrbWFnZW50YTogMHg4YjAwOGIsXG4gICAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICAgIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICAgIGRhcmtvcmNoaWQ6IDB4OTkzMmNjLFxuICAgIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICAgIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICAgIGRhcmtzZWFncmVlbjogMHg4ZmJjOGYsXG4gICAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gICAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gICAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGYsXG4gICAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gICAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gICAgZGVlcHBpbms6IDB4ZmYxNDkzLFxuICAgIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgICBkaW1ncmV5OiAweDY5Njk2OSxcbiAgICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICAgIGZsb3JhbHdoaXRlOiAweGZmZmFmMCxcbiAgICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gICAgZnVjaHNpYTogMHhmZjAwZmYsXG4gICAgZ2FpbnNib3JvOiAweGRjZGNkYyxcbiAgICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgICBnb2xkOiAweGZmZDcwMCxcbiAgICBnb2xkZW5yb2Q6IDB4ZGFhNTIwLFxuICAgIGdyYXk6IDB4ODA4MDgwLFxuICAgIGdyZWVuOiAweDAwODAwMCxcbiAgICBncmVlbnllbGxvdzogMHhhZGZmMmYsXG4gICAgZ3JleTogMHg4MDgwODAsXG4gICAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICAgIGhvdHBpbms6IDB4ZmY2OWI0LFxuICAgIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gICAgaW5kaWdvOiAweDRiMDA4MixcbiAgICBpdm9yeTogMHhmZmZmZjAsXG4gICAga2hha2k6IDB4ZjBlNjhjLFxuICAgIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNSxcbiAgICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICAgIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gICAgbGlnaHRibHVlOiAweGFkZDhlNixcbiAgICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMixcbiAgICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICAgIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICAgIGxpZ2h0Z3JleTogMHhkM2QzZDMsXG4gICAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gICAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWEsXG4gICAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gICAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5LFxuICAgIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gICAgbGltZTogMHgwMGZmMDAsXG4gICAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgICBsaW5lbjogMHhmYWYwZTYsXG4gICAgbWFnZW50YTogMHhmZjAwZmYsXG4gICAgbWFyb29uOiAweDgwMDAwMCxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgICBtZWRpdW1ibHVlOiAweDAwMDBjZCxcbiAgICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICAgIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gICAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2MsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICAgIG1pbnRjcmVhbTogMHhmNWZmZmEsXG4gICAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gICAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkLFxuICAgIG5hdnk6IDB4MDAwMDgwLFxuICAgIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICAgIG9saXZlOiAweDgwODAwMCxcbiAgICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICAgIG9yYW5nZTogMHhmZmE1MDAsXG4gICAgb3JhbmdlcmVkOiAweGZmNDUwMCxcbiAgICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICAgIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICAgIHBhbGVncmVlbjogMHg5OGZiOTgsXG4gICAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gICAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gICAgcGFwYXlhd2hpcDogMHhmZmVmZDUsXG4gICAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgICBwZXJ1OiAweGNkODUzZixcbiAgICBwaW5rOiAweGZmYzBjYixcbiAgICBwbHVtOiAweGRkYTBkZCxcbiAgICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgICBwdXJwbGU6IDB4ODAwMDgwLFxuICAgIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICAgIHJlZDogMHhmZjAwMDAsXG4gICAgcm9zeWJyb3duOiAweGJjOGY4ZixcbiAgICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICAgIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgICBzYWxtb246IDB4ZmE4MDcyLFxuICAgIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICAgIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgICBzZWFzaGVsbDogMHhmZmY1ZWUsXG4gICAgc2llbm5hOiAweGEwNTIyZCxcbiAgICBzaWx2ZXI6IDB4YzBjMGMwLFxuICAgIHNreWJsdWU6IDB4ODdjZWViLFxuICAgIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gICAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgICBzbGF0ZWdyZXk6IDB4NzA4MDkwLFxuICAgIHNub3c6IDB4ZmZmYWZhLFxuICAgIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgICBzdGVlbGJsdWU6IDB4NDY4MmI0LFxuICAgIHRhbjogMHhkMmI0OGMsXG4gICAgdGVhbDogMHgwMDgwODAsXG4gICAgdGhpc3RsZTogMHhkOGJmZDgsXG4gICAgdG9tYXRvOiAweGZmNjM0NyxcbiAgICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICAgIHZpb2xldDogMHhlZTgyZWUsXG4gICAgd2hlYXQ6IDB4ZjVkZWIzLFxuICAgIHdoaXRlOiAweGZmZmZmZixcbiAgICB3aGl0ZXNtb2tlOiAweGY1ZjVmNSxcbiAgICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICAgIHllbGxvd2dyZWVuOiAweDlhY2QzMlxuICB9O1xuXG4gIHZhciBkYXJrZXIgPSAuNztcbiAgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxuICBmdW5jdGlvbiByZ2IociwgZywgYikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgQ29sb3IpKSByID0gY29sb3Iocik7XG4gICAgICBpZiAocikge1xuICAgICAgICByID0gci5yZ2IoKTtcbiAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgZyA9IHIuZztcbiAgICAgICAgciA9IHIucjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSBnID0gYiA9IE5hTjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZ2IociwgZywgYik7XG4gIH1mdW5jdGlvbiBSZ2IociwgZywgYikge1xuICAgIHRoaXMuciA9ICtyO1xuICAgIHRoaXMuZyA9ICtnO1xuICAgIHRoaXMuYiA9ICtiO1xuICB9dmFyIF9fX19wcm90b3R5cGUgPSByZ2IucHJvdG90eXBlID0gUmdiLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfX19fcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrKTtcbiAgfTtcblxuICBfX19fcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrKTtcbiAgfTtcblxuICBfX19fcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fX19wcm90b3R5cGUuZGlzcGxheWFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5yICYmIHRoaXMuciA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMuZyAmJiB0aGlzLmcgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmIgJiYgdGhpcy5iIDw9IDI1NSk7XG4gIH07XG5cbiAgX19fX3Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfZm9ybWF0KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9mb3JtYXQociwgZywgYikge1xuICAgIHJldHVybiBcIiNcIlxuICAgICAgICArIChpc05hTihyKSA/IFwiMDBcIiA6IChyID0gTWF0aC5yb3VuZChyKSkgPCAxNiA/IFwiMFwiICsgTWF0aC5tYXgoMCwgcikudG9TdHJpbmcoMTYpIDogTWF0aC5taW4oMjU1LCByKS50b1N0cmluZygxNikpXG4gICAgICAgICsgKGlzTmFOKGcpID8gXCIwMFwiIDogKGcgPSBNYXRoLnJvdW5kKGcpKSA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCBnKS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIGcpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgKyAoaXNOYU4oYikgPyBcIjAwXCIgOiAoYiA9IE1hdGgucm91bmQoYikpIDwgMTYgPyBcIjBcIiArIE1hdGgubWF4KDAsIGIpLnRvU3RyaW5nKDE2KSA6IE1hdGgubWluKDI1NSwgYikudG9TdHJpbmcoMTYpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhzbChoLCBzLCBsKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChoIGluc3RhbmNlb2YgSHNsKSB7XG4gICAgICAgIGwgPSBoLmw7XG4gICAgICAgIHMgPSBoLnM7XG4gICAgICAgIGggPSBoLmg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShoIGluc3RhbmNlb2YgQ29sb3IpKSBoID0gY29sb3IoaCk7XG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgaWYgKGggaW5zdGFuY2VvZiBIc2wpIHJldHVybiBoO1xuICAgICAgICAgIGggPSBoLnJnYigpO1xuICAgICAgICAgIHZhciByID0gaC5yIC8gMjU1LFxuICAgICAgICAgICAgICBnID0gaC5nIC8gMjU1LFxuICAgICAgICAgICAgICBiID0gaC5iIC8gMjU1LFxuICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgICAgIHJhbmdlID0gbWF4IC0gbWluO1xuICAgICAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBzID0gbCA8IC41ID8gcmFuZ2UgLyAobWF4ICsgbWluKSA6IHJhbmdlIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgICAgICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyByYW5nZSArIChnIDwgYikgKiA2O1xuICAgICAgICAgICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHJhbmdlICsgMjtcbiAgICAgICAgICAgIGVsc2UgaCA9IChyIC0gZykgLyByYW5nZSArIDQ7XG4gICAgICAgICAgICBoICo9IDYwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoID0gTmFOO1xuICAgICAgICAgICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGggPSBzID0gbCA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEhzbChoLCBzLCBsKTtcbiAgfWZ1bmN0aW9uIEhzbChoLCBzLCBsKSB7XG4gICAgdGhpcy5oID0gK2g7XG4gICAgdGhpcy5zID0gK3M7XG4gICAgdGhpcy5sID0gK2w7XG4gIH12YXIgX19fcHJvdG90eXBlID0gaHNsLnByb3RvdHlwZSA9IEhzbC5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgX19fcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgX19fcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgX19fcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMilcbiAgICApO1xuICB9O1xuXG4gIF9fX3Byb3RvdHlwZS5kaXNwbGF5YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKTtcbiAgfTtcblxuICAvKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG4gIGZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gICAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICAgIDogbTEpICogMjU1O1xuICB9XG5cbiAgdmFyIEtuID0gMTg7XG5cbiAgdmFyIFhuID0gMC45NTA0NzA7XG4gIHZhciBZbiA9IDE7XG4gIHZhciBabiA9IDEuMDg4ODMwO1xuICB2YXIgdDAgPSA0IC8gMjk7XG4gIHZhciB0MSA9IDYgLyAyOTtcbiAgdmFyIHQyID0gMyAqIHQxICogdDE7XG4gIHZhciB0MyA9IHQxICogdDEgKiB0MTtcbiAgZnVuY3Rpb24gbGFiKGwsIGEsIGIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGwgaW5zdGFuY2VvZiBMYWIpIHtcbiAgICAgICAgYiA9IGwuYjtcbiAgICAgICAgYSA9IGwuYTtcbiAgICAgICAgbCA9IGwubDtcbiAgICAgIH0gZWxzZSBpZiAobCBpbnN0YW5jZW9mIEhjbCkge1xuICAgICAgICB2YXIgaCA9IGwuaCAqIGRlZzJyYWQ7XG4gICAgICAgIGIgPSBNYXRoLnNpbihoKSAqIGwuYztcbiAgICAgICAgYSA9IE1hdGguY29zKGgpICogbC5jO1xuICAgICAgICBsID0gbC5sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEobCBpbnN0YW5jZW9mIFJnYikpIGwgPSByZ2IobCk7XG4gICAgICAgIHZhciByID0gcmdiMnh5eihsLnIpLFxuICAgICAgICAgICAgZyA9IHJnYjJ4eXoobC5nKSxcbiAgICAgICAgICAgIGIgPSByZ2IyeHl6KGwuYiksXG4gICAgICAgICAgICB4ID0geHl6MmxhYigoMC40MTI0NTY0ICogciArIDAuMzU3NTc2MSAqIGcgKyAwLjE4MDQzNzUgKiBiKSAvIFhuKSxcbiAgICAgICAgICAgIHkgPSB4eXoybGFiKCgwLjIxMjY3MjkgKiByICsgMC43MTUxNTIyICogZyArIDAuMDcyMTc1MCAqIGIpIC8gWW4pLFxuICAgICAgICAgICAgeiA9IHh5ejJsYWIoKDAuMDE5MzMzOSAqIHIgKyAwLjExOTE5MjAgKiBnICsgMC45NTAzMDQxICogYikgLyBabik7XG4gICAgICAgIGIgPSAyMDAgKiAoeSAtIHopO1xuICAgICAgICBhID0gNTAwICogKHggLSB5KTtcbiAgICAgICAgbCA9IDExNiAqIHkgLSAxNjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMYWIobCwgYSwgYik7XG4gIH1mdW5jdGlvbiBMYWIobCwgYSwgYikge1xuICAgIHRoaXMubCA9ICtsO1xuICAgIHRoaXMuYSA9ICthO1xuICAgIHRoaXMuYiA9ICtiO1xuICB9dmFyIF9fcHJvdG90eXBlID0gbGFiLnByb3RvdHlwZSA9IExhYi5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgX19wcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgS24gKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG5cbiAgX19wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEtuICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuXG4gIF9fcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIHh5ejJyZ2IoIDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIC8vIEQ2NSAtPiBzUkdCXG4gICAgICB4eXoycmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopLFxuICAgICAgeHl6MnJnYiggMC4wNTU2NDM0ICogeCAtIDAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KVxuICAgICk7XG4gIH07XG5cbiAgZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xuICB9XG5cbiAgZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG4gIH1cblxuICBmdW5jdGlvbiB4eXoycmdiKHgpIHtcbiAgICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJnYjJ4eXooeCkge1xuICAgIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9XG5cbiAgdmFyIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5cbiAgZnVuY3Rpb24gaGNsKGgsIGMsIGwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGggaW5zdGFuY2VvZiBIY2wpIHtcbiAgICAgICAgbCA9IGgubDtcbiAgICAgICAgYyA9IGguYztcbiAgICAgICAgaCA9IGguaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGggaW5zdGFuY2VvZiBMYWIpKSBoID0gbGFiKGgpO1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBjID0gTWF0aC5zcXJ0KGguYSAqIGguYSArIGguYiAqIGguYik7XG4gICAgICAgIGggPSBNYXRoLmF0YW4yKGguYiwgaC5hKSAqIHJhZDJkZWc7XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSGNsKGgsIGMsIGwpO1xuICB9ZnVuY3Rpb24gSGNsKGgsIGMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLmMgPSArYztcbiAgICB0aGlzLmwgPSArbDtcbiAgfXZhciBfcHJvdG90eXBlID0gaGNsLnByb3RvdHlwZSA9IEhjbC5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgX3Byb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgS24gKiAoayA9PSBudWxsID8gMSA6IGspKTtcbiAgfTtcblxuICBfcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gS24gKiAoayA9PSBudWxsID8gMSA6IGspKTtcbiAgfTtcblxuICBfcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsYWIodGhpcykucmdiKCk7XG4gIH07XG5cbiAgdmFyIEEgPSAtMC4xNDg2MTtcbiAgdmFyIEIgPSArMS43ODI3NztcbiAgdmFyIEMgPSAtMC4yOTIyNztcbiAgdmFyIEQgPSAtMC45MDY0OTtcbiAgdmFyIEUgPSArMS45NzI5NDtcbiAgdmFyIEVEID0gRSAqIEQ7XG4gIHZhciBFQiA9IEUgKiBCO1xuICB2YXIgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuICBmdW5jdGlvbiBjdWJlaGVsaXgoaCwgcywgbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaCBpbnN0YW5jZW9mIEN1YmVoZWxpeCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIFJnYikpIGggPSByZ2IoaCk7XG4gICAgICAgIHZhciByID0gaC5yIC8gMjU1LCBnID0gaC5nIC8gMjU1LCBiID0gaC5iIC8gMjU1O1xuICAgICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKTtcbiAgICAgICAgdmFyIGJsID0gYiAtIGwsIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRDtcbiAgICAgICAgcyA9IE1hdGguc3FydChrICogayArIGJsICogYmwpIC8gKEUgKiBsICogKDEgLSBsKSk7IC8vIE5hTiBpZiBsPTAgb3IgbD0xXG4gICAgICAgIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiByYWQyZGVnIC0gMTIwIDogTmFOO1xuICAgICAgICBpZiAoaCA8IDApIGggKz0gMzYwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeChoLCBzLCBsKTtcbiAgfWZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsKSB7XG4gICAgdGhpcy5oID0gK2g7XG4gICAgdGhpcy5zID0gK3M7XG4gICAgdGhpcy5sID0gK2w7XG4gIH12YXIgcHJvdG90eXBlID0gY3ViZWhlbGl4LnByb3RvdHlwZSA9IEN1YmVoZWxpeC5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gaXNOYU4odGhpcy5oKSA/IDAgOiAodGhpcy5oICsgMTIwKSAqIGRlZzJyYWQsXG4gICAgICAgIGwgPSArdGhpcy5sLFxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcbiAgICAgICAgY29zaCA9IE1hdGguY29zKGgpLFxuICAgICAgICBzaW5oID0gTWF0aC5zaW4oaCk7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICAyNTUgKiAobCArIGEgKiAoQSAqIGNvc2ggKyBCICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEMgKiBjb3NoICsgRCAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpXG4gICAgKTtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hKGdhbW1hKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGEgPSBjdWJlaGVsaXgoYSk7XG4gICAgICBiID0gY3ViZWhlbGl4KGIpO1xuICAgICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGRlbHRhSHVlKGIuaCwgYWgpLFxuICAgICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICAgIGEucyA9IGFzICsgYnMgKiB0O1xuICAgICAgICBhLmwgPSBhbCArIGJsICogTWF0aC5wb3codCwgZ2FtbWEpO1xuICAgICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hTG9uZyhnYW1tYSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBhID0gY3ViZWhlbGl4KGEpO1xuICAgICAgYiA9IGN1YmVoZWxpeChiKTtcbiAgICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgICAgYXMgPSBpc05hTihhLnMpID8gYi5zIDogYS5zLFxuICAgICAgICAgIGFsID0gYS5sLFxuICAgICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBiLmggLSBhaCxcbiAgICAgICAgICBicyA9IGlzTmFOKGIucykgPyAwIDogYi5zIC0gYXMsXG4gICAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgICBhLnMgPSBhcyArIGJzICogdDtcbiAgICAgICAgYS5sID0gYWwgKyBibCAqIE1hdGgucG93KHQsIGdhbW1hKTtcbiAgICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIY2xMb25nKGEsIGIpIHtcbiAgICBhID0gaGNsKGEpO1xuICAgIGIgPSBoY2woYik7XG4gICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgYWMgPSBpc05hTihhLmMpID8gYi5jIDogYS5jLFxuICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGIuaCAtIGFoLFxuICAgICAgICBiYyA9IGlzTmFOKGIuYykgPyAwIDogYi5jIC0gYWMsXG4gICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgYS5jID0gYWMgKyBiYyAqIHQ7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIY2woYSwgYikge1xuICAgIGEgPSBoY2woYSk7XG4gICAgYiA9IGhjbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhYyA9IGlzTmFOKGEuYykgPyBiLmMgOiBhLmMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogZGVsdGFIdWUoYi5oLCBhaCksXG4gICAgICAgIGJjID0gaXNOYU4oYi5jKSA/IDAgOiBiLmMgLSBhYyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLmMgPSBhYyArIGJjICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUxhYihhLCBiKSB7XG4gICAgYSA9IGxhYihhKTtcbiAgICBiID0gbGFiKGIpO1xuICAgIHZhciBhbCA9IGEubCxcbiAgICAgICAgYWEgPSBhLmEsXG4gICAgICAgIGFiID0gYS5iLFxuICAgICAgICBibCA9IGIubCAtIGFsLFxuICAgICAgICBiYSA9IGIuYSAtIGFhLFxuICAgICAgICBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIGEuYSA9IGFhICsgYmEgKiB0O1xuICAgICAgYS5iID0gYWIgKyBiYiAqIHQ7XG4gICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlSHNsTG9uZyhhLCBiKSB7XG4gICAgYSA9IGhzbChhKTtcbiAgICBiID0gaHNsKGIpO1xuICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgIGFzID0gaXNOYU4oYS5zKSA/IGIucyA6IGEucyxcbiAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBiLmggLSBhaCxcbiAgICAgICAgYnMgPSBpc05hTihiLnMpID8gMCA6IGIucyAtIGFzLFxuICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgIGEucyA9IGFzICsgYnMgKiB0O1xuICAgICAgYS5sID0gYWwgKyBibCAqIHQ7XG4gICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlSHNsKGEsIGIpIHtcbiAgICBhID0gaHNsKGEpO1xuICAgIGIgPSBoc2woYik7XG4gICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgYXMgPSBpc05hTihhLnMpID8gYi5zIDogYS5zLFxuICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGRlbHRhSHVlKGIuaCwgYWgpLFxuICAgICAgICBicyA9IGlzTmFOKGIucykgPyAwIDogYi5zIC0gYXMsXG4gICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVSZ2IoYSwgYikge1xuICAgIGEgPSByZ2IoYSk7XG4gICAgYiA9IHJnYihiKTtcbiAgICB2YXIgYXIgPSBhLnIsXG4gICAgICAgIGFnID0gYS5nLFxuICAgICAgICBhYiA9IGEuYixcbiAgICAgICAgYnIgPSBiLnIgLSBhcixcbiAgICAgICAgYmcgPSBiLmcgLSBhZyxcbiAgICAgICAgYmIgPSBiLmIgLSBhYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIF9mb3JtYXQoTWF0aC5yb3VuZChhciArIGJyICogdCksIE1hdGgucm91bmQoYWcgKyBiZyAqIHQpLCBNYXRoLnJvdW5kKGFiICsgYmIgKiB0KSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0ZUN1YmVoZWxpeCA9IGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWEoMSk7XG4gIHZhciBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hTG9uZygxKTtcblxuICBleHBvcnRzLmludGVycG9sYXRlQ3ViZWhlbGl4ID0gaW50ZXJwb2xhdGVDdWJlaGVsaXg7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nID0gaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nO1xuICBleHBvcnRzLmNvbG9yID0gY29sb3I7XG4gIGV4cG9ydHMucmdiID0gcmdiO1xuICBleHBvcnRzLmhzbCA9IGhzbDtcbiAgZXhwb3J0cy5sYWIgPSBsYWI7XG4gIGV4cG9ydHMuaGNsID0gaGNsO1xuICBleHBvcnRzLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYiA9IGludGVycG9sYXRlUmdiO1xuICBleHBvcnRzLmludGVycG9sYXRlSHNsID0gaW50ZXJwb2xhdGVIc2w7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIc2xMb25nID0gaW50ZXJwb2xhdGVIc2xMb25nO1xuICBleHBvcnRzLmludGVycG9sYXRlTGFiID0gaW50ZXJwb2xhdGVMYWI7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIY2wgPSBpbnRlcnBvbGF0ZUhjbDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbExvbmcgPSBpbnRlcnBvbGF0ZUhjbExvbmc7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYSA9IGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWE7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYUxvbmcgPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hTG9uZztcblxufSkpOyIsImlmICh0eXBlb2YgTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIE1hcCA9IGZ1bmN0aW9uKCkgeyB0aGlzLmNsZWFyKCk7IH07XG4gIE1hcC5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihrLCB2KSB7IHRoaXMuX1trXSA9IHY7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldDogZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5fW2tdOyB9LFxuICAgIGhhczogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl87IH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbihrKSB7IHJldHVybiBrIGluIHRoaXMuXyAmJiBkZWxldGUgdGhpcy5fW2tdOyB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHsgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfSxcbiAgICBnZXQgc2l6ZSgpIHsgdmFyIG4gPSAwOyBmb3IgKHZhciBrIGluIHRoaXMuXykgKytuOyByZXR1cm4gbjsgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjKSB7IGZvciAodmFyIGsgaW4gdGhpcy5fKSBjKHRoaXMuX1trXSwgaywgdGhpcyk7IH1cbiAgfTtcbn0gZWxzZSAoZnVuY3Rpb24oKSB7XG4gIHZhciBtID0gbmV3IE1hcDtcbiAgaWYgKG0uc2V0KDAsIDApICE9PSBtKSB7XG4gICAgbSA9IG0uc2V0O1xuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7IG0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIHRoaXM7IH07XG4gIH1cbn0pKCk7XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmZvcm1hdCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgemhDbiA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIsKlXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIHJ1UnUgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDRgNGD0LEuXCJdXG4gIH07XG5cbiAgdmFyIHB0QnIgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJSJFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBwbFBsID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiesWCXCJdXG4gIH07XG5cbiAgdmFyIG5sTmwgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLigqxcXHhhMFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBta01rID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDQtNC10L0uXCJdXG4gIH07XG5cbiAgdmFyIGphSnAgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCLlhoZcIl1cbiAgfTtcblxuICB2YXIgaXRJdCA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIuKCrFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBoZUlsID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wi4oKqXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGZyRnIgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBmckNhID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCJcXHhhMFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIiRcIl1cbiAgfTtcblxuICB2YXIgZmlGaSA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiXFx4YTBcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBlc0VzID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfTtcblxuICB2YXIgZW5VcyA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZW5HYiA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIsKjXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGVuQ2EgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGRlRGUgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBjYUVzID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfTtcblxuXG4gIC8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbiAgLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4gIC8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuICBmdW5jdGlvbiBmb3JtYXREZWNpbWFsKHgsIHApIHtcbiAgICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gICAgLy8gVGhlIHN0cmluZyByZXR1cm5lZCBieSB0b0V4cG9uZW50aWFsIGVpdGhlciBoYXMgdGhlIGZvcm0gXFxkXFwuXFxkK2VbLStdXFxkK1xuICAgIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gICAgcmV0dXJuIFtcbiAgICAgIGNvZWZmaWNpZW50Lmxlbmd0aCA+IDEgPyBjb2VmZmljaWVudFswXSArIGNvZWZmaWNpZW50LnNsaWNlKDIpIDogY29lZmZpY2llbnQsXG4gICAgICAreC5zbGljZShpICsgMSlcbiAgICBdO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwb25lbnQoeCkge1xuICAgIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbChNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xuICB9XG5cbiAgdmFyIHByZWZpeEV4cG9uZW50O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeEF1dG8oeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBwICsgaSAtIDEpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3VuZGVkKHgsIHApIHtcbiAgICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gICAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICAgIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0KHgsIHApIHtcbiAgICB4ID0geC50b1ByZWNpc2lvbihwKTtcblxuICAgIG91dDogZm9yICh2YXIgbiA9IHgubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN3aXRjaCAoeFtpXSkge1xuICAgICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZVwiOiBicmVhayBvdXQ7XG4gICAgICAgIGRlZmF1bHQ6IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGkwID4gMCA/IHguc2xpY2UoMCwgaTApICsgeC5zbGljZShpMSArIDEpIDogeDtcbiAgfVxuXG4gIHZhciBmb3JtYXRUeXBlcyA9IHtcbiAgICBcIlwiOiBmb3JtYXREZWZhdWx0LFxuICAgIFwiJVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiAoeCAqIDEwMCkudG9GaXhlZChwKTsgfSxcbiAgICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgICBcImNcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4geCArIFwiXCI7IH0sXG4gICAgXCJkXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTApOyB9LFxuICAgIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gICAgXCJmXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9GaXhlZChwKTsgfSxcbiAgICBcImdcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b1ByZWNpc2lvbihwKTsgfSxcbiAgICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgICBcInBcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKTsgfSxcbiAgICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgICBcIlhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfSxcbiAgICBcInhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNik7IH1cbiAgfTtcblxuXG4gIC8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bdHlwZV1cbiAgdmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLVxcKCBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLlxcZCspPyhbYS16JV0pPyQvaTtcblxuICBmdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG5cbiAgICB2YXIgbWF0Y2gsXG4gICAgICAgIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIixcbiAgICAgICAgYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIixcbiAgICAgICAgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLFxuICAgICAgICBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLFxuICAgICAgICB6ZXJvID0gISFtYXRjaFs1XSxcbiAgICAgICAgd2lkdGggPSBtYXRjaFs2XSAmJiArbWF0Y2hbNl0sXG4gICAgICAgIGNvbW1hID0gISFtYXRjaFs3XSxcbiAgICAgICAgcHJlY2lzaW9uID0gbWF0Y2hbOF0gJiYgK21hdGNoWzhdLnNsaWNlKDEpLFxuICAgICAgICB0eXBlID0gbWF0Y2hbOV0gfHwgXCJcIjtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIE1hcCBpbnZhbGlkIHR5cGVzIHRvIHRoZSBkZWZhdWx0IGZvcm1hdC5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHR5cGUgPSBcIlwiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLnNpZ24gPSBzaWduO1xuICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgIHRoaXMuemVybyA9IHplcm87XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY29tbWEgPSBjb21tYTtcbiAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICAgKyB0aGlzLmFsaWduXG4gICAgICAgICsgdGhpcy5zaWduXG4gICAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLndpZHRoID09IG51bGwgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLnByZWNpc2lvbiA9PSBudWxsID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICAgKyB0aGlzLnR5cGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIHQgPSBbXSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgJiYgbG9jYWxlLnRob3VzYW5kcyA/IGZvcm1hdEdyb3VwKGxvY2FsZS5ncm91cGluZywgbG9jYWxlLnRob3VzYW5kcykgOiBpZGVudGl0eSxcbiAgICAgICAgY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksXG4gICAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbDtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdChzcGVjaWZpZXIpIHtcbiAgICAgIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuXG4gICAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICAgIHNpZ24gPSBzcGVjaWZpZXIuc2lnbixcbiAgICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgICB3aWR0aCA9IHNwZWNpZmllci53aWR0aCxcbiAgICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMF0gOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzFdIDogL1slcF0vLnRlc3QodHlwZSkgPyBcIiVcIiA6IFwiXCI7XG5cbiAgICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICAgIG1heWJlU3VmZml4ID0gIXR5cGUgfHwgL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/ICh0eXBlID8gNiA6IDEyKVxuICAgICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgICAgdmFsdWVTdWZmaXggPSBzdWZmaXg7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgICAgdmFsdWVTdWZmaXggPSBmb3JtYXRUeXBlKHZhbHVlKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgbmVnYXRpdmUgdG8gcG9zaXRpdmUsIGFuZCBjb21wdXRlIHRoZSBwcmVmaXguXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IC0wIGlzIG5vdCBsZXNzIHRoYW4gMCwgYnV0IDEgLyAtMCBpcyFcbiAgICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9ICh2YWx1ZSA8IDAgfHwgMSAvIHZhbHVlIDwgMCkgJiYgKHZhbHVlICo9IC0xLCB0cnVlKTtcblxuICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgICB2YWx1ZSA9IGZvcm1hdFR5cGUodmFsdWUsIHByZWNpc2lvbik7XG5cbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XG4gICAgICAgICAgdmFsdWVTdWZmaXggPSB2YWx1ZVN1ZmZpeCArICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyAodmFsdWVOZWdhdGl2ZSAmJiBzaWduID09PSBcIihcIiA/IFwiKVwiIDogXCJcIik7XG5cbiAgICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICAgIGlmIChtYXliZVN1ZmZpeCkge1xuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aCwgYztcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gKGMgPT09IDQ2ID8gZGVjaW1hbCArIHZhbHVlLnNsaWNlKGkgKyAxKSA6IHZhbHVlLnNsaWNlKGkpKSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwYWRkaW5nLlxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGFmdGVyIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgICBjYXNlIFwiPFwiOiByZXR1cm4gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZztcbiAgICAgICAgICBjYXNlIFwiPVwiOiByZXR1cm4gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICBjYXNlIFwiXlwiOiByZXR1cm4gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpIHtcbiAgICAgIHZhciBmID0gZm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzLFxuICAgICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uUm91bmQoc3RlcCwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50KE1hdGguYWJzKG1heCkpIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKSArIDE7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uRml4ZWQoc3RlcCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbiAgfVxuXG4gIHZhciBsb2NhbGVEZWZpbml0aW9ucyA9IChuZXcgTWFwKVxuICAgICAgLnNldChcImNhLUVTXCIsIGNhRXMpXG4gICAgICAuc2V0KFwiZGUtREVcIiwgZGVEZSlcbiAgICAgIC5zZXQoXCJlbi1DQVwiLCBlbkNhKVxuICAgICAgLnNldChcImVuLUdCXCIsIGVuR2IpXG4gICAgICAuc2V0KFwiZW4tVVNcIiwgZW5VcylcbiAgICAgIC5zZXQoXCJlcy1FU1wiLCBlc0VzKVxuICAgICAgLnNldChcImZpLUZJXCIsIGZpRmkpXG4gICAgICAuc2V0KFwiZnItQ0FcIiwgZnJDYSlcbiAgICAgIC5zZXQoXCJmci1GUlwiLCBmckZyKVxuICAgICAgLnNldChcImhlLUlMXCIsIGhlSWwpXG4gICAgICAuc2V0KFwiaXQtSVRcIiwgaXRJdClcbiAgICAgIC5zZXQoXCJqYS1KUFwiLCBqYUpwKVxuICAgICAgLnNldChcIm1rLU1LXCIsIG1rTWspXG4gICAgICAuc2V0KFwibmwtTkxcIiwgbmxObClcbiAgICAgIC5zZXQoXCJwbC1QTFwiLCBwbFBsKVxuICAgICAgLnNldChcInB0LUJSXCIsIHB0QnIpXG4gICAgICAuc2V0KFwicnUtUlVcIiwgcnVSdSlcbiAgICAgIC5zZXQoXCJ6aC1DTlwiLCB6aENuKTtcblxuICB2YXIgZGVmYXVsdExvY2FsZSA9IGxvY2FsZShlblVzKTtcbiAgZXhwb3J0cy5mb3JtYXQgPSBkZWZhdWx0TG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy5mb3JtYXRQcmVmaXggPSBkZWZhdWx0TG9jYWxlLmZvcm1hdFByZWZpeDtcblxuICBmdW5jdGlvbiBsb2NhbGVGb3JtYXQoZGVmaW5pdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVmaW5pdGlvbiA9IGxvY2FsZURlZmluaXRpb25zLmdldChkZWZpbml0aW9uKTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGUoZGVmaW5pdGlvbik7XG4gIH1cbiAgO1xuXG4gIGV4cG9ydHMubG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0O1xuICBleHBvcnRzLmZvcm1hdFNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcjtcbiAgZXhwb3J0cy5wcmVjaXNpb25GaXhlZCA9IHByZWNpc2lvbkZpeGVkO1xuICBleHBvcnRzLnByZWNpc2lvblByZWZpeCA9IHByZWNpc2lvblByZWZpeDtcbiAgZXhwb3J0cy5wcmVjaXNpb25Sb3VuZCA9IHByZWNpc2lvblJvdW5kO1xuXG59KSk7IiwiaWYgKHR5cGVvZiBNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgTWFwID0gZnVuY3Rpb24oKSB7IHRoaXMuY2xlYXIoKTsgfTtcbiAgTWFwLnByb3RvdHlwZSA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHsgdGhpcy5fW2tdID0gdjsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLl9ba107IH0sXG4gICAgaGFzOiBmdW5jdGlvbihrKSB7IHJldHVybiBrIGluIHRoaXMuXzsgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIGsgaW4gdGhpcy5fICYmIGRlbGV0ZSB0aGlzLl9ba107IH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkgeyB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9LFxuICAgIGdldCBzaXplKCkgeyB2YXIgbiA9IDA7IGZvciAodmFyIGsgaW4gdGhpcy5fKSArK247IHJldHVybiBuOyB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGMpIHsgZm9yICh2YXIgayBpbiB0aGlzLl8pIGModGhpcy5fW2tdLCBrLCB0aGlzKTsgfVxuICB9O1xufSBlbHNlIChmdW5jdGlvbigpIHtcbiAgdmFyIG0gPSBuZXcgTWFwO1xuICBpZiAobS5zZXQoMCwgMCkgIT09IG0pIHtcbiAgICBtID0gbS5zZXQ7XG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHsgbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gdGhpczsgfTtcbiAgfVxufSkoKTtcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICBmYWN0b3J5KChnbG9iYWwudGltZUZvcm1hdCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgemhDbiA9IHtcbiAgICBkYXRlVGltZTogXCIlYSAlYiAlZSAlWCAlWVwiLFxuICAgIGRhdGU6IFwiJVkvJS1tLyUtZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCLkuIrljYhcIiwgXCLkuIvljYhcIl0sXG4gICAgZGF5czogW1wi5pif5pyf5pelXCIsIFwi5pif5pyf5LiAXCIsIFwi5pif5pyf5LqMXCIsIFwi5pif5pyf5LiJXCIsIFwi5pif5pyf5ZubXCIsIFwi5pif5pyf5LqUXCIsIFwi5pif5pyf5YWtXCJdLFxuICAgIHNob3J0RGF5czogW1wi5pif5pyf5pelXCIsIFwi5pif5pyf5LiAXCIsIFwi5pif5pyf5LqMXCIsIFwi5pif5pyf5LiJXCIsIFwi5pif5pyf5ZubXCIsIFwi5pif5pyf5LqUXCIsIFwi5pif5pyf5YWtXCJdLFxuICAgIG1vbnRoczogW1wi5LiA5pyIXCIsIFwi5LqM5pyIXCIsIFwi5LiJ5pyIXCIsIFwi5Zub5pyIXCIsIFwi5LqU5pyIXCIsIFwi5YWt5pyIXCIsIFwi5LiD5pyIXCIsIFwi5YWr5pyIXCIsIFwi5Lmd5pyIXCIsIFwi5Y2B5pyIXCIsIFwi5Y2B5LiA5pyIXCIsIFwi5Y2B5LqM5pyIXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCLkuIDmnIhcIiwgXCLkuozmnIhcIiwgXCLkuInmnIhcIiwgXCLlm5vmnIhcIiwgXCLkupTmnIhcIiwgXCLlha3mnIhcIiwgXCLkuIPmnIhcIiwgXCLlhavmnIhcIiwgXCLkuZ3mnIhcIiwgXCLljYHmnIhcIiwgXCLljYHkuIDmnIhcIiwgXCLljYHkuozmnIhcIl1cbiAgfTtcblxuICB2YXIgcnVSdSA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVkg0LMuICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcItCy0L7RgdC60YDQtdGB0LXQvdGM0LVcIiwgXCLQv9C+0L3QtdC00LXQu9GM0L3QuNC6XCIsIFwi0LLRgtC+0YDQvdC40LpcIiwgXCLRgdGA0LXQtNCwXCIsIFwi0YfQtdGC0LLQtdGA0LNcIiwgXCLQv9GP0YLQvdC40YbQsFwiLCBcItGB0YPQsdCx0L7RgtCwXCJdLFxuICAgIHNob3J0RGF5czogW1wi0LLRgVwiLCBcItC/0L1cIiwgXCLQstGCXCIsIFwi0YHRgFwiLCBcItGH0YJcIiwgXCLQv9GCXCIsIFwi0YHQsVwiXSxcbiAgICBtb250aHM6IFtcItGP0L3QstCw0YDRj1wiLCBcItGE0LXQstGA0LDQu9GPXCIsIFwi0LzQsNGA0YLQsFwiLCBcItCw0L/RgNC10LvRj1wiLCBcItC80LDRj1wiLCBcItC40Y7QvdGPXCIsIFwi0LjRjtC70Y9cIiwgXCLQsNCy0LPRg9GB0YLQsFwiLCBcItGB0LXQvdGC0Y/QsdGA0Y9cIiwgXCLQvtC60YLRj9Cx0YDRj1wiLCBcItC90L7Rj9Cx0YDRj1wiLCBcItC00LXQutCw0LHRgNGPXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCLRj9C90LJcIiwgXCLRhNC10LJcIiwgXCLQvNCw0YBcIiwgXCLQsNC/0YBcIiwgXCLQvNCw0LlcIiwgXCLQuNGO0L1cIiwgXCLQuNGO0LtcIiwgXCLQsNCy0LNcIiwgXCLRgdC10L1cIiwgXCLQvtC60YJcIiwgXCLQvdC+0Y9cIiwgXCLQtNC10LpcIl1cbiAgfTtcblxuICB2YXIgcHRCciA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVkuICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIkRvbWluZ29cIiwgXCJTZWd1bmRhXCIsIFwiVGVyw6dhXCIsIFwiUXVhcnRhXCIsIFwiUXVpbnRhXCIsIFwiU2V4dGFcIiwgXCJTw6FiYWRvXCJdLFxuICAgIHNob3J0RGF5czogW1wiRG9tXCIsIFwiU2VnXCIsIFwiVGVyXCIsIFwiUXVhXCIsIFwiUXVpXCIsIFwiU2V4XCIsIFwiU8OhYlwiXSxcbiAgICBtb250aHM6IFtcIkphbmVpcm9cIiwgXCJGZXZlcmVpcm9cIiwgXCJNYXLDp29cIiwgXCJBYnJpbFwiLCBcIk1haW9cIiwgXCJKdW5ob1wiLCBcIkp1bGhvXCIsIFwiQWdvc3RvXCIsIFwiU2V0ZW1icm9cIiwgXCJPdXR1YnJvXCIsIFwiTm92ZW1icm9cIiwgXCJEZXplbWJyb1wiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmV2XCIsIFwiTWFyXCIsIFwiQWJyXCIsIFwiTWFpXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQWdvXCIsIFwiU2V0XCIsIFwiT3V0XCIsIFwiTm92XCIsIFwiRGV6XCJdXG4gIH07XG5cbiAgdmFyIHBsUGwgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiTmllZHppZWxhXCIsIFwiUG9uaWVkemlhxYJla1wiLCBcIld0b3Jla1wiLCBcIsWacm9kYVwiLCBcIkN6d2FydGVrXCIsIFwiUGnEhXRla1wiLCBcIlNvYm90YVwiXSxcbiAgICBzaG9ydERheXM6IFtcIk5pZWR6LlwiLCBcIlBvbi5cIiwgXCJXdC5cIiwgXCLFmnIuXCIsIFwiQ3p3LlwiLCBcIlB0LlwiLCBcIlNvYi5cIl0sXG4gICAgbW9udGhzOiBbXCJTdHljemXFhFwiLCBcIkx1dHlcIiwgXCJNYXJ6ZWNcIiwgXCJLd2llY2llxYRcIiwgXCJNYWpcIiwgXCJDemVyd2llY1wiLCBcIkxpcGllY1wiLCBcIlNpZXJwaWXFhFwiLCBcIldyemVzaWXFhFwiLCBcIlBhxbpkemllcm5pa1wiLCBcIkxpc3RvcGFkXCIsIFwiR3J1ZHppZcWEXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJTdHljei5cIiwgXCJMdXR5XCIsIFwiTWFyei5cIiwgXCJLd2llLlwiLCBcIk1halwiLCBcIkN6ZXJ3LlwiLCBcIkxpcGMuXCIsIFwiU2llcnAuXCIsIFwiV3J6LlwiLCBcIlBhxbpkei5cIiwgXCJMaXN0b3AuXCIsIFwiR3J1ZHouXCJdLyogSW4gUG9saXNoIGxhbmd1YWdlIGFiYnJhdmlhdGVkIG1vbnRocyBhcmUgbm90IGNvbW1vbmx5IHVzZWQgc28gdGhlcmUgaXMgYSBkaXNwdXRlIGFib3V0IHRoZSBwcm9wZXIgYWJicmF2aWF0aW9ucy4gKi9cbiAgfTtcblxuICB2YXIgbmxObCA9IHtcbiAgICBkYXRlVGltZTogXCIlYSAlZSAlQiAlWSAlVFwiLFxuICAgIGRhdGU6IFwiJWQtJW0tJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiem9uZGFnXCIsIFwibWFhbmRhZ1wiLCBcImRpbnNkYWdcIiwgXCJ3b2Vuc2RhZ1wiLCBcImRvbmRlcmRhZ1wiLCBcInZyaWpkYWdcIiwgXCJ6YXRlcmRhZ1wiXSxcbiAgICBzaG9ydERheXM6IFtcInpvXCIsIFwibWFcIiwgXCJkaVwiLCBcIndvXCIsIFwiZG9cIiwgXCJ2clwiLCBcInphXCJdLFxuICAgIG1vbnRoczogW1wiamFudWFyaVwiLCBcImZlYnJ1YXJpXCIsIFwibWFhcnRcIiwgXCJhcHJpbFwiLCBcIm1laVwiLCBcImp1bmlcIiwgXCJqdWxpXCIsIFwiYXVndXN0dXNcIiwgXCJzZXB0ZW1iZXJcIiwgXCJva3RvYmVyXCIsIFwibm92ZW1iZXJcIiwgXCJkZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFuXCIsIFwiZmViXCIsIFwibXJ0XCIsIFwiYXByXCIsIFwibWVpXCIsIFwianVuXCIsIFwianVsXCIsIFwiYXVnXCIsIFwic2VwXCIsIFwib2t0XCIsIFwibm92XCIsIFwiZGVjXCJdXG4gIH07XG5cbiAgdmFyIG1rTWsgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlICVCICVZINCzLiAlWFwiLFxuICAgIGRhdGU6IFwiJWQuJW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCLQvdC10LTQtdC70LBcIiwgXCLQv9C+0L3QtdC00LXQu9C90LjQulwiLCBcItCy0YLQvtGA0L3QuNC6XCIsIFwi0YHRgNC10LTQsFwiLCBcItGH0LXRgtCy0YDRgtC+0LpcIiwgXCLQv9C10YLQvtC6XCIsIFwi0YHQsNCx0L7RgtCwXCJdLFxuICAgIHNob3J0RGF5czogW1wi0L3QtdC0XCIsIFwi0L/QvtC9XCIsIFwi0LLRgtC+XCIsIFwi0YHRgNC1XCIsIFwi0YfQtdGCXCIsIFwi0L/QtdGCXCIsIFwi0YHQsNCxXCJdLFxuICAgIG1vbnRoczogW1wi0ZjQsNC90YPQsNGA0LhcIiwgXCLRhNC10LLRgNGD0LDRgNC4XCIsIFwi0LzQsNGA0YJcIiwgXCLQsNC/0YDQuNC7XCIsIFwi0LzQsNGYXCIsIFwi0ZjRg9C90LhcIiwgXCLRmNGD0LvQuFwiLCBcItCw0LLQs9GD0YHRglwiLCBcItGB0LXQv9GC0LXQvNCy0YDQuFwiLCBcItC+0LrRgtC+0LzQstGA0LhcIiwgXCLQvdC+0LXQvNCy0YDQuFwiLCBcItC00LXQutC10LzQstGA0LhcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcItGY0LDQvVwiLCBcItGE0LXQslwiLCBcItC80LDRgFwiLCBcItCw0L/RgFwiLCBcItC80LDRmFwiLCBcItGY0YPQvVwiLCBcItGY0YPQu1wiLCBcItCw0LLQs1wiLCBcItGB0LXQv1wiLCBcItC+0LrRglwiLCBcItC90L7QtVwiLCBcItC00LXQulwiXVxuICB9O1xuXG4gIHZhciBpdEl0ID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiRG9tZW5pY2FcIiwgXCJMdW5lZMOsXCIsIFwiTWFydGVkw6xcIiwgXCJNZXJjb2xlZMOsXCIsIFwiR2lvdmVkw6xcIiwgXCJWZW5lcmTDrFwiLCBcIlNhYmF0b1wiXSxcbiAgICBzaG9ydERheXM6IFtcIkRvbVwiLCBcIkx1blwiLCBcIk1hclwiLCBcIk1lclwiLCBcIkdpb1wiLCBcIlZlblwiLCBcIlNhYlwiXSxcbiAgICBtb250aHM6IFtcIkdlbm5haW9cIiwgXCJGZWJicmFpb1wiLCBcIk1hcnpvXCIsIFwiQXByaWxlXCIsIFwiTWFnZ2lvXCIsIFwiR2l1Z25vXCIsIFwiTHVnbGlvXCIsIFwiQWdvc3RvXCIsIFwiU2V0dGVtYnJlXCIsIFwiT3R0b2JyZVwiLCBcIk5vdmVtYnJlXCIsIFwiRGljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkdlblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1hZ1wiLCBcIkdpdVwiLCBcIkx1Z1wiLCBcIkFnb1wiLCBcIlNldFwiLCBcIk90dFwiLCBcIk5vdlwiLCBcIkRpY1wiXVxuICB9O1xuXG4gIHZhciBoZUlsID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSDXkSVCICVZICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIteo15DXqdeV159cIiwgXCLXqdeg15lcIiwgXCLXqdec15nXqdeZXCIsIFwi16jXkdeZ16LXmVwiLCBcIteX157Xmdep15lcIiwgXCLXqdeZ16nXmVwiLCBcItep15HXqlwiXSxcbiAgICBzaG9ydERheXM6IFtcIteQ17NcIiwgXCLXkdezXCIsIFwi15LXs1wiLCBcIteT17NcIiwgXCLXlNezXCIsIFwi15XXs1wiLCBcItep17NcIl0sXG4gICAgbW9udGhzOiBbXCLXmdeg15XXkNeoXCIsIFwi16TXkdeo15XXkNeoXCIsIFwi157XqNelXCIsIFwi15DXpNeo15nXnFwiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXldeh15hcIiwgXCLXodek15jXnteR16hcIiwgXCLXkNeV16fXmNeV15HXqFwiLCBcIteg15XXkdee15HXqFwiLCBcIteT16bXnteR16hcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIteZ16DXldezXCIsIFwi16TXkdeo17NcIiwgXCLXnteo16VcIiwgXCLXkNek16jXs1wiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXs1wiLCBcIteh16TXmNezXCIsIFwi15DXlden17NcIiwgXCLXoNeV15HXs1wiLCBcIteT16bXntezXCJdXG4gIH07XG5cbiAgdmFyIGZyRnIgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsIGxlICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiZGltYW5jaGVcIiwgXCJsdW5kaVwiLCBcIm1hcmRpXCIsIFwibWVyY3JlZGlcIiwgXCJqZXVkaVwiLCBcInZlbmRyZWRpXCIsIFwic2FtZWRpXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGltLlwiLCBcImx1bi5cIiwgXCJtYXIuXCIsIFwibWVyLlwiLCBcImpldS5cIiwgXCJ2ZW4uXCIsIFwic2FtLlwiXSxcbiAgICBtb250aHM6IFtcImphbnZpZXJcIiwgXCJmw6l2cmllclwiLCBcIm1hcnNcIiwgXCJhdnJpbFwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsbGV0XCIsIFwiYW/Du3RcIiwgXCJzZXB0ZW1icmVcIiwgXCJvY3RvYnJlXCIsIFwibm92ZW1icmVcIiwgXCJkw6ljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImphbnYuXCIsIFwiZsOpdnIuXCIsIFwibWFyc1wiLCBcImF2ci5cIiwgXCJtYWlcIiwgXCJqdWluXCIsIFwianVpbC5cIiwgXCJhb8O7dFwiLCBcInNlcHQuXCIsIFwib2N0LlwiLCBcIm5vdi5cIiwgXCJkw6ljLlwiXVxuICB9O1xuXG4gIHZhciBmckNhID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICViICVZICVYXCIsXG4gICAgZGF0ZTogXCIlWS0lbS0lZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJcIiwgXCJcIl0sXG4gICAgZGF5czogW1wiZGltYW5jaGVcIiwgXCJsdW5kaVwiLCBcIm1hcmRpXCIsIFwibWVyY3JlZGlcIiwgXCJqZXVkaVwiLCBcInZlbmRyZWRpXCIsIFwic2FtZWRpXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGltXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWVyXCIsIFwiamV1XCIsIFwidmVuXCIsIFwic2FtXCJdLFxuICAgIG1vbnRoczogW1wiamFudmllclwiLCBcImbDqXZyaWVyXCIsIFwibWFyc1wiLCBcImF2cmlsXCIsIFwibWFpXCIsIFwianVpblwiLCBcImp1aWxsZXRcIiwgXCJhb8O7dFwiLCBcInNlcHRlbWJyZVwiLCBcIm9jdG9icmVcIiwgXCJub3ZlbWJyZVwiLCBcImTDqWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFuXCIsIFwiZsOpdlwiLCBcIm1hclwiLCBcImF2clwiLCBcIm1haVwiLCBcImp1aVwiLCBcImp1bFwiLCBcImFvw7tcIiwgXCJzZXBcIiwgXCJvY3RcIiwgXCJub3ZcIiwgXCJkw6ljXCJdXG4gIH07XG5cbiAgdmFyIGZpRmkgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICUtZC4gJUJ0YSAlWSBrbG8gJVhcIixcbiAgICBkYXRlOiBcIiUtZC4lLW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiYS5tLlwiLCBcInAubS5cIl0sXG4gICAgZGF5czogW1wic3VubnVudGFpXCIsIFwibWFhbmFudGFpXCIsIFwidGlpc3RhaVwiLCBcImtlc2tpdmlpa2tvXCIsIFwidG9yc3RhaVwiLCBcInBlcmphbnRhaVwiLCBcImxhdWFudGFpXCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VcIiwgXCJNYVwiLCBcIlRpXCIsIFwiS2VcIiwgXCJUb1wiLCBcIlBlXCIsIFwiTGFcIl0sXG4gICAgbW9udGhzOiBbXCJ0YW1taWt1dVwiLCBcImhlbG1pa3V1XCIsIFwibWFhbGlza3V1XCIsIFwiaHVodGlrdXVcIiwgXCJ0b3Vrb2t1dVwiLCBcImtlc8Oka3V1XCIsIFwiaGVpbsOka3V1XCIsIFwiZWxva3V1XCIsIFwic3l5c2t1dVwiLCBcImxva2FrdXVcIiwgXCJtYXJyYXNrdXVcIiwgXCJqb3VsdWt1dVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiVGFtbWlcIiwgXCJIZWxtaVwiLCBcIk1hYWxpc1wiLCBcIkh1aHRpXCIsIFwiVG91a29cIiwgXCJLZXPDpFwiLCBcIkhlaW7DpFwiLCBcIkVsb1wiLCBcIlN5eXNcIiwgXCJMb2thXCIsIFwiTWFycmFzXCIsIFwiSm91bHVcIl1cbiAgfTtcblxuICB2YXIgZXNFcyA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcImRvbWluZ29cIiwgXCJsdW5lc1wiLCBcIm1hcnRlc1wiLCBcIm1pw6lyY29sZXNcIiwgXCJqdWV2ZXNcIiwgXCJ2aWVybmVzXCIsIFwic8OhYmFkb1wiXSxcbiAgICBzaG9ydERheXM6IFtcImRvbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1pw6lcIiwgXCJqdWVcIiwgXCJ2aWVcIiwgXCJzw6FiXCJdLFxuICAgIG1vbnRoczogW1wiZW5lcm9cIiwgXCJmZWJyZXJvXCIsIFwibWFyem9cIiwgXCJhYnJpbFwiLCBcIm1heW9cIiwgXCJqdW5pb1wiLCBcImp1bGlvXCIsIFwiYWdvc3RvXCIsIFwic2VwdGllbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZpZW1icmVcIiwgXCJkaWNpZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImVuZVwiLCBcImZlYlwiLCBcIm1hclwiLCBcImFiclwiLCBcIm1heVwiLCBcImp1blwiLCBcImp1bFwiLCBcImFnb1wiLCBcInNlcFwiLCBcIm9jdFwiLCBcIm5vdlwiLCBcImRpY1wiXVxuICB9O1xuXG4gIHZhciBlblVzID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBlbkdiID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICViICVYICVZXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBlbkNhID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlWS0lbS0lZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBkZURlID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCBkZXIgJWUuICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQuJW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiU29ubnRhZ1wiLCBcIk1vbnRhZ1wiLCBcIkRpZW5zdGFnXCIsIFwiTWl0dHdvY2hcIiwgXCJEb25uZXJzdGFnXCIsIFwiRnJlaXRhZ1wiLCBcIlNhbXN0YWdcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTb1wiLCBcIk1vXCIsIFwiRGlcIiwgXCJNaVwiLCBcIkRvXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhclwiLCBcIkZlYnJ1YXJcIiwgXCJNw6RyelwiLCBcIkFwcmlsXCIsIFwiTWFpXCIsIFwiSnVuaVwiLCBcIkp1bGlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZXplbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTXJ6XCIsIFwiQXByXCIsIFwiTWFpXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2t0XCIsIFwiTm92XCIsIFwiRGV6XCJdXG4gIH07XG5cbiAgdmFyIGNhRXMgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlIGRlICVCIGRlICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJkaXVtZW5nZVwiLCBcImRpbGx1bnNcIiwgXCJkaW1hcnRzXCIsIFwiZGltZWNyZXNcIiwgXCJkaWpvdXNcIiwgXCJkaXZlbmRyZXNcIiwgXCJkaXNzYWJ0ZVwiXSxcbiAgICBzaG9ydERheXM6IFtcImRnLlwiLCBcImRsLlwiLCBcImR0LlwiLCBcImRjLlwiLCBcImRqLlwiLCBcImR2LlwiLCBcImRzLlwiXSxcbiAgICBtb250aHM6IFtcImdlbmVyXCIsIFwiZmVicmVyXCIsIFwibWFyw6dcIiwgXCJhYnJpbFwiLCBcIm1haWdcIiwgXCJqdW55XCIsIFwianVsaW9sXCIsIFwiYWdvc3RcIiwgXCJzZXRlbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZlbWJyZVwiLCBcImRlc2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJnZW4uXCIsIFwiZmVici5cIiwgXCJtYXLDp1wiLCBcImFici5cIiwgXCJtYWlnXCIsIFwianVueVwiLCBcImp1bC5cIiwgXCJhZy5cIiwgXCJzZXQuXCIsIFwib2N0LlwiLCBcIm5vdi5cIiwgXCJkZXMuXCJdXG4gIH07XG5cbiAgdmFyIHQwID0gbmV3IERhdGU7XG4gIHZhciB0MSA9IG5ldyBEYXRlO1xuXG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQpIHtcblxuICAgIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gICAgfVxuXG4gICAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICAgIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbmV3IERhdGUoK2RhdGUpLFxuICAgICAgICAgIGQxID0gbmV3IERhdGUoZGF0ZSAtIDEpO1xuICAgICAgZmxvb3JpKGQwKSwgZmxvb3JpKGQxKSwgb2Zmc2V0aShkMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0IC0gMSk7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0b3ApO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgICBvZmZzZXRpKHN0YXJ0LCAxKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICAgIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY291bnQpIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICB2YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG4gIHZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xuXG4gIHZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xuICB9KTtcblxuICB2YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbiAgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5cbiAgdmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gICAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3WWVhcih5KSB7XG4gICAgcmV0dXJuIHt5OiB5LCBtOiAwLCBkOiAxLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgICBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLFxuICAgICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgICAgbG9jYWxlX3Nob3J0V2Vla2RheXMgPSBsb2NhbGUuc2hvcnREYXlzLFxuICAgICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gICAgdmFyIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICAgIHdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIHNob3J0V2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydE1vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgXCJhXCI6IGZvcm1hdFNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgICBcIkJcIjogZm9ybWF0TW9udGgsXG4gICAgICBcImNcIjogbnVsbCxcbiAgICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgICBcIlVcIjogZm9ybWF0V2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogbnVsbCxcbiAgICAgIFwiWFwiOiBudWxsLFxuICAgICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgICBcIllcIjogZm9ybWF0RnVsbFllYXIsXG4gICAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcbiAgICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgICAgXCJjXCI6IG51bGwsXG4gICAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICAgIFwiSVwiOiBmb3JtYXRVVENIb3VyMTIsXG4gICAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBmb3JtYXRVVENNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxuICAgICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IG51bGwsXG4gICAgICBcIlhcIjogbnVsbCxcbiAgICAgIFwieVwiOiBmb3JtYXRVVENZZWFyLFxuICAgICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgICAgXCJaXCI6IGZvcm1hdFVUQ1pvbmUsXG4gICAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlcyA9IHtcbiAgICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgICBcImJcIjogcGFyc2VTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IHBhcnNlTW9udGgsXG4gICAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICAgIFwiZFwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJJXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgICAgXCJTXCI6IHBhcnNlU2Vjb25kcyxcbiAgICAgIFwiVVwiOiBwYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICAgIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gICAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gICAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBwYWQsXG4gICAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkID09IG51bGwgPyAoYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiKSA6IHBhZCk7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgbmV3RGF0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgZCA9IG5ld1llYXIoMTkwMCksXG4gICAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgICAvLyBJZiBhIHRpbWUgem9uZSBpcyBzcGVjaWZpZWQsIGFsbCBmaWVsZHMgYXJlIGludGVycHJldGVkIGFzIFVUQyBhbmQgdGhlblxuICAgICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgICB2YXIgZGF5ID0gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgaWYgKFwiV1wiIGluIGQpIGQuVSA9IGQuVywgZC53ID0gKGQudyArIDYpICUgNywgLS1kYXk7XG4gICAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgICAgZC5kID0gZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQuSCArPSBkLlogLyAxMDAgfCAwO1xuICAgICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgdmFyIGRheSA9IG5ld0RhdGUobmV3WWVhcihkLnkpKS5nZXREYXkoKTtcbiAgICAgICAgICBpZiAoXCJXXCIgaW4gZCkgZC5VID0gZC5XLCBkLncgPSAoZC53ICsgNikgJSA3LCAtLWRheTtcbiAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgIGQuZCA9IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRlKGQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFyc2U7XG5cbiAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gc2hvcnRXZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gd2Vla2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQubSA9IG1vbnRoTG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gcGVyaW9kTG9va3VwLmdldChzdHJpbmcuc2xpY2UoaSwgaSArPSAyKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBuID09IG51bGwgPyAtMSA6IChkLnAgPSBuLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgICBmLnBhcnNlID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCBsb2NhbERhdGUpO1xuICAgICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCB1dGNGb3JtYXRzKTtcbiAgICAgICAgZi5wYXJzZSA9IG5ld1BhcnNlKHNwZWNpZmllciwgdXRjRGF0ZSk7XG4gICAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBwYWRzID0ge1wiLVwiOiBcIlwiLCBcIl9cIjogXCIgXCIsIFwiMFwiOiBcIjBcIn07XG4gIHZhciBudW1iZXJSZSA9IC9eXFxzKlxcZCsvO1xuICB2YXIgcGVyY2VudFJlID0gL14lLztcbiAgdmFyIHJlcXVvdGVSZSA9IC9bXFxcXFxcXlxcJFxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxcLlxce1xcfV0vZztcblxuICBmdW5jdGlvbiBwYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVxdW90ZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UmUobmFtZXMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMb29rdXAobmFtZXMpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KG5hbWVzW2ldLnRvTG93ZXJDYXNlKCksIGkpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2Vab25lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiAvXlsrLV1cXGR7NH0kLy50ZXN0KHN0cmluZyA9IHN0cmluZy5zbGljZShpLCBpICsgNSkpXG4gICAgICAgID8gKGQuWiA9IC1zdHJpbmcsIGkgKyA1KSAvLyBzaWduIGRpZmZlcnMgZnJvbSBnZXRUaW1lem9uZU9mZnNldCFcbiAgICAgICAgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGhOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURheU9mWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSG91cjI0KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGQuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdERheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0SG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGF5T2ZZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKDEgKyBkYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TW9udGhOdW1iZXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNaW51dGVzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChzdW5kYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKG1vbmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRGdWxsWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRab25lKGQpIHtcbiAgICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgICArIHBhZCh6IC8gNjAgfCAwLCBcIjBcIiwgMilcbiAgICAgICAgKyBwYWQoeiAlIDYwLCBcIjBcIiwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENEYXlPZk1vbnRoKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIyNChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDSG91cjEyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCgxICsgdXRjRGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01pbnV0ZXMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDU2Vjb25kcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQodXRjU3VuZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXIoZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RheSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCh1dGNNb25kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcbiAgICByZXR1cm4gXCIrMDAwMFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TGl0ZXJhbFBlcmNlbnQoKSB7XG4gICAgcmV0dXJuIFwiJVwiO1xuICB9XG5cbiAgdmFyIGlzb1NwZWNpZmllciA9IFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCI7XG5cbiAgZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICB9XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xuICB9O1xuXG4gIGZvcm1hdElzb05hdGl2ZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc29TcGVjaWZpZXI7XG4gIH07XG5cbiAgdmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKVxuICAgICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICAgIDogZW5Vcy51dGNGb3JtYXQoaXNvU3BlY2lmaWVyKTtcblxuICB2YXIgaXNvRm9ybWF0ID0gZm9ybWF0SXNvO1xuXG4gIHZhciBsb2NhbGVEZWZpbml0aW9ucyA9IChuZXcgTWFwKVxuICAgICAgLnNldChcImNhLUVTXCIsIGNhRXMpXG4gICAgICAuc2V0KFwiZGUtREVcIiwgZGVEZSlcbiAgICAgIC5zZXQoXCJlbi1DQVwiLCBlbkNhKVxuICAgICAgLnNldChcImVuLUdCXCIsIGVuR2IpXG4gICAgICAuc2V0KFwiZW4tVVNcIiwgZW5VcylcbiAgICAgIC5zZXQoXCJlcy1FU1wiLCBlc0VzKVxuICAgICAgLnNldChcImZpLUZJXCIsIGZpRmkpXG4gICAgICAuc2V0KFwiZnItQ0FcIiwgZnJDYSlcbiAgICAgIC5zZXQoXCJmci1GUlwiLCBmckZyKVxuICAgICAgLnNldChcImhlLUlMXCIsIGhlSWwpXG4gICAgICAuc2V0KFwiaXQtSVRcIiwgaXRJdClcbiAgICAgIC5zZXQoXCJtay1NS1wiLCBta01rKVxuICAgICAgLnNldChcIm5sLU5MXCIsIG5sTmwpXG4gICAgICAuc2V0KFwicGwtUExcIiwgcGxQbClcbiAgICAgIC5zZXQoXCJwdC1CUlwiLCBwdEJyKVxuICAgICAgLnNldChcInJ1LVJVXCIsIHJ1UnUpXG4gICAgICAuc2V0KFwiemgtQ05cIiwgemhDbik7XG5cbiAgdmFyIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGUoZW5Vcyk7XG4gIGV4cG9ydHMuZm9ybWF0ID0gZGVmYXVsdExvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMudXRjRm9ybWF0ID0gZGVmYXVsdExvY2FsZS51dGNGb3JtYXQ7XG5cbiAgZnVuY3Rpb24gbG9jYWxlRm9ybWF0KGRlZmluaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRlZmluaXRpb24gPSBsb2NhbGVEZWZpbml0aW9ucy5nZXQoZGVmaW5pdGlvbik7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlKGRlZmluaXRpb24pO1xuICB9XG4gIDtcblxuICBleHBvcnRzLmxvY2FsZUZvcm1hdCA9IGxvY2FsZUZvcm1hdDtcbiAgZXhwb3J0cy5pc29Gb3JtYXQgPSBpc29Gb3JtYXQ7XG5cbn0pKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC5kc3YgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICAgIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5dXCIpLFxuICAgICAgICBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgICB2YXIgbztcbiAgICAgIHJldHVybiBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICAgIGlmIChvKSByZXR1cm4gbyhyb3csIGkgLSAxKTtcbiAgICAgICAgdmFyIGEgPSBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIHJvdy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiKTtcbiAgICAgICAgbyA9IGYgPyBmdW5jdGlvbihyb3csIGkpIHsgcmV0dXJuIGYoYShyb3cpLCBpKTsgfSA6IGE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgICAgdmFyIEVPTCA9IHt9LCAvLyBzZW50aW5lbCB2YWx1ZSBmb3IgZW5kLW9mLWxpbmVcbiAgICAgICAgICBFT0YgPSB7fSwgLy8gc2VudGluZWwgdmFsdWUgZm9yIGVuZC1vZi1maWxlXG4gICAgICAgICAgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgICBuID0gMCwgLy8gdGhlIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgICB0LCAvLyB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgIGVvbDsgLy8gaXMgdGhlIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgICAgaWYgKEkgPj0gTikgcmV0dXJuIEVPRjsgLy8gc3BlY2lhbCBjYXNlOiBlbmQgb2YgZmlsZVxuICAgICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDsgLy8gc3BlY2lhbCBjYXNlOiBlbmQgb2YgbGluZVxuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogcXVvdGVzXG4gICAgICAgIHZhciBqID0gSTtcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gMzQpIHtcbiAgICAgICAgICB2YXIgaSA9IGo7XG4gICAgICAgICAgd2hpbGUgKGkrKyA8IE4pIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IDM0KSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpICE9PSAzNCkgYnJlYWs7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgSSA9IGkgKyAyO1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAyKSA9PT0gMTApICsrSTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDEwKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tb24gY2FzZTogZmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lXG4gICAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICAgIHZhciBjID0gdGV4dC5jaGFyQ29kZUF0KEkrKyksIGsgPSAxO1xuICAgICAgICAgIGlmIChjID09PSAxMCkgZW9sID0gdHJ1ZTsgLy8gXFxuXG4gICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMTMpIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gMTApICsrSSwgKytrOyB9IC8vIFxccnxcXHJcXG5cbiAgICAgICAgICBlbHNlIGlmIChjICE9PSBkZWxpbWl0ZXJDb2RlKSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBJIC0gayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IGxhc3QgdG9rZW4gYmVmb3JlIEVPRlxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikge1xuICAgICAgICAgIGEucHVzaCh0KTtcbiAgICAgICAgICB0ID0gdG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiAmJiAoYSA9IGYoYSwgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIHJvd3MucHVzaChhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHJvd3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvd3NbMF0pKSByZXR1cm4gZm9ybWF0Um93cyhyb3dzKTsgLy8gZGVwcmVjYXRlZDsgdXNlIGZvcm1hdFJvd3NcbiAgICAgIHZhciBmaWVsZFNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksIGZpZWxkcyA9IFtdO1xuXG4gICAgICAvLyBDb21wdXRlIHVuaXF1ZSBmaWVsZHMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiByb3cpIHtcbiAgICAgICAgICBpZiAoISgoZmllbGQgKz0gXCJcIikgaW4gZmllbGRTZXQpKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZFNldFtmaWVsZF0gPSBmaWVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFtmaWVsZHMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2ZpZWxkXSk7XG4gICAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICAgIH0pKS5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHRleHQpIHtcbiAgICAgIHJldHVybiByZUZvcm1hdC50ZXN0KHRleHQpID8gXCJcXFwiXCIgKyB0ZXh0LnJlcGxhY2UoL1xcXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiIDogdGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3NcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0cy5jc3YgPSBkc3YoXCIsXCIpO1xuICBleHBvcnRzLnRzdiA9IGRzdihcIlxcdFwiKTtcblxuICBleHBvcnRzLmRzdiA9IGRzdjtcblxufSkpOyIsImlmICh0eXBlb2YgTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIE1hcCA9IGZ1bmN0aW9uKCkgeyB0aGlzLmNsZWFyKCk7IH07XG4gIE1hcC5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihrLCB2KSB7IHRoaXMuX1trXSA9IHY7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldDogZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5fW2tdOyB9LFxuICAgIGhhczogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl87IH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbihrKSB7IHJldHVybiBrIGluIHRoaXMuXyAmJiBkZWxldGUgdGhpcy5fW2tdOyB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHsgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfSxcbiAgICBnZXQgc2l6ZSgpIHsgdmFyIG4gPSAwOyBmb3IgKHZhciBrIGluIHRoaXMuXykgKytuOyByZXR1cm4gbjsgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjKSB7IGZvciAodmFyIGsgaW4gdGhpcy5fKSBjKHRoaXMuX1trXSwgaywgdGhpcyk7IH1cbiAgfTtcbn0gZWxzZSAoZnVuY3Rpb24oKSB7XG4gIHZhciBtID0gbmV3IE1hcDtcbiAgaWYgKG0uc2V0KDAsIDApICE9PSBtKSB7XG4gICAgbSA9IG0uc2V0O1xuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7IG0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIHRoaXM7IH07XG4gIH1cbn0pKCk7XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLnRpbWVGb3JtYXQgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHpoQ24gPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVZLyUtbS8lLWRcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wi5LiK5Y2IXCIsIFwi5LiL5Y2IXCJdLFxuICAgIGRheXM6IFtcIuaYn+acn+aXpVwiLCBcIuaYn+acn+S4gFwiLCBcIuaYn+acn+S6jFwiLCBcIuaYn+acn+S4iVwiLCBcIuaYn+acn+Wbm1wiLCBcIuaYn+acn+S6lFwiLCBcIuaYn+acn+WFrVwiXSxcbiAgICBzaG9ydERheXM6IFtcIuaYn+acn+aXpVwiLCBcIuaYn+acn+S4gFwiLCBcIuaYn+acn+S6jFwiLCBcIuaYn+acn+S4iVwiLCBcIuaYn+acn+Wbm1wiLCBcIuaYn+acn+S6lFwiLCBcIuaYn+acn+WFrVwiXSxcbiAgICBtb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi5LiA5pyIXCIsIFwi5LqM5pyIXCIsIFwi5LiJ5pyIXCIsIFwi5Zub5pyIXCIsIFwi5LqU5pyIXCIsIFwi5YWt5pyIXCIsIFwi5LiD5pyIXCIsIFwi5YWr5pyIXCIsIFwi5Lmd5pyIXCIsIFwi5Y2B5pyIXCIsIFwi5Y2B5LiA5pyIXCIsIFwi5Y2B5LqM5pyIXCJdXG4gIH07XG5cbiAgdmFyIHJ1UnUgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlICVCICVZINCzLiAlWFwiLFxuICAgIGRhdGU6IFwiJWQuJW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCLQstC+0YHQutGA0LXRgdC10L3RjNC1XCIsIFwi0L/QvtC90LXQtNC10LvRjNC90LjQulwiLCBcItCy0YLQvtGA0L3QuNC6XCIsIFwi0YHRgNC10LTQsFwiLCBcItGH0LXRgtCy0LXRgNCzXCIsIFwi0L/Rj9GC0L3QuNGG0LBcIiwgXCLRgdGD0LHQsdC+0YLQsFwiXSxcbiAgICBzaG9ydERheXM6IFtcItCy0YFcIiwgXCLQv9C9XCIsIFwi0LLRglwiLCBcItGB0YBcIiwgXCLRh9GCXCIsIFwi0L/RglwiLCBcItGB0LFcIl0sXG4gICAgbW9udGhzOiBbXCLRj9C90LLQsNGA0Y9cIiwgXCLRhNC10LLRgNCw0LvRj1wiLCBcItC80LDRgNGC0LBcIiwgXCLQsNC/0YDQtdC70Y9cIiwgXCLQvNCw0Y9cIiwgXCLQuNGO0L3Rj1wiLCBcItC40Y7Qu9GPXCIsIFwi0LDQstCz0YPRgdGC0LBcIiwgXCLRgdC10L3RgtGP0LHRgNGPXCIsIFwi0L7QutGC0Y/QsdGA0Y9cIiwgXCLQvdC+0Y/QsdGA0Y9cIiwgXCLQtNC10LrQsNCx0YDRj1wiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi0Y/QvdCyXCIsIFwi0YTQtdCyXCIsIFwi0LzQsNGAXCIsIFwi0LDQv9GAXCIsIFwi0LzQsNC5XCIsIFwi0LjRjtC9XCIsIFwi0LjRjtC7XCIsIFwi0LDQstCzXCIsIFwi0YHQtdC9XCIsIFwi0L7QutGCXCIsIFwi0L3QvtGPXCIsIFwi0LTQtdC6XCJdXG4gIH07XG5cbiAgdmFyIHB0QnIgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlIGRlICVCIGRlICVZLiAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJEb21pbmdvXCIsIFwiU2VndW5kYVwiLCBcIlRlcsOnYVwiLCBcIlF1YXJ0YVwiLCBcIlF1aW50YVwiLCBcIlNleHRhXCIsIFwiU8OhYmFkb1wiXSxcbiAgICBzaG9ydERheXM6IFtcIkRvbVwiLCBcIlNlZ1wiLCBcIlRlclwiLCBcIlF1YVwiLCBcIlF1aVwiLCBcIlNleFwiLCBcIlPDoWJcIl0sXG4gICAgbW9udGhzOiBbXCJKYW5laXJvXCIsIFwiRmV2ZXJlaXJvXCIsIFwiTWFyw6dvXCIsIFwiQWJyaWxcIiwgXCJNYWlvXCIsIFwiSnVuaG9cIiwgXCJKdWxob1wiLCBcIkFnb3N0b1wiLCBcIlNldGVtYnJvXCIsIFwiT3V0dWJyb1wiLCBcIk5vdmVtYnJvXCIsIFwiRGV6ZW1icm9cIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZldlwiLCBcIk1hclwiLCBcIkFiclwiLCBcIk1haVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkFnb1wiLCBcIlNldFwiLCBcIk91dFwiLCBcIk5vdlwiLCBcIkRlelwiXVxuICB9O1xuXG4gIHZhciBwbFBsID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcIk5pZWR6aWVsYVwiLCBcIlBvbmllZHppYcWCZWtcIiwgXCJXdG9yZWtcIiwgXCLFmnJvZGFcIiwgXCJDendhcnRla1wiLCBcIlBpxIV0ZWtcIiwgXCJTb2JvdGFcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJOaWVkei5cIiwgXCJQb24uXCIsIFwiV3QuXCIsIFwixZpyLlwiLCBcIkN6dy5cIiwgXCJQdC5cIiwgXCJTb2IuXCJdLFxuICAgIG1vbnRoczogW1wiU3R5Y3plxYRcIiwgXCJMdXR5XCIsIFwiTWFyemVjXCIsIFwiS3dpZWNpZcWEXCIsIFwiTWFqXCIsIFwiQ3plcndpZWNcIiwgXCJMaXBpZWNcIiwgXCJTaWVycGllxYRcIiwgXCJXcnplc2llxYRcIiwgXCJQYcW6ZHppZXJuaWtcIiwgXCJMaXN0b3BhZFwiLCBcIkdydWR6aWXFhFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiU3R5Y3ouXCIsIFwiTHV0eVwiLCBcIk1hcnouXCIsIFwiS3dpZS5cIiwgXCJNYWpcIiwgXCJDemVydy5cIiwgXCJMaXBjLlwiLCBcIlNpZXJwLlwiLCBcIldyei5cIiwgXCJQYcW6ZHouXCIsIFwiTGlzdG9wLlwiLCBcIkdydWR6LlwiXS8qIEluIFBvbGlzaCBsYW5ndWFnZSBhYmJyYXZpYXRlZCBtb250aHMgYXJlIG5vdCBjb21tb25seSB1c2VkIHNvIHRoZXJlIGlzIGEgZGlzcHV0ZSBhYm91dCB0aGUgcHJvcGVyIGFiYnJhdmlhdGlvbnMuICovXG4gIH07XG5cbiAgdmFyIG5sTmwgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWUgJUIgJVkgJVRcIixcbiAgICBkYXRlOiBcIiVkLSVtLSVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcInpvbmRhZ1wiLCBcIm1hYW5kYWdcIiwgXCJkaW5zZGFnXCIsIFwid29lbnNkYWdcIiwgXCJkb25kZXJkYWdcIiwgXCJ2cmlqZGFnXCIsIFwiemF0ZXJkYWdcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJ6b1wiLCBcIm1hXCIsIFwiZGlcIiwgXCJ3b1wiLCBcImRvXCIsIFwidnJcIiwgXCJ6YVwiXSxcbiAgICBtb250aHM6IFtcImphbnVhcmlcIiwgXCJmZWJydWFyaVwiLCBcIm1hYXJ0XCIsIFwiYXByaWxcIiwgXCJtZWlcIiwgXCJqdW5pXCIsIFwianVsaVwiLCBcImF1Z3VzdHVzXCIsIFwic2VwdGVtYmVyXCIsIFwib2t0b2JlclwiLCBcIm5vdmVtYmVyXCIsIFwiZGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImphblwiLCBcImZlYlwiLCBcIm1ydFwiLCBcImFwclwiLCBcIm1laVwiLCBcImp1blwiLCBcImp1bFwiLCBcImF1Z1wiLCBcInNlcFwiLCBcIm9rdFwiLCBcIm5vdlwiLCBcImRlY1wiXVxuICB9O1xuXG4gIHZhciBta01rID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSDQsy4gJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi0L3QtdC00LXQu9CwXCIsIFwi0L/QvtC90LXQtNC10LvQvdC40LpcIiwgXCLQstGC0L7RgNC90LjQulwiLCBcItGB0YDQtdC00LBcIiwgXCLRh9C10YLQstGA0YLQvtC6XCIsIFwi0L/QtdGC0L7QulwiLCBcItGB0LDQsdC+0YLQsFwiXSxcbiAgICBzaG9ydERheXM6IFtcItC90LXQtFwiLCBcItC/0L7QvVwiLCBcItCy0YLQvlwiLCBcItGB0YDQtVwiLCBcItGH0LXRglwiLCBcItC/0LXRglwiLCBcItGB0LDQsVwiXSxcbiAgICBtb250aHM6IFtcItGY0LDQvdGD0LDRgNC4XCIsIFwi0YTQtdCy0YDRg9Cw0YDQuFwiLCBcItC80LDRgNGCXCIsIFwi0LDQv9GA0LjQu1wiLCBcItC80LDRmFwiLCBcItGY0YPQvdC4XCIsIFwi0ZjRg9C70LhcIiwgXCLQsNCy0LPRg9GB0YJcIiwgXCLRgdC10L/RgtC10LzQstGA0LhcIiwgXCLQvtC60YLQvtC80LLRgNC4XCIsIFwi0L3QvtC10LzQstGA0LhcIiwgXCLQtNC10LrQtdC80LLRgNC4XCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCLRmNCw0L1cIiwgXCLRhNC10LJcIiwgXCLQvNCw0YBcIiwgXCLQsNC/0YBcIiwgXCLQvNCw0ZhcIiwgXCLRmNGD0L1cIiwgXCLRmNGD0LtcIiwgXCLQsNCy0LNcIiwgXCLRgdC10L9cIiwgXCLQvtC60YJcIiwgXCLQvdC+0LVcIiwgXCLQtNC10LpcIl1cbiAgfTtcblxuICB2YXIgamFKcCA9IHtcbiAgICBkYXRlVGltZTogXCIlWSAlYiAlZSAlYSAlWFwiLFxuICAgIGRhdGU6IFwiJVkvJW0vJWRcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCLml6Xmm5zml6VcIiwgXCLmnIjmm5zml6VcIiwgXCLngavmm5zml6VcIiwgXCLmsLTmm5zml6VcIiwgXCLmnKjmm5zml6VcIiwgXCLph5Hmm5zml6VcIiwgXCLlnJ/mm5zml6VcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLml6VcIiwgXCLmnIhcIiwgXCLngatcIiwgXCLmsLRcIiwgXCLmnKhcIiwgXCLph5FcIiwgXCLlnJ9cIl0sXG4gICAgbW9udGhzOiBbXCLnnabmnIhcIiwgXCLlpoLmnIhcIiwgXCLlvKXnlJ9cIiwgXCLlja/mnIhcIiwgXCLnmpDmnIhcIiwgXCLmsLTnhKHmnIhcIiwgXCLmlofmnIhcIiwgXCLokYnmnIhcIiwgXCLplbfmnIhcIiwgXCLnpZ7nhKHmnIhcIiwgXCLpnJzmnIhcIiwgXCLluKvotbBcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIjHmnIhcIiwgXCIy5pyIXCIsIFwiM+aciFwiLCBcIjTmnIhcIiwgXCI15pyIXCIsIFwiNuaciFwiLCBcIjfmnIhcIiwgXCI45pyIXCIsIFwiOeaciFwiLCBcIjEw5pyIXCIsIFwiMTHmnIhcIiwgXCIxMuaciFwiXVxuICB9O1xuXG4gIHZhciBpdEl0ID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiRG9tZW5pY2FcIiwgXCJMdW5lZMOsXCIsIFwiTWFydGVkw6xcIiwgXCJNZXJjb2xlZMOsXCIsIFwiR2lvdmVkw6xcIiwgXCJWZW5lcmTDrFwiLCBcIlNhYmF0b1wiXSxcbiAgICBzaG9ydERheXM6IFtcIkRvbVwiLCBcIkx1blwiLCBcIk1hclwiLCBcIk1lclwiLCBcIkdpb1wiLCBcIlZlblwiLCBcIlNhYlwiXSxcbiAgICBtb250aHM6IFtcIkdlbm5haW9cIiwgXCJGZWJicmFpb1wiLCBcIk1hcnpvXCIsIFwiQXByaWxlXCIsIFwiTWFnZ2lvXCIsIFwiR2l1Z25vXCIsIFwiTHVnbGlvXCIsIFwiQWdvc3RvXCIsIFwiU2V0dGVtYnJlXCIsIFwiT3R0b2JyZVwiLCBcIk5vdmVtYnJlXCIsIFwiRGljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkdlblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1hZ1wiLCBcIkdpdVwiLCBcIkx1Z1wiLCBcIkFnb1wiLCBcIlNldFwiLCBcIk90dFwiLCBcIk5vdlwiLCBcIkRpY1wiXVxuICB9O1xuXG4gIHZhciBoZUlsID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSDXkSVCICVZICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIteo15DXqdeV159cIiwgXCLXqdeg15lcIiwgXCLXqdec15nXqdeZXCIsIFwi16jXkdeZ16LXmVwiLCBcIteX157Xmdep15lcIiwgXCLXqdeZ16nXmVwiLCBcItep15HXqlwiXSxcbiAgICBzaG9ydERheXM6IFtcIteQ17NcIiwgXCLXkdezXCIsIFwi15LXs1wiLCBcIteT17NcIiwgXCLXlNezXCIsIFwi15XXs1wiLCBcItep17NcIl0sXG4gICAgbW9udGhzOiBbXCLXmdeg15XXkNeoXCIsIFwi16TXkdeo15XXkNeoXCIsIFwi157XqNelXCIsIFwi15DXpNeo15nXnFwiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXldeh15hcIiwgXCLXodek15jXnteR16hcIiwgXCLXkNeV16fXmNeV15HXqFwiLCBcIteg15XXkdee15HXqFwiLCBcIteT16bXnteR16hcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIteZ16DXldezXCIsIFwi16TXkdeo17NcIiwgXCLXnteo16VcIiwgXCLXkNek16jXs1wiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXs1wiLCBcIteh16TXmNezXCIsIFwi15DXlden17NcIiwgXCLXoNeV15HXs1wiLCBcIteT16bXntezXCJdXG4gIH07XG5cbiAgdmFyIGZyRnIgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsIGxlICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiZGltYW5jaGVcIiwgXCJsdW5kaVwiLCBcIm1hcmRpXCIsIFwibWVyY3JlZGlcIiwgXCJqZXVkaVwiLCBcInZlbmRyZWRpXCIsIFwic2FtZWRpXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGltLlwiLCBcImx1bi5cIiwgXCJtYXIuXCIsIFwibWVyLlwiLCBcImpldS5cIiwgXCJ2ZW4uXCIsIFwic2FtLlwiXSxcbiAgICBtb250aHM6IFtcImphbnZpZXJcIiwgXCJmw6l2cmllclwiLCBcIm1hcnNcIiwgXCJhdnJpbFwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsbGV0XCIsIFwiYW/Du3RcIiwgXCJzZXB0ZW1icmVcIiwgXCJvY3RvYnJlXCIsIFwibm92ZW1icmVcIiwgXCJkw6ljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImphbnYuXCIsIFwiZsOpdnIuXCIsIFwibWFyc1wiLCBcImF2ci5cIiwgXCJtYWlcIiwgXCJqdWluXCIsIFwianVpbC5cIiwgXCJhb8O7dFwiLCBcInNlcHQuXCIsIFwib2N0LlwiLCBcIm5vdi5cIiwgXCJkw6ljLlwiXVxuICB9O1xuXG4gIHZhciBmckNhID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICViICVZICVYXCIsXG4gICAgZGF0ZTogXCIlWS0lbS0lZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJcIiwgXCJcIl0sXG4gICAgZGF5czogW1wiZGltYW5jaGVcIiwgXCJsdW5kaVwiLCBcIm1hcmRpXCIsIFwibWVyY3JlZGlcIiwgXCJqZXVkaVwiLCBcInZlbmRyZWRpXCIsIFwic2FtZWRpXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGltXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWVyXCIsIFwiamV1XCIsIFwidmVuXCIsIFwic2FtXCJdLFxuICAgIG1vbnRoczogW1wiamFudmllclwiLCBcImbDqXZyaWVyXCIsIFwibWFyc1wiLCBcImF2cmlsXCIsIFwibWFpXCIsIFwianVpblwiLCBcImp1aWxsZXRcIiwgXCJhb8O7dFwiLCBcInNlcHRlbWJyZVwiLCBcIm9jdG9icmVcIiwgXCJub3ZlbWJyZVwiLCBcImTDqWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFuXCIsIFwiZsOpdlwiLCBcIm1hclwiLCBcImF2clwiLCBcIm1haVwiLCBcImp1aVwiLCBcImp1bFwiLCBcImFvw7tcIiwgXCJzZXBcIiwgXCJvY3RcIiwgXCJub3ZcIiwgXCJkw6ljXCJdXG4gIH07XG5cbiAgdmFyIGZpRmkgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICUtZC4gJUJ0YSAlWSBrbG8gJVhcIixcbiAgICBkYXRlOiBcIiUtZC4lLW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiYS5tLlwiLCBcInAubS5cIl0sXG4gICAgZGF5czogW1wic3VubnVudGFpXCIsIFwibWFhbmFudGFpXCIsIFwidGlpc3RhaVwiLCBcImtlc2tpdmlpa2tvXCIsIFwidG9yc3RhaVwiLCBcInBlcmphbnRhaVwiLCBcImxhdWFudGFpXCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VcIiwgXCJNYVwiLCBcIlRpXCIsIFwiS2VcIiwgXCJUb1wiLCBcIlBlXCIsIFwiTGFcIl0sXG4gICAgbW9udGhzOiBbXCJ0YW1taWt1dVwiLCBcImhlbG1pa3V1XCIsIFwibWFhbGlza3V1XCIsIFwiaHVodGlrdXVcIiwgXCJ0b3Vrb2t1dVwiLCBcImtlc8Oka3V1XCIsIFwiaGVpbsOka3V1XCIsIFwiZWxva3V1XCIsIFwic3l5c2t1dVwiLCBcImxva2FrdXVcIiwgXCJtYXJyYXNrdXVcIiwgXCJqb3VsdWt1dVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiVGFtbWlcIiwgXCJIZWxtaVwiLCBcIk1hYWxpc1wiLCBcIkh1aHRpXCIsIFwiVG91a29cIiwgXCJLZXPDpFwiLCBcIkhlaW7DpFwiLCBcIkVsb1wiLCBcIlN5eXNcIiwgXCJMb2thXCIsIFwiTWFycmFzXCIsIFwiSm91bHVcIl1cbiAgfTtcblxuICB2YXIgZXNFcyA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcImRvbWluZ29cIiwgXCJsdW5lc1wiLCBcIm1hcnRlc1wiLCBcIm1pw6lyY29sZXNcIiwgXCJqdWV2ZXNcIiwgXCJ2aWVybmVzXCIsIFwic8OhYmFkb1wiXSxcbiAgICBzaG9ydERheXM6IFtcImRvbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1pw6lcIiwgXCJqdWVcIiwgXCJ2aWVcIiwgXCJzw6FiXCJdLFxuICAgIG1vbnRoczogW1wiZW5lcm9cIiwgXCJmZWJyZXJvXCIsIFwibWFyem9cIiwgXCJhYnJpbFwiLCBcIm1heW9cIiwgXCJqdW5pb1wiLCBcImp1bGlvXCIsIFwiYWdvc3RvXCIsIFwic2VwdGllbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZpZW1icmVcIiwgXCJkaWNpZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImVuZVwiLCBcImZlYlwiLCBcIm1hclwiLCBcImFiclwiLCBcIm1heVwiLCBcImp1blwiLCBcImp1bFwiLCBcImFnb1wiLCBcInNlcFwiLCBcIm9jdFwiLCBcIm5vdlwiLCBcImRpY1wiXVxuICB9O1xuXG4gIHZhciBlblVzID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBlbkdiID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICViICVYICVZXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBlbkNhID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlWS0lbS0lZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9O1xuXG4gIHZhciBkZURlID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCBkZXIgJWUuICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQuJW0uJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiU29ubnRhZ1wiLCBcIk1vbnRhZ1wiLCBcIkRpZW5zdGFnXCIsIFwiTWl0dHdvY2hcIiwgXCJEb25uZXJzdGFnXCIsIFwiRnJlaXRhZ1wiLCBcIlNhbXN0YWdcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTb1wiLCBcIk1vXCIsIFwiRGlcIiwgXCJNaVwiLCBcIkRvXCIsIFwiRnJcIiwgXCJTYVwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhclwiLCBcIkZlYnJ1YXJcIiwgXCJNw6RyelwiLCBcIkFwcmlsXCIsIFwiTWFpXCIsIFwiSnVuaVwiLCBcIkp1bGlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZXplbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTXJ6XCIsIFwiQXByXCIsIFwiTWFpXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2t0XCIsIFwiTm92XCIsIFwiRGV6XCJdXG4gIH07XG5cbiAgdmFyIGNhRXMgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlIGRlICVCIGRlICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJkaXVtZW5nZVwiLCBcImRpbGx1bnNcIiwgXCJkaW1hcnRzXCIsIFwiZGltZWNyZXNcIiwgXCJkaWpvdXNcIiwgXCJkaXZlbmRyZXNcIiwgXCJkaXNzYWJ0ZVwiXSxcbiAgICBzaG9ydERheXM6IFtcImRnLlwiLCBcImRsLlwiLCBcImR0LlwiLCBcImRjLlwiLCBcImRqLlwiLCBcImR2LlwiLCBcImRzLlwiXSxcbiAgICBtb250aHM6IFtcImdlbmVyXCIsIFwiZmVicmVyXCIsIFwibWFyw6dcIiwgXCJhYnJpbFwiLCBcIm1haWdcIiwgXCJqdW55XCIsIFwianVsaW9sXCIsIFwiYWdvc3RcIiwgXCJzZXRlbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZlbWJyZVwiLCBcImRlc2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJnZW4uXCIsIFwiZmVici5cIiwgXCJtYXLDp1wiLCBcImFici5cIiwgXCJtYWlnXCIsIFwianVueVwiLCBcImp1bC5cIiwgXCJhZy5cIiwgXCJzZXQuXCIsIFwib2N0LlwiLCBcIm5vdi5cIiwgXCJkZXMuXCJdXG4gIH07XG5cbiAgdmFyIHQwID0gbmV3IERhdGU7XG4gIHZhciB0MSA9IG5ldyBEYXRlO1xuXG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQpIHtcblxuICAgIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gICAgfVxuXG4gICAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICAgIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbmV3IERhdGUoK2RhdGUpLFxuICAgICAgICAgIGQxID0gbmV3IERhdGUoZGF0ZSAtIDEpO1xuICAgICAgZmxvb3JpKGQwKSwgZmxvb3JpKGQxKSwgb2Zmc2V0aShkMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0IC0gMSk7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0b3ApO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgICBvZmZzZXRpKHN0YXJ0LCAxKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICAgIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY291bnQpIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICB2YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG4gIHZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xuXG4gIHZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xuICB9KTtcblxuICB2YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbiAgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5cbiAgdmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gICAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3WWVhcih5KSB7XG4gICAgcmV0dXJuIHt5OiB5LCBtOiAwLCBkOiAxLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgICBsb2NhbGVfdGltZSA9IGxvY2FsZS50aW1lLFxuICAgICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgICAgbG9jYWxlX3Nob3J0V2Vla2RheXMgPSBsb2NhbGUuc2hvcnREYXlzLFxuICAgICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gICAgdmFyIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICAgIHdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIHNob3J0V2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydE1vbnRocyksXG4gICAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgXCJhXCI6IGZvcm1hdFNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgICBcIkJcIjogZm9ybWF0TW9udGgsXG4gICAgICBcImNcIjogbnVsbCxcbiAgICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgICBcIlVcIjogZm9ybWF0V2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogbnVsbCxcbiAgICAgIFwiWFwiOiBudWxsLFxuICAgICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgICBcIllcIjogZm9ybWF0RnVsbFllYXIsXG4gICAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogZm9ybWF0VVRDV2Vla2RheSxcbiAgICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgICAgXCJjXCI6IG51bGwsXG4gICAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICAgIFwiSVwiOiBmb3JtYXRVVENIb3VyMTIsXG4gICAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBmb3JtYXRVVENNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxuICAgICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IG51bGwsXG4gICAgICBcIlhcIjogbnVsbCxcbiAgICAgIFwieVwiOiBmb3JtYXRVVENZZWFyLFxuICAgICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgICAgXCJaXCI6IGZvcm1hdFVUQ1pvbmUsXG4gICAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlcyA9IHtcbiAgICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgICBcImJcIjogcGFyc2VTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IHBhcnNlTW9udGgsXG4gICAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICAgIFwiZFwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJJXCI6IHBhcnNlSG91cjI0LFxuICAgICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IHBhcnNlTWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgICAgXCJwXCI6IHBhcnNlUGVyaW9kLFxuICAgICAgXCJTXCI6IHBhcnNlU2Vjb25kcyxcbiAgICAgIFwiVVwiOiBwYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IHBhcnNlV2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgXCJ5XCI6IHBhcnNlWWVhcixcbiAgICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBwYXJzZUxpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgICBmb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIGZvcm1hdHMpO1xuICAgIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gICAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCB1dGNGb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gICAgZnVuY3Rpb24gbmV3Rm9ybWF0KHNwZWNpZmllciwgZm9ybWF0cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBwYWQsXG4gICAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9IGZvcm1hdHNbY10pIGMgPSBmb3JtYXQoZGF0ZSwgcGFkID09IG51bGwgPyAoYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiKSA6IHBhZCk7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgbmV3RGF0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB2YXIgZCA9IG5ld1llYXIoMTkwMCksXG4gICAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgICAvLyBJZiBhIHRpbWUgem9uZSBpcyBzcGVjaWZpZWQsIGFsbCBmaWVsZHMgYXJlIGludGVycHJldGVkIGFzIFVUQyBhbmQgdGhlblxuICAgICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgICB2YXIgZGF5ID0gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgaWYgKFwiV1wiIGluIGQpIGQuVSA9IGQuVywgZC53ID0gKGQudyArIDYpICUgNywgLS1kYXk7XG4gICAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgICAgZC5kID0gZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQuSCArPSBkLlogLyAxMDAgfCAwO1xuICAgICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICAgIGlmIChcIndcIiBpbiBkICYmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpKSB7XG4gICAgICAgICAgdmFyIGRheSA9IG5ld0RhdGUobmV3WWVhcihkLnkpKS5nZXREYXkoKTtcbiAgICAgICAgICBpZiAoXCJXXCIgaW4gZCkgZC5VID0gZC5XLCBkLncgPSAoZC53ICsgNikgJSA3LCAtLWRheTtcbiAgICAgICAgICBkLm0gPSAwO1xuICAgICAgICAgIGQuZCA9IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRlKGQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgcGFyc2U7XG5cbiAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gajtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gc2hvcnRXZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gd2Vla2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQubSA9IG1vbnRoTG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gcGVyaW9kTG9va3VwLmdldChzdHJpbmcuc2xpY2UoaSwgaSArPSAyKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBuID09IG51bGwgPyAtMSA6IChkLnAgPSBuLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgICBmLnBhcnNlID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCBsb2NhbERhdGUpO1xuICAgICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCB1dGNGb3JtYXRzKTtcbiAgICAgICAgZi5wYXJzZSA9IG5ld1BhcnNlKHNwZWNpZmllciwgdXRjRGF0ZSk7XG4gICAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBwYWRzID0ge1wiLVwiOiBcIlwiLCBcIl9cIjogXCIgXCIsIFwiMFwiOiBcIjBcIn07XG4gIHZhciBudW1iZXJSZSA9IC9eXFxzKlxcZCsvO1xuICB2YXIgcGVyY2VudFJlID0gL14lLztcbiAgdmFyIHJlcXVvdGVSZSA9IC9bXFxcXFxcXlxcJFxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxcLlxce1xcfV0vZztcblxuICBmdW5jdGlvbiBwYWQodmFsdWUsIGZpbGwsIHdpZHRoKSB7XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVxdW90ZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UmUobmFtZXMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMb29rdXAobmFtZXMpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KG5hbWVzW2ldLnRvTG93ZXJDYXNlKCksIGkpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2Vab25lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiAvXlsrLV1cXGR7NH0kLy50ZXN0KHN0cmluZyA9IHN0cmluZy5zbGljZShpLCBpICsgNSkpXG4gICAgICAgID8gKGQuWiA9IC1zdHJpbmcsIGkgKyA1KSAvLyBzaWduIGRpZmZlcnMgZnJvbSBnZXRUaW1lem9uZU9mZnNldCFcbiAgICAgICAgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGhOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURheU9mWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSG91cjI0KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGQuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdERheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0SG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGF5T2ZZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKDEgKyBkYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TW9udGhOdW1iZXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNaW51dGVzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChzdW5kYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKG1vbmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRGdWxsWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRab25lKGQpIHtcbiAgICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgICArIHBhZCh6IC8gNjAgfCAwLCBcIjBcIiwgMilcbiAgICAgICAgKyBwYWQoeiAlIDYwLCBcIjBcIiwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENEYXlPZk1vbnRoKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIyNChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDSG91cjEyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCgxICsgdXRjRGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoTnVtYmVyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTWludXRlcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01pbnV0ZXMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDU2Vjb25kcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQodXRjU3VuZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXIoZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RheSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCh1dGNNb25kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcbiAgICByZXR1cm4gXCIrMDAwMFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TGl0ZXJhbFBlcmNlbnQoKSB7XG4gICAgcmV0dXJuIFwiJVwiO1xuICB9XG5cbiAgdmFyIGlzb1NwZWNpZmllciA9IFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCI7XG5cbiAgZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICB9XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xuICB9O1xuXG4gIGZvcm1hdElzb05hdGl2ZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc29TcGVjaWZpZXI7XG4gIH07XG5cbiAgdmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKVxuICAgICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICAgIDogZW5Vcy51dGNGb3JtYXQoaXNvU3BlY2lmaWVyKTtcblxuICB2YXIgaXNvRm9ybWF0ID0gZm9ybWF0SXNvO1xuXG4gIHZhciBsb2NhbGVEZWZpbml0aW9ucyA9IChuZXcgTWFwKVxuICAgICAgLnNldChcImNhLUVTXCIsIGNhRXMpXG4gICAgICAuc2V0KFwiZGUtREVcIiwgZGVEZSlcbiAgICAgIC5zZXQoXCJlbi1DQVwiLCBlbkNhKVxuICAgICAgLnNldChcImVuLUdCXCIsIGVuR2IpXG4gICAgICAuc2V0KFwiZW4tVVNcIiwgZW5VcylcbiAgICAgIC5zZXQoXCJlcy1FU1wiLCBlc0VzKVxuICAgICAgLnNldChcImZpLUZJXCIsIGZpRmkpXG4gICAgICAuc2V0KFwiZnItQ0FcIiwgZnJDYSlcbiAgICAgIC5zZXQoXCJmci1GUlwiLCBmckZyKVxuICAgICAgLnNldChcImhlLUlMXCIsIGhlSWwpXG4gICAgICAuc2V0KFwiaXQtSVRcIiwgaXRJdClcbiAgICAgIC5zZXQoXCJqYS1KUFwiLCBqYUpwKVxuICAgICAgLnNldChcIm1rLU1LXCIsIG1rTWspXG4gICAgICAuc2V0KFwibmwtTkxcIiwgbmxObClcbiAgICAgIC5zZXQoXCJwbC1QTFwiLCBwbFBsKVxuICAgICAgLnNldChcInB0LUJSXCIsIHB0QnIpXG4gICAgICAuc2V0KFwicnUtUlVcIiwgcnVSdSlcbiAgICAgIC5zZXQoXCJ6aC1DTlwiLCB6aENuKTtcblxuICB2YXIgZGVmYXVsdExvY2FsZSA9IGxvY2FsZShlblVzKTtcbiAgZXhwb3J0cy5mb3JtYXQgPSBkZWZhdWx0TG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBkZWZhdWx0TG9jYWxlLnV0Y0Zvcm1hdDtcblxuICBmdW5jdGlvbiBsb2NhbGVGb3JtYXQoZGVmaW5pdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVmaW5pdGlvbiA9IGxvY2FsZURlZmluaXRpb25zLmdldChkZWZpbml0aW9uKTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGUoZGVmaW5pdGlvbik7XG4gIH1cbiAgO1xuXG4gIGV4cG9ydHMubG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0O1xuICBleHBvcnRzLmlzb0Zvcm1hdCA9IGlzb0Zvcm1hdDtcblxufSkpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLnRpbWUgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHQxID0gbmV3IERhdGU7XG5cbiAgdmFyIHQwID0gbmV3IERhdGU7XG5cbiAgZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCkge1xuXG4gICAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgICB9XG5cbiAgICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gICAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBuZXcgRGF0ZSgrZGF0ZSksXG4gICAgICAgICAgZDEgPSBuZXcgRGF0ZShkYXRlIC0gMSk7XG4gICAgICBmbG9vcmkoZDApLCBmbG9vcmkoZDEpLCBvZmZzZXRpKGQxLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHN0YXJ0ID0gbmV3IERhdGUoc3RhcnQgLSAxKTtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZSgrc3RvcCk7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICAgIG9mZnNldGkoc3RhcnQsIDEpLCBmbG9vcmkoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHdoaWxlIChvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KSwgc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgICAgd2hpbGUgKC0tc3RlcCA+PSAwKSB3aGlsZSAob2Zmc2V0aShkYXRlLCAxKSwgIXRlc3QoZGF0ZSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjb3VudCkgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIHZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9KTtcblxuICBleHBvcnRzLnNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cbiAgdmFyIG1pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFNlY29uZHMoMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNmU0O1xuICB9KTtcblxuICBleHBvcnRzLm1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG5cbiAgdmFyIGhvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRNaW51dGVzKDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAzNmU1O1xuICB9KTtcblxuICBleHBvcnRzLmhvdXJzID0gaG91ci5yYW5nZTtcblxuICB2YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy5kYXlzID0gZGF5LnJhbmdlO1xuXG4gIGZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuc3VuZGF5ID0gd2Vla2RheSgwKTtcblxuICBleHBvcnRzLnN1bmRheXMgPSBleHBvcnRzLnN1bmRheS5yYW5nZTtcblxuICBleHBvcnRzLm1vbmRheSA9IHdlZWtkYXkoMSk7XG5cbiAgZXhwb3J0cy5tb25kYXlzID0gZXhwb3J0cy5tb25kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy50dWVzZGF5ID0gd2Vla2RheSgyKTtcblxuICBleHBvcnRzLnR1ZXNkYXlzID0gZXhwb3J0cy50dWVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMud2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcblxuICBleHBvcnRzLndlZG5lc2RheXMgPSBleHBvcnRzLndlZG5lc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnRodXJzZGF5ID0gd2Vla2RheSg0KTtcblxuICBleHBvcnRzLnRodXJzZGF5cyA9IGV4cG9ydHMudGh1cnNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy5mcmlkYXkgPSB3ZWVrZGF5KDUpO1xuXG4gIGV4cG9ydHMuZnJpZGF5cyA9IGV4cG9ydHMuZnJpZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMuc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG4gIGV4cG9ydHMuc2F0dXJkYXlzID0gZXhwb3J0cy5zYXR1cmRheS5yYW5nZTtcblxuICB2YXIgd2VlayA9IGV4cG9ydHMuc3VuZGF5O1xuXG4gIGV4cG9ydHMud2Vla3MgPSB3ZWVrLnJhbmdlO1xuXG4gIHZhciBtb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldE1vbnRoKCkgLSBzdGFydC5nZXRNb250aCgpICsgKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbiAgfSk7XG5cbiAgZXhwb3J0cy5tb250aHMgPSBtb250aC5yYW5nZTtcblxuICB2YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZXhwb3J0cy55ZWFycyA9IHllYXIucmFuZ2U7XG5cbiAgdmFyIHV0Y1NlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ01pbGxpc2Vjb25kcygwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAxZTM7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjU2Vjb25kcyA9IHV0Y1NlY29uZC5yYW5nZTtcblxuICB2YXIgdXRjTWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2ZTQ7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcblxuICB2YXIgdXRjSG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDM2ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjSG91cnMgPSB1dGNIb3VyLnJhbmdlO1xuXG4gIHZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG5cbiAgZXhwb3J0cy51dGNTdW5kYXlzID0gZXhwb3J0cy51dGNTdW5kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xuXG4gIGV4cG9ydHMudXRjTW9uZGF5cyA9IGV4cG9ydHMudXRjTW9uZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG5cbiAgZXhwb3J0cy51dGNUdWVzZGF5cyA9IGV4cG9ydHMudXRjVHVlc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG5cbiAgZXhwb3J0cy51dGNXZWRuZXNkYXlzID0gZXhwb3J0cy51dGNXZWRuZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG5cbiAgZXhwb3J0cy51dGNUaHVyc2RheXMgPSBleHBvcnRzLnV0Y1RodXJzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcblxuICBleHBvcnRzLnV0Y0ZyaWRheXMgPSBleHBvcnRzLnV0Y0ZyaWRheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxuICBleHBvcnRzLnV0Y1NhdHVyZGF5cyA9IGV4cG9ydHMudXRjU2F0dXJkYXkucmFuZ2U7XG5cbiAgdmFyIHV0Y1dlZWsgPSBleHBvcnRzLnV0Y1N1bmRheTtcblxuICBleHBvcnRzLnV0Y1dlZWtzID0gdXRjV2Vlay5yYW5nZTtcblxuICB2YXIgdXRjTW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ0RhdGUoMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cbiAgdmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuXG4gIGV4cG9ydHMuaW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcbiAgZXhwb3J0cy5zZWNvbmQgPSBzZWNvbmQ7XG4gIGV4cG9ydHMubWludXRlID0gbWludXRlO1xuICBleHBvcnRzLmhvdXIgPSBob3VyO1xuICBleHBvcnRzLmRheSA9IGRheTtcbiAgZXhwb3J0cy53ZWVrID0gd2VlaztcbiAgZXhwb3J0cy5tb250aCA9IG1vbnRoO1xuICBleHBvcnRzLnllYXIgPSB5ZWFyO1xuICBleHBvcnRzLnV0Y1NlY29uZCA9IHV0Y1NlY29uZDtcbiAgZXhwb3J0cy51dGNNaW51dGUgPSB1dGNNaW51dGU7XG4gIGV4cG9ydHMudXRjSG91ciA9IHV0Y0hvdXI7XG4gIGV4cG9ydHMudXRjRGF5ID0gdXRjRGF5O1xuICBleHBvcnRzLnV0Y1dlZWsgPSB1dGNXZWVrO1xuICBleHBvcnRzLnV0Y01vbnRoID0gdXRjTW9udGg7XG4gIGV4cG9ydHMudXRjWWVhciA9IHV0Y1llYXI7XG5cbn0pKTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICBNZWFzdXJlcyA9IHJlcXVpcmUoJy4vbWVhc3VyZXMnKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL2NvbGxlY3RvcicpO1xuXG5mdW5jdGlvbiBBZ2dyZWdhdG9yKCkge1xuICB0aGlzLl9jZWxscyA9IHt9O1xuICB0aGlzLl9hZ2dyID0gW107XG4gIHRoaXMuX3N0cmVhbSA9IGZhbHNlO1xufVxuXG52YXIgRmxhZ3MgPSBBZ2dyZWdhdG9yLkZsYWdzID0ge1xuICBBRERfQ0VMTDogMSxcbiAgTU9EX0NFTEw6IDJcbn07XG5cbnZhciBwcm90byA9IEFnZ3JlZ2F0b3IucHJvdG90eXBlO1xuXG4vLyBQYXJhbWV0ZXJzXG5cbnByb3RvLnN0cmVhbSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3N0cmVhbTtcbiAgdGhpcy5fc3RyZWFtID0gISF2O1xuICB0aGlzLl9hZ2dyID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8ga2V5IGFjY2Vzc29yIHRvIHVzZSBmb3Igc3RyZWFtaW5nIHJlbW92ZXNcbnByb3RvLmtleSA9IGZ1bmN0aW9uKGtleSkge1xuICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzLl9rZXk7XG4gIHRoaXMuX2tleSA9IHV0aWwuJChrZXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIElucHV0OiBhcnJheSBvZiBvYmplY3RzIG9mIHRoZSBmb3JtXG4vLyB7bmFtZTogc3RyaW5nLCBnZXQ6IGZ1bmN0aW9ufVxucHJvdG8uZ3JvdXBieSA9IGZ1bmN0aW9uKGRpbXMpIHtcbiAgdGhpcy5fZGltcyA9IHV0aWwuYXJyYXkoZGltcykubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICBkID0gdXRpbC5pc1N0cmluZyhkKSA/IHtuYW1lOiBkLCBnZXQ6IHV0aWwuJChkKX1cbiAgICAgIDogdXRpbC5pc0Z1bmN0aW9uKGQpID8ge25hbWU6IHV0aWwubmFtZShkKSB8fCBkLm5hbWUgfHwgKCdfJyArIGkpLCBnZXQ6IGR9XG4gICAgICA6IChkLm5hbWUgJiYgdXRpbC5pc0Z1bmN0aW9uKGQuZ2V0KSkgPyBkIDogbnVsbDtcbiAgICBpZiAoZCA9PSBudWxsKSB0aHJvdyAnSW52YWxpZCBncm91cGJ5IGFyZ3VtZW50OiAnICsgZDtcbiAgICByZXR1cm4gZDtcbiAgfSk7XG4gIHJldHVybiB0aGlzLmNsZWFyKCk7XG59O1xuXG4vLyBJbnB1dDogYXJyYXkgb2Ygb2JqZWN0cyBvZiB0aGUgZm9ybVxuLy8ge25hbWU6IHN0cmluZywgb3BzOiBbc3RyaW5nLCAuLi5dfVxucHJvdG8uc3VtbWFyaXplID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gIGZpZWxkcyA9IHN1bW1hcml6ZV9hcmdzKGZpZWxkcyk7XG4gIHRoaXMuX2NvdW50ID0gdHJ1ZTtcbiAgdmFyIGFnZ3IgPSAodGhpcy5fYWdnciA9IFtdKSxcbiAgICAgIG0sIGYsIGksIGosIG9wLCBhcywgZ2V0O1xuXG4gIGZvciAoaT0wOyBpPGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgIGZvciAoaj0wLCBtPVtdLCBmPWZpZWxkc1tpXTsgajxmLm9wcy5sZW5ndGg7ICsraikge1xuICAgICAgb3AgPSBmLm9wc1tqXTtcbiAgICAgIGlmIChvcCAhPT0gJ2NvdW50JykgdGhpcy5fY291bnQgPSBmYWxzZTtcbiAgICAgIGFzID0gKGYuYXMgJiYgZi5hc1tqXSkgfHwgKG9wICsgKGYubmFtZT09PScqJyA/ICcnIDogJ18nK2YubmFtZSkpO1xuICAgICAgbS5wdXNoKE1lYXN1cmVzW29wXShhcykpO1xuICAgIH1cbiAgICBnZXQgPSBmLmdldCAmJiB1dGlsLiQoZi5nZXQpIHx8XG4gICAgICAoZi5uYW1lID09PSAnKicgPyB1dGlsLmlkZW50aXR5IDogdXRpbC4kKGYubmFtZSkpO1xuICAgIGFnZ3IucHVzaCh7XG4gICAgICBuYW1lOiBmLm5hbWUsXG4gICAgICBtZWFzdXJlczogTWVhc3VyZXMuY3JlYXRlKFxuICAgICAgICBtLFxuICAgICAgICB0aGlzLl9zdHJlYW0sIC8vIHN0cmVhbWluZyByZW1vdmUgZmxhZ1xuICAgICAgICBnZXQsICAgICAgICAgIC8vIGlucHV0IHR1cGxlIGdldHRlclxuICAgICAgICB0aGlzLl9hc3NpZ24pIC8vIG91dHB1dCB0dXBsZSBzZXR0ZXJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5jbGVhcigpO1xufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHN1bW1hcml6ZSBieSBjb3VudFxucHJvdG8uY291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3VtbWFyaXplKHsnKic6J2NvdW50J30pO1xufTtcblxuLy8gT3ZlcnJpZGUgdG8gcGVyZm9ybSBjdXN0b20gdHVwbGUgdmFsdWUgYXNzaWdubWVudFxucHJvdG8uX2Fzc2lnbiA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgb2JqZWN0W25hbWVdID0gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBzdW1tYXJpemVfYXJncyhmaWVsZHMpIHtcbiAgaWYgKHV0aWwuaXNBcnJheShmaWVsZHMpKSB7IHJldHVybiBmaWVsZHM7IH1cbiAgaWYgKGZpZWxkcyA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuICB2YXIgYSA9IFtdLCBuYW1lLCBvcHM7XG4gIGZvciAobmFtZSBpbiBmaWVsZHMpIHtcbiAgICBvcHMgPSB1dGlsLmFycmF5KGZpZWxkc1tuYW1lXSk7XG4gICAgYS5wdXNoKHtuYW1lOiBuYW1lLCBvcHM6IG9wc30pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vLyBDZWxsIE1hbmFnZW1lbnRcblxucHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9jZWxscyA9IHt9LCB0aGlzKTtcbn07XG5cbnByb3RvLl9jZWxsa2V5ID0gZnVuY3Rpb24oeCkge1xuICB2YXIgZCA9IHRoaXMuX2RpbXMsXG4gICAgICBuID0gZC5sZW5ndGgsIGksXG4gICAgICBrID0gU3RyaW5nKGRbMF0uZ2V0KHgpKTtcbiAgZm9yIChpPTE7IGk8bjsgKytpKSB7XG4gICAgayArPSAnfCcgKyBkW2ldLmdldCh4KTtcbiAgfVxuICByZXR1cm4gaztcbn07XG5cbnByb3RvLl9jZWxsID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5ID0gdGhpcy5fZGltcy5sZW5ndGggPyB0aGlzLl9jZWxsa2V5KHgpIDogJyc7XG4gIHJldHVybiB0aGlzLl9jZWxsc1trZXldIHx8ICh0aGlzLl9jZWxsc1trZXldID0gdGhpcy5fbmV3Y2VsbCh4LCBrZXkpKTtcbn07XG5cbnByb3RvLl9uZXdjZWxsID0gZnVuY3Rpb24oeCwga2V5KSB7XG4gIHZhciBjZWxsID0ge1xuICAgIG51bTogICAwLFxuICAgIHR1cGxlOiB0aGlzLl9uZXd0dXBsZSh4LCBrZXkpLFxuICAgIGZsYWc6ICBGbGFncy5BRERfQ0VMTCxcbiAgICBhZ2dzOiAge31cbiAgfTtcblxuICB2YXIgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG4gIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXSA9IG5ldyBhZ2dyW2ldLm1lYXN1cmVzKGNlbGwsIGNlbGwudHVwbGUpO1xuICB9XG4gIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICBjZWxsLmRhdGEgPSBuZXcgQ29sbGVjdG9yKHRoaXMuX2tleSk7XG4gIH1cbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fbmV3dHVwbGUgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgIHQgPSB7fSwgaSwgbjtcbiAgZm9yIChpPTAsIG49ZGltcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdFtkaW1zW2ldLm5hbWVdID0gZGltc1tpXS5nZXQoeCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2luZ2VzdCh0KTtcbn07XG5cbi8vIE92ZXJyaWRlIHRvIHBlcmZvcm0gY3VzdG9tIHR1cGxlIGluZ2VzdGlvblxucHJvdG8uX2luZ2VzdCA9IHV0aWwuaWRlbnRpdHk7XG5cbi8vIFByb2Nlc3MgVHVwbGVzXG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuXG4gIGNlbGwubnVtICs9IDE7XG4gIGlmICghdGhpcy5fY291bnQpIHsgLy8gc2tpcCBpZiBjb3VudC1vbmx5XG4gICAgaWYgKGNlbGwuY29sbGVjdCkgY2VsbC5kYXRhLmFkZCh4KTtcbiAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXS5hZGQoeCk7XG4gICAgfVxuICB9XG4gIGNlbGwuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbiAgaWYgKHRoaXMuX29uX2FkZCkgdGhpcy5fb25fYWRkKHgsIGNlbGwpO1xufTtcblxucHJvdG8uX3JlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsKHgpLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG5cbiAgY2VsbC5udW0gLT0gMTtcbiAgaWYgKCF0aGlzLl9jb3VudCkgeyAvLyBza2lwIGlmIGNvdW50LW9ubHlcbiAgICBpZiAoY2VsbC5jb2xsZWN0KSBjZWxsLmRhdGEucmVtKHgpO1xuICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnJlbSh4KTtcbiAgICB9XG4gIH1cbiAgY2VsbC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBpZiAodGhpcy5fb25fcmVtKSB0aGlzLl9vbl9yZW0oeCwgY2VsbCk7XG59O1xuXG5wcm90by5fbW9kID0gZnVuY3Rpb24oY3VyciwgcHJldikge1xuICB2YXIgY2VsbDAgPSB0aGlzLl9jZWxsKHByZXYpLFxuICAgICAgY2VsbDEgPSB0aGlzLl9jZWxsKGN1cnIpLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG5cbiAgaWYgKGNlbGwwICE9PSBjZWxsMSkge1xuICAgIGNlbGwwLm51bSAtPSAxO1xuICAgIGNlbGwxLm51bSArPSAxO1xuICAgIGlmIChjZWxsMC5jb2xsZWN0KSBjZWxsMC5kYXRhLnJlbShwcmV2KTtcbiAgICBpZiAoY2VsbDEuY29sbGVjdCkgY2VsbDEuZGF0YS5hZGQoY3Vycik7XG4gIH0gZWxzZSBpZiAoY2VsbDAuY29sbGVjdCAmJiAhdXRpbC5pc09iamVjdChjdXJyKSkge1xuICAgIGNlbGwwLmRhdGEucmVtKHByZXYpO1xuICAgIGNlbGwwLmRhdGEuYWRkKGN1cnIpO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgIGNlbGwwLmFnZ3NbYWdncltpXS5uYW1lXS5yZW0ocHJldik7XG4gICAgY2VsbDEuYWdnc1thZ2dyW2ldLm5hbWVdLmFkZChjdXJyKTtcbiAgfVxuICBjZWxsMC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBjZWxsMS5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBpZiAodGhpcy5fb25fbW9kKSB0aGlzLl9vbl9tb2QoY3VyciwgcHJldiwgY2VsbDAsIGNlbGwxKTtcbn07XG5cbnByb3RvLnJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBhZ2dyID0gdGhpcy5fYWdncixcbiAgICAgIGNlbGwsIGksIGs7XG5cbiAgZm9yIChrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgY2VsbCA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmIChjZWxsLm51bSA+IDApIHtcbiAgICAgIC8vIGNvbnNvbGlkYXRlIGNvbGxlY3RvciB2YWx1ZXNcbiAgICAgIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICAgICAgY2VsbC5kYXRhLnZhbHVlcygpO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIHR1cGxlIHByb3BlcnRpZXNcbiAgICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uc2V0KCk7XG4gICAgICB9XG4gICAgICAvLyBhZGQgb3V0cHV0IHR1cGxlXG4gICAgICByZXN1bHQucHVzaChjZWxsLnR1cGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuX2NlbGxzW2tdO1xuICAgIH1cbiAgICBjZWxsLmZsYWcgPSAwO1xuICB9XG5cbiAgdGhpcy5fcmVtcyA9IGZhbHNlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxucHJvdG8uY2hhbmdlcyA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICB2YXIgY2hhbmdlcyA9IG91dHB1dCB8fCB7YWRkOltdLCByZW06W10sIG1vZDpbXX0sXG4gICAgICBhZ2dyID0gdGhpcy5fYWdncixcbiAgICAgIGNlbGwsIGZsYWcsIGksIGs7XG5cbiAgZm9yIChrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgY2VsbCA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGZsYWcgPSBjZWxsLmZsYWc7XG5cbiAgICAvLyBjb25zb2xpZGF0ZSBjb2xsZWN0b3IgdmFsdWVzXG4gICAgaWYgKGNlbGwuY29sbGVjdCkge1xuICAgICAgY2VsbC5kYXRhLnZhbHVlcygpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uc2V0KCk7XG4gICAgfVxuXG4gICAgLy8gb3JnYW5pemUgb3V0cHV0IHR1cGxlc1xuICAgIGlmIChjZWxsLm51bSA8PSAwKSB7XG4gICAgICBjaGFuZ2VzLnJlbS5wdXNoKGNlbGwudHVwbGUpOyAvLyBpZiAoZmxhZyA9PT0gRmxhZ3MuTU9EX0NFTEwpIHsgPz9cbiAgICAgIGRlbGV0ZSB0aGlzLl9jZWxsc1trXTtcbiAgICAgIGlmICh0aGlzLl9vbl9kcm9wKSB0aGlzLl9vbl9kcm9wKGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fb25fa2VlcCkgdGhpcy5fb25fa2VlcChjZWxsKTtcbiAgICAgIGlmIChmbGFnICYgRmxhZ3MuQUREX0NFTEwpIHtcbiAgICAgICAgY2hhbmdlcy5hZGQucHVzaChjZWxsLnR1cGxlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZyAmIEZsYWdzLk1PRF9DRUxMKSB7XG4gICAgICAgIGNoYW5nZXMubW9kLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2VsbC5mbGFnID0gMDtcbiAgfVxuXG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5wcm90by5leGVjdXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMuY2xlYXIoKS5pbnNlcnQoaW5wdXQpLnJlc3VsdCgpO1xufTtcblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdGhpcy5fY29uc29saWRhdGUoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fYWRkKGlucHV0W2ldKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmICghdGhpcy5fc3RyZWFtKSB7XG4gICAgdGhyb3cgJ0FnZ3JlZ2F0b3Igbm90IGNvbmZpZ3VyZWQgZm9yIHN0cmVhbWluZyByZW1vdmVzLicgK1xuICAgICAgJyBDYWxsIHN0cmVhbSh0cnVlKSBwcmlvciB0byBjYWxsaW5nIHN1bW1hcml6ZS4nO1xuICB9XG4gIGZvciAodmFyIGk9MDsgaTxpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX3JlbShpbnB1dFtpXSk7XG4gIH1cbiAgdGhpcy5fcmVtcyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gY29uc29saWRhdGUgcmVtb3ZhbHNcbnByb3RvLl9jb25zb2xpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbXMpIHJldHVybjtcbiAgZm9yICh2YXIgayBpbiB0aGlzLl9jZWxscykge1xuICAgIGlmICh0aGlzLl9jZWxsc1trXS5jb2xsZWN0KSB7XG4gICAgICB0aGlzLl9jZWxsc1trXS5kYXRhLnZhbHVlcygpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3I7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xuXG52YXIgUkVNID0gJ19fZGxfcmVtX18nO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3Ioa2V5KSB7XG4gIHRoaXMuX2FkZCA9IFtdO1xuICB0aGlzLl9yZW0gPSBbXTtcbiAgdGhpcy5fa2V5ID0ga2V5IHx8IG51bGw7XG4gIHRoaXMuX2xhc3QgPSBudWxsO1xufVxuXG52YXIgcHJvdG8gPSBDb2xsZWN0b3IucHJvdG90eXBlO1xuXG5wcm90by5hZGQgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuX2FkZC5wdXNoKHYpO1xufTtcblxucHJvdG8ucmVtID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9yZW0ucHVzaCh2KTtcbn07XG5cbnByb3RvLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9nZXQgPSBudWxsO1xuICBpZiAodGhpcy5fcmVtLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2FkZDtcblxuICB2YXIgYSA9IHRoaXMuX2FkZCxcbiAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICBrID0gdGhpcy5fa2V5LFxuICAgICAgeCA9IEFycmF5KGEubGVuZ3RoIC0gci5sZW5ndGgpLFxuICAgICAgaSwgaiwgbiwgbTtcblxuICBpZiAoIXV0aWwuaXNPYmplY3QoclswXSkpIHtcbiAgICAvLyBwcm9jZXNzaW5nIHJhdyB2YWx1ZXNcbiAgICBtID0gc3RhdHMuY291bnQubWFwKHIpO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAobVthW2ldXSA+IDApIHtcbiAgICAgICAgbVthW2ldXSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFtqKytdID0gYVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaykge1xuICAgIC8vIGhhcyB1bmlxdWUga2V5IGZpZWxkLCBzbyB1c2UgdGhhdFxuICAgIG0gPSB1dGlsLnRvTWFwKHIsIGspO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoayhhW2ldKSkpIHsgeFtqKytdID0gYVtpXTsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBubyB1bmlxdWUga2V5LCBtYXJrIHR1cGxlcyBkaXJlY3RseVxuICAgIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgcltpXVtSRU1dID0gMTtcbiAgICB9XG4gICAgZm9yIChpPTAsIGo9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmICghYVtpXVtSRU1dKSB7IHhbaisrXSA9IGFbaV07IH1cbiAgICB9XG4gICAgZm9yIChpPTAsIG49ci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBkZWxldGUgcltpXVtSRU1dO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbSA9IFtdO1xuICByZXR1cm4gKHRoaXMuX2FkZCA9IHgpO1xufTtcblxuLy8gbWVtb2l6aW5nIHN0YXRpc3RpY3MgbWV0aG9kc1xuXG5wcm90by5leHRlbnQgPSBmdW5jdGlvbihnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICB2YXIgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIGkgPSBzdGF0cy5leHRlbnQuaW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0OyAgICBcbiAgfVxuICByZXR1cm4gdGhpcy5fZXh0O1xufTtcblxucHJvdG8uYXJnbWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzBdO1xufTtcblxucHJvdG8uYXJnbWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzFdO1xufTtcblxucHJvdG8ubWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVswXTtcbiAgcmV0dXJuIG0gPyBnZXQobSkgOiArSW5maW5pdHk7XG59O1xuXG5wcm90by5tYXggPSBmdW5jdGlvbihnZXQpIHtcbiAgdmFyIG0gPSB0aGlzLmV4dGVudChnZXQpWzFdO1xuICByZXR1cm4gbSA/IGdldChtKSA6IC1JbmZpbml0eTtcbn07XG5cbnByb3RvLnF1YXJ0aWxlID0gZnVuY3Rpb24oZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fcSkge1xuICAgIHRoaXMuX3EgPSBzdGF0cy5xdWFydGlsZSh0aGlzLnZhbHVlcygpLCBnZXQpO1xuICAgIHRoaXMuX2dldCA9IGdldDsgICAgXG4gIH1cbiAgcmV0dXJuIHRoaXMuX3E7XG59O1xuXG5wcm90by5xMSA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzBdO1xufTtcblxucHJvdG8ucTIgPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsxXTtcbn07XG5cbnByb3RvLnEzID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMl07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3RvcjtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIEFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gZmxhdHRlbiBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheVxuICB2YXIgYXJncyA9IFtdLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgeCkge1xuICAgIHJldHVybiBhLmNvbmNhdCh1dGlsLmFycmF5KHgpKTtcbiAgfSwgW10pO1xuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhbiBhZ2dyZWdhdG9yXG4gIHJldHVybiBuZXcgQWdncmVnYXRvcigpXG4gICAgLmdyb3VwYnkoYXJncylcbiAgICAuc3VtbWFyaXplKHsnKic6J3ZhbHVlcyd9KTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIHR5cGVzID0ge1xuICAndmFsdWVzJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbHVlcycsXG4gICAgaW5pdDogJ2NlbGwuY29sbGVjdCA9IHRydWU7JyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnZhbHVlcygpJywgaWR4OiAtMVxuICB9KSxcbiAgJ2NvdW50JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2NvdW50JyxcbiAgICBzZXQ6ICAnY2VsbC5udW0nXG4gIH0pLFxuICAnbWlzc2luZyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaXNzaW5nJyxcbiAgICBzZXQ6ICAndGhpcy5taXNzaW5nJ1xuICB9KSxcbiAgJ3ZhbGlkJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbGlkJyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCdcbiAgfSksXG4gICdzdW0nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3VtJyxcbiAgICBpbml0OiAndGhpcy5zdW0gPSAwOycsXG4gICAgYWRkOiAgJ3RoaXMuc3VtICs9IHY7JyxcbiAgICByZW06ICAndGhpcy5zdW0gLT0gdjsnLFxuICAgIHNldDogICd0aGlzLnN1bSdcbiAgfSksXG4gICdtZWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lYW4nLFxuICAgIGluaXQ6ICd0aGlzLm1lYW4gPSAwOycsXG4gICAgYWRkOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuICs9IGQgLyB0aGlzLnZhbGlkOycsXG4gICAgcmVtOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuIC09IHRoaXMudmFsaWQgPyBkIC8gdGhpcy52YWxpZCA6IHRoaXMubWVhbjsnLFxuICAgIHNldDogICd0aGlzLm1lYW4nXG4gIH0pLFxuICAnYXZlcmFnZSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhdmVyYWdlJyxcbiAgICBzZXQ6ICAndGhpcy5tZWFuJyxcbiAgICByZXE6ICBbJ21lYW4nXSwgaWR4OiAxXG4gIH0pLFxuICAndmFyaWFuY2UnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFyaWFuY2UnLFxuICAgIGluaXQ6ICd0aGlzLmRldiA9IDA7JyxcbiAgICBhZGQ6ICAndGhpcy5kZXYgKz0gZCAqICh2IC0gdGhpcy5tZWFuKTsnLFxuICAgIHJlbTogICd0aGlzLmRldiAtPSBkICogKHYgLSB0aGlzLm1lYW4pOycsXG4gICAgc2V0OiAgJ3RoaXMudmFsaWQgPiAxID8gdGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKSA6IDAnLFxuICAgIHJlcTogIFsnbWVhbiddLCBpZHg6IDFcbiAgfSksXG4gICd2YXJpYW5jZXAnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFyaWFuY2VwJyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCA+IDEgPyB0aGlzLmRldiAvIHRoaXMudmFsaWQgOiAwJyxcbiAgICByZXE6ICBbJ3ZhcmlhbmNlJ10sIGlkeDogMlxuICB9KSxcbiAgJ3N0ZGV2JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3N0ZGV2JyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCA+IDEgPyBNYXRoLnNxcnQodGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKSkgOiAwJyxcbiAgICByZXE6ICBbJ3ZhcmlhbmNlJ10sIGlkeDogMlxuICB9KSxcbiAgJ3N0ZGV2cCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdGRldnAnLFxuICAgIHNldDogICd0aGlzLnZhbGlkID4gMSA/IE1hdGguc3FydCh0aGlzLmRldiAvIHRoaXMudmFsaWQpIDogMCcsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdtZWRpYW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWVkaWFuJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnEyKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAncTEnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAncTEnLFxuICAgIHNldDogICdjZWxsLmRhdGEucTEodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdxMyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdxMycsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMyh0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2Rpc3RpbmN0JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2Rpc3RpbmN0JyxcbiAgICBzZXQ6ICAndGhpcy5kaXN0aW5jdChjZWxsLmRhdGEudmFsdWVzKCksIHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnYXJnbWluJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2FyZ21pbicsXG4gICAgYWRkOiAgJ2lmICh2IDwgdGhpcy5taW4pIHRoaXMuYXJnbWluID0gdDsnLFxuICAgIHJlbTogICdpZiAodiA8PSB0aGlzLm1pbikgdGhpcy5hcmdtaW4gPSBudWxsOycsXG4gICAgc2V0OiAgJ3RoaXMuYXJnbWluID0gdGhpcy5hcmdtaW4gfHwgY2VsbC5kYXRhLmFyZ21pbih0aGlzLmdldCknLFxuICAgIHJlcTogIFsnbWluJ10sIHN0cjogWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnYXJnbWF4JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2FyZ21heCcsXG4gICAgYWRkOiAgJ2lmICh2ID4gdGhpcy5tYXgpIHRoaXMuYXJnbWF4ID0gdDsnLFxuICAgIHJlbTogICdpZiAodiA+PSB0aGlzLm1heCkgdGhpcy5hcmdtYXggPSBudWxsOycsXG4gICAgc2V0OiAgJ3RoaXMuYXJnbWF4ID0gdGhpcy5hcmdtYXggfHwgY2VsbC5kYXRhLmFyZ21heCh0aGlzLmdldCknLFxuICAgIHJlcTogIFsnbWF4J10sIHN0cjogWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnbWluJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21pbicsXG4gICAgaW5pdDogJ3RoaXMubWluID0gK0luZmluaXR5OycsXG4gICAgYWRkOiAgJ2lmICh2IDwgdGhpcy5taW4pIHRoaXMubWluID0gdjsnLFxuICAgIHJlbTogICdpZiAodiA8PSB0aGlzLm1pbikgdGhpcy5taW4gPSBOYU47JyxcbiAgICBzZXQ6ICAndGhpcy5taW4gPSAoaXNOYU4odGhpcy5taW4pID8gY2VsbC5kYXRhLm1pbih0aGlzLmdldCkgOiB0aGlzLm1pbiknLFxuICAgIHN0cjogIFsndmFsdWVzJ10sIGlkeDogNFxuICB9KSxcbiAgJ21heCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtYXgnLFxuICAgIGluaXQ6ICd0aGlzLm1heCA9IC1JbmZpbml0eTsnLFxuICAgIGFkZDogICdpZiAodiA+IHRoaXMubWF4KSB0aGlzLm1heCA9IHY7JyxcbiAgICByZW06ICAnaWYgKHYgPj0gdGhpcy5tYXgpIHRoaXMubWF4ID0gTmFOOycsXG4gICAgc2V0OiAgJ3RoaXMubWF4ID0gKGlzTmFOKHRoaXMubWF4KSA/IGNlbGwuZGF0YS5tYXgodGhpcy5nZXQpIDogdGhpcy5tYXgpJyxcbiAgICBzdHI6ICBbJ3ZhbHVlcyddLCBpZHg6IDRcbiAgfSksXG4gICdtb2Rlc2tldyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtb2Rlc2tldycsXG4gICAgc2V0OiAgJ3RoaXMuZGV2PT09MCA/IDAgOiAodGhpcy5tZWFuIC0gY2VsbC5kYXRhLnEyKHRoaXMuZ2V0KSkgLyBNYXRoLnNxcnQodGhpcy5kZXYvKHRoaXMudmFsaWQtMSkpJyxcbiAgICByZXE6ICBbJ21lYW4nLCAnc3RkZXYnLCAnbWVkaWFuJ10sIGlkeDogNVxuICB9KVxufTtcblxuZnVuY3Rpb24gbWVhc3VyZShiYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvdXQpIHtcbiAgICB2YXIgbSA9IHV0aWwuZXh0ZW5kKHtpbml0OicnLCBhZGQ6JycsIHJlbTonJywgaWR4OjB9LCBiYXNlKTtcbiAgICBtLm91dCA9IG91dCB8fCBiYXNlLm5hbWU7XG4gICAgcmV0dXJuIG07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYWdnLCBzdHJlYW0pIHtcbiAgZnVuY3Rpb24gY29sbGVjdChtLCBhKSB7XG4gICAgZnVuY3Rpb24gaGVscGVyKHIpIHsgaWYgKCFtW3JdKSBjb2xsZWN0KG0sIG1bcl0gPSB0eXBlc1tyXSgpKTsgfVxuICAgIGlmIChhLnJlcSkgYS5yZXEuZm9yRWFjaChoZWxwZXIpO1xuICAgIGlmIChzdHJlYW0gJiYgYS5zdHIpIGEuc3RyLmZvckVhY2goaGVscGVyKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICB2YXIgbWFwID0gYWdnLnJlZHVjZShcbiAgICBjb2xsZWN0LFxuICAgIGFnZy5yZWR1Y2UoZnVuY3Rpb24obSwgYSkgeyByZXR1cm4gKG1bYS5uYW1lXSA9IGEsIG0pOyB9LCB7fSlcbiAgKTtcbiAgcmV0dXJuIHV0aWwudmFscyhtYXApLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShhZ2csIHN0cmVhbSwgYWNjZXNzb3IsIG11dGF0b3IpIHtcbiAgdmFyIGFsbCA9IHJlc29sdmUoYWdnLCBzdHJlYW0pLFxuICAgICAgY3RyID0gJ3RoaXMuY2VsbCA9IGNlbGw7IHRoaXMudHVwbGUgPSB0OyB0aGlzLnZhbGlkID0gMDsgdGhpcy5taXNzaW5nID0gMDsnLFxuICAgICAgYWRkID0gJ2lmICh2PT1udWxsKSB0aGlzLm1pc3NpbmcrKzsgaWYgKCF0aGlzLmlzVmFsaWQodikpIHJldHVybjsgKyt0aGlzLnZhbGlkOycsXG4gICAgICByZW0gPSAnaWYgKHY9PW51bGwpIHRoaXMubWlzc2luZy0tOyBpZiAoIXRoaXMuaXNWYWxpZCh2KSkgcmV0dXJuOyAtLXRoaXMudmFsaWQ7JyxcbiAgICAgIHNldCA9ICd2YXIgdCA9IHRoaXMudHVwbGU7IHZhciBjZWxsID0gdGhpcy5jZWxsOyc7XG5cbiAgYWxsLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIGlmIChhLmlkeCA8IDApIHtcbiAgICAgIGN0ciA9IGEuaW5pdCArIGN0cjtcbiAgICAgIGFkZCA9IGEuYWRkICsgYWRkO1xuICAgICAgcmVtID0gYS5yZW0gKyByZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0ciArPSBhLmluaXQ7XG4gICAgICBhZGQgKz0gYS5hZGQ7XG4gICAgICByZW0gKz0gYS5yZW07XG4gICAgfVxuICB9KTtcbiAgYWdnLnNsaWNlKClcbiAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmlkeCAtIGIuaWR4OyB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHNldCArPSAndGhpcy5hc3NpZ24odCxcXCcnK2Eub3V0KydcXCcsJythLnNldCsnKTsnO1xuICAgIH0pO1xuICBzZXQgKz0gJ3JldHVybiB0Oyc7XG5cbiAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgY3RyID0gRnVuY3Rpb24oJ2NlbGwnLCAndCcsIGN0cik7XG4gIGN0ci5wcm90b3R5cGUuYXNzaWduID0gbXV0YXRvcjtcbiAgY3RyLnByb3RvdHlwZS5hZGQgPSBGdW5jdGlvbigndCcsICd2YXIgdiA9IHRoaXMuZ2V0KHQpOycgKyBhZGQpO1xuICBjdHIucHJvdG90eXBlLnJlbSA9IEZ1bmN0aW9uKCd0JywgJ3ZhciB2ID0gdGhpcy5nZXQodCk7JyArIHJlbSk7XG4gIGN0ci5wcm90b3R5cGUuc2V0ID0gRnVuY3Rpb24oc2V0KTtcbiAgY3RyLnByb3RvdHlwZS5nZXQgPSBhY2Nlc3NvcjtcbiAgY3RyLnByb3RvdHlwZS5kaXN0aW5jdCA9IHJlcXVpcmUoJy4uL3N0YXRzJykuY291bnQuZGlzdGluY3Q7XG4gIGN0ci5wcm90b3R5cGUuaXNWYWxpZCA9IHV0aWwuaXNWYWxpZDtcbiAgY3RyLmZpZWxkcyA9IGFnZy5tYXAodXRpbC4kKCdvdXQnKSk7XG4gIHJldHVybiBjdHI7XG59XG5cbnR5cGVzLmNyZWF0ZSA9IGNyZWF0ZTtcbm1vZHVsZS5leHBvcnRzID0gdHlwZXM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgdGltZSA9IHJlcXVpcmUoJy4uL3RpbWUnKSxcbiAgICBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbnMob3B0KSB7XG4gIGlmICghb3B0KSB7IHRocm93IEVycm9yKFwiTWlzc2luZyBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSwgICAgICBcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcbiAgICBcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHsgc3RlcCAqPSBiYXNlOyB9IHdoaWxlIChNYXRoLmNlaWwoc3Bhbi9zdGVwKSA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGk9MDsgaTxkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuICB2ID0gTWF0aC5sb2coc3RlcCk7XG4gIHByZWNpc2lvbiA9IHYgPj0gMCA/IDAgOiB+figtdiAvIGxvZ2IpICsgMTtcbiAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogIG1heCxcbiAgICBzdGVwOiAgc3RlcCxcbiAgICB1bml0OiAge3ByZWNpc2lvbjogcHJlY2lzaW9ufSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpc2VjdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHYgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgodikge1xuICByZXR1cm4gTWF0aC5mbG9vcigodiAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGRhdGVfdmFsdWUodikge1xuICByZXR1cm4gdGhpcy51bml0LmRhdGUodmFsdWUuY2FsbCh0aGlzLCB2KSk7XG59XG5cbmZ1bmN0aW9uIGRhdGVfaW5kZXgodikge1xuICByZXR1cm4gaW5kZXguY2FsbCh0aGlzLCB0aGlzLnVuaXQudW5pdCh2KSk7XG59XG5cbmJpbnMuZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBpZiAoIW9wdCkgeyB0aHJvdyBFcnJvcihcIk1pc3NpbmcgZGF0ZSBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZmluZCB0aW1lIHN0ZXAsIHRoZW4gYmluXG4gIHZhciB1bml0cyA9IG9wdC51dGMgPyB0aW1lLnV0YyA6IHRpbWUsXG4gICAgICBkbWluID0gb3B0Lm1pbixcbiAgICAgIGRtYXggPSBvcHQubWF4LFxuICAgICAgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDIwLFxuICAgICAgbWluYiA9IG9wdC5taW5iaW5zIHx8IDQsXG4gICAgICBzcGFuID0gKCtkbWF4KSAtICgrZG1pbiksXG4gICAgICB1bml0ID0gb3B0LnVuaXQgPyB1bml0c1tvcHQudW5pdF0gOiB1bml0cy5maW5kKHNwYW4sIG1pbmIsIG1heGIpLFxuICAgICAgc3BlYyA9IGJpbnMoe1xuICAgICAgICBtaW46ICAgICB1bml0Lm1pbiAhPSBudWxsID8gdW5pdC5taW4gOiB1bml0LnVuaXQoZG1pbiksXG4gICAgICAgIG1heDogICAgIHVuaXQubWF4ICE9IG51bGwgPyB1bml0Lm1heCA6IHVuaXQudW5pdChkbWF4KSxcbiAgICAgICAgbWF4YmluczogbWF4YixcbiAgICAgICAgbWluc3RlcDogdW5pdC5taW5zdGVwLFxuICAgICAgICBzdGVwczogICB1bml0LnN0ZXBcbiAgICAgIH0pO1xuXG4gIHNwZWMudW5pdCA9IHVuaXQ7XG4gIHNwZWMuaW5kZXggPSBkYXRlX2luZGV4O1xuICBpZiAoIW9wdC5yYXcpIHNwZWMudmFsdWUgPSBkYXRlX3ZhbHVlO1xuICByZXR1cm4gc3BlYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmlucztcbiIsInZhciBiaW5zID0gcmVxdWlyZSgnLi9iaW5zJyksXG4gICAgZ2VuICA9IHJlcXVpcmUoJy4uL2dlbmVyYXRlJyksXG4gICAgdHlwZSA9IHJlcXVpcmUoJy4uL2ltcG9ydC90eXBlJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICBzdGF0cyA9IHJlcXVpcmUoJy4uL3N0YXRzJyk7XG5cbnZhciBxdHlwZSA9IHtcbiAgJ2ludGVnZXInOiAxLFxuICAnbnVtYmVyJzogMSxcbiAgJ2RhdGUnOiAxXG59O1xuXG5mdW5jdGlvbiAkYmluKHZhbHVlcywgZiwgb3B0KSB7XG4gIG9wdCA9IG9wdGlvbnModmFsdWVzLCBmLCBvcHQpO1xuICB2YXIgYiA9IHNwZWMob3B0KTtcbiAgcmV0dXJuICFiID8gKG9wdC5hY2Nlc3NvciB8fCB1dGlsLmlkZW50aXR5KSA6XG4gICAgdXRpbC4kZnVuYygnYmluJywgYi51bml0LnVuaXQgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gYi52YWx1ZShiLnVuaXQudW5pdCh4KSk7IH0gOlxuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gYi52YWx1ZSh4KTsgfVxuICAgICkob3B0LmFjY2Vzc29yKTtcbn1cblxuZnVuY3Rpb24gaGlzdG9ncmFtKHZhbHVlcywgZiwgb3B0KSB7XG4gIG9wdCA9IG9wdGlvbnModmFsdWVzLCBmLCBvcHQpO1xuICB2YXIgYiA9IHNwZWMob3B0KTtcbiAgcmV0dXJuIGIgP1xuICAgIG51bWVyaWNhbCh2YWx1ZXMsIG9wdC5hY2Nlc3NvciwgYikgOlxuICAgIGNhdGVnb3JpY2FsKHZhbHVlcywgb3B0LmFjY2Vzc29yLCBvcHQgJiYgb3B0LnNvcnQpO1xufVxuXG5mdW5jdGlvbiBzcGVjKG9wdCkge1xuICB2YXIgdCA9IG9wdC50eXBlLCBiID0gbnVsbDtcbiAgaWYgKHQgPT0gbnVsbCB8fCBxdHlwZVt0XSkge1xuICAgIGlmICh0ID09PSAnaW50ZWdlcicgJiYgb3B0Lm1pbnN0ZXAgPT0gbnVsbCkgb3B0Lm1pbnN0ZXAgPSAxO1xuICAgIGIgPSAodCA9PT0gJ2RhdGUnKSA/IGJpbnMuZGF0ZShvcHQpIDogYmlucyhvcHQpO1xuICB9XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBvcHRpb25zKCkge1xuICB2YXIgYSA9IGFyZ3VtZW50cyxcbiAgICAgIGkgPSAwLFxuICAgICAgdmFsdWVzID0gdXRpbC5pc0FycmF5KGFbaV0pID8gYVtpKytdIDogbnVsbCxcbiAgICAgIGYgPSB1dGlsLmlzRnVuY3Rpb24oYVtpXSkgfHwgdXRpbC5pc1N0cmluZyhhW2ldKSA/IHV0aWwuJChhW2krK10pIDogbnVsbCxcbiAgICAgIG9wdCA9IHV0aWwuZXh0ZW5kKHt9LCBhW2ldKTtcbiAgXG4gIGlmICh2YWx1ZXMpIHtcbiAgICBvcHQudHlwZSA9IG9wdC50eXBlIHx8IHR5cGUodmFsdWVzLCBmKTtcbiAgICBpZiAocXR5cGVbb3B0LnR5cGVdKSB7XG4gICAgICB2YXIgZXh0ID0gc3RhdHMuZXh0ZW50KHZhbHVlcywgZik7XG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7bWluOiBleHRbMF0sIG1heDogZXh0WzFdfSwgb3B0KTtcbiAgICB9XG4gIH1cbiAgaWYgKGYpIHsgb3B0LmFjY2Vzc29yID0gZjsgfVxuICByZXR1cm4gb3B0O1xufVxuXG5mdW5jdGlvbiBudW1lcmljYWwodmFsdWVzLCBmLCBiKSB7XG4gIHZhciBoID0gZ2VuLnJhbmdlKGIuc3RhcnQsIGIuc3RvcCArIGIuc3RlcC8yLCBiLnN0ZXApXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB7dmFsdWU6IGIudmFsdWUodiksIGNvdW50OiAwfTsgfSk7XG5cbiAgZm9yICh2YXIgaT0wLCB2LCBqOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGogPSBiLmluZGV4KHYpO1xuICAgICAgaWYgKGogPCAwIHx8IGogPj0gaC5sZW5ndGggfHwgIWlzRmluaXRlKGopKSBjb250aW51ZTtcbiAgICAgIGhbal0uY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgaC5iaW5zID0gYjtcbiAgcmV0dXJuIGg7XG59XG5cbmZ1bmN0aW9uIGNhdGVnb3JpY2FsKHZhbHVlcywgZiwgc29ydCkge1xuICB2YXIgdSA9IHN0YXRzLnVuaXF1ZSh2YWx1ZXMsIGYpLFxuICAgICAgYyA9IHN0YXRzLmNvdW50Lm1hcCh2YWx1ZXMsIGYpO1xuICByZXR1cm4gdS5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4ge3ZhbHVlOiBrLCBjb3VudDogY1trXX07IH0pXG4gICAgLnNvcnQodXRpbC5jb21wYXJhdG9yKHNvcnQgPyAnLWNvdW50JyA6ICcrdmFsdWUnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAkYmluOiAkYmluLFxuICBoaXN0b2dyYW06IGhpc3RvZ3JhbVxufTsiLCJ2YXIgZDNfdGltZSA9IHJlcXVpcmUoJ2QzLXRpbWUnKSxcbiAgICBkM190aW1lRiA9IHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0JyksXG4gICAgZDNfbnVtYmVyRiA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpLFxuICAgIG51bWJlckYgPSBkM19udW1iZXJGLCAvLyBkZWZhdWx0cyB0byBFTi1VU1xuICAgIHRpbWVGID0gZDNfdGltZUY7ICAgICAvLyBkZWZhdWx0cyB0byBFTi1VU1xuXG5mdW5jdGlvbiBudW1iZXJMb2NhbGUobCkge1xuICB2YXIgZiA9IGQzX251bWJlckYubG9jYWxlRm9ybWF0KGwpO1xuICBpZiAoZiA9PSBudWxsKSB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIGxvY2FsZTogJyArIGwpO1xuICBudW1iZXJGID0gZjtcbn1cblxuZnVuY3Rpb24gdGltZUxvY2FsZShsKSB7XG4gIHZhciBmID0gZDNfdGltZUYubG9jYWxlRm9ybWF0KGwpO1xuICBpZiAoZiA9PSBudWxsKSB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIGxvY2FsZTogJyArIGwpO1xuICB0aW1lRiA9IGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBVcGRhdGUgbnVtYmVyIGZvcm1hdHRlciB0byB1c2UgcHJvdmlkZWQgbG9jYWxlIGNvbmZpZ3VyYXRpb24uXG4gIC8vIEZvciBtb3JlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZm9ybWF0XG4gIG51bWJlckxvY2FsZTogbnVtYmVyTG9jYWxlLFxuICBudW1iZXI6ICAgICAgIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIG51bWJlckYuZm9ybWF0KGYpOyB9LFxuICBudW1iZXJQcmVmaXg6IGZ1bmN0aW9uKGYsIHYpIHsgcmV0dXJuIG51bWJlckYuZm9ybWF0UHJlZml4KGYsIHYpOyB9LFxuXG4gIC8vIFVwZGF0ZSB0aW1lIGZvcm1hdHRlciB0byB1c2UgcHJvdmlkZWQgbG9jYWxlIGNvbmZpZ3VyYXRpb24uXG4gIC8vIEZvciBtb3JlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXRcbiAgdGltZUxvY2FsZTogICB0aW1lTG9jYWxlLFxuICB0aW1lOiAgICAgICAgIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHRpbWVGLmZvcm1hdChmKTsgfSwgIFxuICB1dGM6ICAgICAgICAgIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHRpbWVGLnV0Y0Zvcm1hdChmKTsgfSxcblxuICAvLyBTZXQgbnVtYmVyIGFuZCB0aW1lIGxvY2FsZSBzaW11bHRhbmVvdXNseS5cbiAgbG9jYWxlOiAgICAgICBmdW5jdGlvbihsKSB7IG51bWJlckxvY2FsZShsKTsgdGltZUxvY2FsZShsKTsgfSxcblxuICAvLyBhdXRvbWF0aWMgZm9ybWF0dGluZyBmdW5jdGlvbnNcbiAgYXV0bzoge1xuICAgIG51bWJlcjogICBudW1iZXJBdXRvRm9ybWF0LFxuICAgIHRpbWU6ICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVBdXRvRm9ybWF0KCk7IH0sXG4gICAgdXRjOiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXRjQXV0b0Zvcm1hdCgpOyB9XG4gIH1cbn07XG5cbnZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZnVuY3Rpb24gaW50ZXJ2YWxzKGRvbWFpbiwgY291bnQpIHtcbiAgaWYgKCFkb21haW4ubGVuZ3RoKSBkb21haW4gPSBbMF07XG4gIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gIHZhciBzdGFydCA9IGRvbWFpblswXSxcbiAgICAgIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChzdG9wIDwgc3RhcnQpIHsgZXJyb3IgPSBzdG9wOyBzdG9wID0gc3RhcnQ7IHN0YXJ0ID0gZXJyb3I7IH1cblxuICB2YXIgc3BhbiA9IChzdG9wIC0gc3RhcnQpIHx8IChjb3VudCA9IDEsIHN0YXJ0IHx8IHN0b3AgfHwgMSksXG4gICAgICBzdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3BhbiAvIGNvdW50KSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzcGFuIC8gY291bnQgLyBzdGVwO1xuXG4gIC8vIEZpbHRlciB0aWNrcyB0byBnZXQgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGNvdW50LlxuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcCAqPSA1O1xuICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcCAqPSAyO1xuXG4gIC8vIFJvdW5kIHN0YXJ0IGFuZCBzdG9wIHZhbHVlcyB0byBzdGVwIGludGVydmFsLlxuICByZXR1cm4gW1xuICAgIE1hdGguY2VpbChzdGFydCAvIHN0ZXApICogc3RlcCxcbiAgICBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKSAqIHN0ZXAgKyBzdGVwIC8gMiwgLy8gaW5jbHVzaXZlXG4gICAgc3RlcFxuICBdO1xufVxuXG5mdW5jdGlvbiBudW1iZXJBdXRvRm9ybWF0KGRvbWFpbiwgY291bnQsIGYpIHtcbiAgdmFyIHJhbmdlID0gaW50ZXJ2YWxzKGRvbWFpbiwgY291bnQpO1xuICBpZiAoZiA9PSBudWxsKSB7XG4gICAgZiA9ICcsLicgKyBkM19udW1iZXJGLnByZWNpc2lvbkZpeGVkKHJhbmdlWzJdKSArICdmJztcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGYgPSBkM19udW1iZXJGLmZvcm1hdFNwZWNpZmllcihmKSwgZi50eXBlKSB7XG4gICAgICBjYXNlICdzJzoge1xuICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhyYW5nZVswXSksIE1hdGguYWJzKHJhbmdlWzFdKSk7XG4gICAgICAgIGlmIChmLnByZWNpc2lvbiA9PSBudWxsKSBmLnByZWNpc2lvbiA9IGQzX251bWJlckYucHJlY2lzaW9uUHJlZml4KHJhbmdlWzJdLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBudW1iZXJGLmZvcm1hdFByZWZpeChmLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjYXNlICcnOlxuICAgICAgY2FzZSAnZSc6XG4gICAgICBjYXNlICdnJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAncic6IHtcbiAgICAgICAgaWYgKGYucHJlY2lzaW9uID09IG51bGwpIGYucHJlY2lzaW9uID0gZDNfbnVtYmVyRi5wcmVjaXNpb25Sb3VuZChyYW5nZVsyXSwgTWF0aC5tYXgoTWF0aC5hYnMocmFuZ2VbMF0pLCBNYXRoLmFicyhyYW5nZVsxXSkpKSAtIChmLnR5cGUgPT09ICdlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZic6XG4gICAgICBjYXNlICclJzoge1xuICAgICAgICBpZiAoZi5wcmVjaXNpb24gPT0gbnVsbCkgZi5wcmVjaXNpb24gPSBkM19udW1iZXJGLnByZWNpc2lvbkZpeGVkKHJhbmdlWzJdKSAtIChmLnR5cGUgPT09ICclJykgKiAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlckYuZm9ybWF0KGYpO1xufVxuXG5mdW5jdGlvbiB0aW1lQXV0b0Zvcm1hdCgpIHtcbiAgdmFyIGYgPSB0aW1lRi5mb3JtYXQsXG4gICAgICBmb3JtYXRNaWxsaXNlY29uZCA9IGYoJy4lTCcpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZignOiVTJyksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmKCclSTolTScpLFxuICAgICAgZm9ybWF0SG91ciA9IGYoJyVJICVwJyksXG4gICAgICBmb3JtYXREYXkgPSBmKCclYSAlZCcpLFxuICAgICAgZm9ybWF0V2VlayA9IGYoJyViICVkJyksXG4gICAgICBmb3JtYXRNb250aCA9IGYoJyVCJyksXG4gICAgICBmb3JtYXRZZWFyID0gZignJVknKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkID0gK2RhdGU7XG4gICAgcmV0dXJuIChkM190aW1lLnNlY29uZChkYXRlKSA8IGQgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IGQzX3RpbWUubWludXRlKGRhdGUpIDwgZCA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGQzX3RpbWUuaG91cihkYXRlKSA8IGQgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkM190aW1lLmRheShkYXRlKSA8IGQgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogZDNfdGltZS5tb250aChkYXRlKSA8IGQgP1xuICAgICAgICAgIChkM190aW1lLndlZWsoZGF0ZSkgPCBkID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiBkM190aW1lLnllYXIoZGF0ZSkgPCBkID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXRjQXV0b0Zvcm1hdCgpIHtcbiAgdmFyIGYgPSB0aW1lRi51dGNGb3JtYXQsXG4gICAgICBmb3JtYXRNaWxsaXNlY29uZCA9IGYoJy4lTCcpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZignOiVTJyksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmKCclSTolTScpLFxuICAgICAgZm9ybWF0SG91ciA9IGYoJyVJICVwJyksXG4gICAgICBmb3JtYXREYXkgPSBmKCclYSAlZCcpLFxuICAgICAgZm9ybWF0V2VlayA9IGYoJyViICVkJyksXG4gICAgICBmb3JtYXRNb250aCA9IGYoJyVCJyksXG4gICAgICBmb3JtYXRZZWFyID0gZignJVknKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkID0gK2RhdGU7XG4gICAgcmV0dXJuIChkM190aW1lLnV0Y1NlY29uZChkYXRlKSA8IGQgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IGQzX3RpbWUudXRjTWludXRlKGRhdGUpIDwgZCA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGQzX3RpbWUudXRjSG91cihkYXRlKSA8IGQgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkM190aW1lLnV0Y0RheShkYXRlKSA8IGQgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogZDNfdGltZS51dGNNb250aChkYXRlKSA8IGQgP1xuICAgICAgICAgIChkM190aW1lLnV0Y1dlZWsoZGF0ZSkgPCBkID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiBkM190aW1lLnV0Y1llYXIoZGF0ZSkgPCBkID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfTtcbn1cbiIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSBtaW4gPT09IHVuZGVmaW5lZCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYiA9IGE7XG4gICAgYSA9IDA7XG4gIH1cbiAgdmFyIGQgPSBiIC0gYTtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiB8fCAxO1xuICB2YXIgbmV4dDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG4gICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeCA9IG5leHQ7XG4gICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIHggPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHJkcyA9IHgqeCArIHkqeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG4gICAgYyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgbmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG4gICAgcmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBkM19kc3YgPSByZXF1aXJlKCdkMy1kc3YnKTtcblxuZnVuY3Rpb24gZHN2KGRhdGEsIGZvcm1hdCkge1xuICBpZiAoZGF0YSkge1xuICAgIHZhciBoID0gZm9ybWF0LmhlYWRlcjtcbiAgICBkYXRhID0gKGggPyBoLmpvaW4oZm9ybWF0LmRlbGltaXRlcikgKyAnXFxuJyA6ICcnKSArIGRhdGE7XG4gIH1cbiAgcmV0dXJuIGQzX2Rzdi5kc3YoZm9ybWF0LmRlbGltaXRlcikucGFyc2UoZGF0YSk7XG59XG5cbmRzdi5kZWxpbWl0ZXIgPSBmdW5jdGlvbihkZWxpbSkge1xuICB2YXIgZm10ID0ge2RlbGltaXRlcjogZGVsaW19O1xuICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGRzdihkYXRhLCBmb3JtYXQgPyB1dGlsLmV4dGVuZChmb3JtYXQsIGZtdCkgOiBmbXQpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkc3Y7IiwidmFyIGRzdiA9IHJlcXVpcmUoJy4vZHN2Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBqc29uOiByZXF1aXJlKCcuL2pzb24nKSxcbiAgdG9wb2pzb246IHJlcXVpcmUoJy4vdG9wb2pzb24nKSxcbiAgdHJlZWpzb246IHJlcXVpcmUoJy4vdHJlZWpzb24nKSxcbiAgZHN2OiBkc3YsXG4gIGNzdjogZHN2LmRlbGltaXRlcignLCcpLFxuICB0c3Y6IGRzdi5kZWxpbWl0ZXIoJ1xcdCcpXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgZCA9IHV0aWwuaXNPYmplY3QoZGF0YSkgJiYgIXV0aWwuaXNCdWZmZXIoZGF0YSkgP1xuICAgIGRhdGEgOiBKU09OLnBhcnNlKGRhdGEpO1xuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5wcm9wZXJ0eSkge1xuICAgIGQgPSB1dGlsLmFjY2Vzc29yKGZvcm1hdC5wcm9wZXJ0eSkoZCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59O1xuIiwidmFyIGpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcblxudmFyIHJlYWRlciA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgdG9wb2pzb24gPSByZWFkZXIudG9wb2pzb247XG4gIGlmICh0b3BvanNvbiA9PSBudWxsKSB7IHRocm93IEVycm9yKCdUb3BvSlNPTiBsaWJyYXJ5IG5vdCBsb2FkZWQuJyk7IH1cblxuICB2YXIgdCA9IGpzb24oZGF0YSwgZm9ybWF0KSwgb2JqO1xuXG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LmZlYXR1cmUpIHtcbiAgICBpZiAoKG9iaiA9IHQub2JqZWN0c1tmb3JtYXQuZmVhdHVyZV0pKSB7XG4gICAgICByZXR1cm4gdG9wb2pzb24uZmVhdHVyZSh0LCBvYmopLmZlYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBUb3BvSlNPTiBvYmplY3Q6ICcgKyBmb3JtYXQuZmVhdHVyZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcm1hdCAmJiBmb3JtYXQubWVzaCkge1xuICAgIGlmICgob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5tZXNoXSkpIHtcbiAgICAgIHJldHVybiBbdG9wb2pzb24ubWVzaCh0LCB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJyArIGZvcm1hdC5tZXNoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ01pc3NpbmcgVG9wb0pTT04gZmVhdHVyZSBvciBtZXNoIHBhcmFtZXRlci4nKTtcbiAgfVxufTtcblxucmVhZGVyLnRvcG9qc29uID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3RvcG9qc29uJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd0b3BvanNvbiddIDogbnVsbCk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlYWRlcjsiLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0ganNvbihkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdG9UYWJsZShkYXRhLCAoZm9ybWF0ICYmIGZvcm1hdC5jaGlsZHJlbikpO1xufTtcblxuZnVuY3Rpb24gdG9UYWJsZShyb290LCBjaGlsZHJlbkZpZWxkKSB7XG4gIGNoaWxkcmVuRmllbGQgPSBjaGlsZHJlbkZpZWxkIHx8ICdjaGlsZHJlbic7XG4gIHZhciB0YWJsZSA9IFtdO1xuICBcbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIHRhYmxlLnB1c2gobm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZVtjaGlsZHJlbkZpZWxkXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aXNpdChjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICB2aXNpdChyb290LCBudWxsKTtcbiAgcmV0dXJuICh0YWJsZS5yb290ID0gcm9vdCwgdGFibGUpO1xufSIsIi8vIE1hdGNoZXMgYWJzb2x1dGUgVVJMcyB3aXRoIG9wdGlvbmFsIHByb3RvY29sXG4vLyAgIGh0dHBzOi8vLi4uICAgIGZpbGU6Ly8uLi4gICAgLy8uLi5cbnZhciBwcm90b2NvbF9yZSA9IC9eKFtBLVphLXpdKzopP1xcL1xcLy87XG5cbi8vIFNwZWNpYWwgdHJlYXRtZW50IGluIG5vZGUuanMgZm9yIHRoZSBmaWxlOiBwcm90b2NvbFxudmFyIGZpbGVQcm90b2NvbCA9ICdmaWxlOi8vJztcblxuLy8gVmFsaWRhdGUgYW5kIGNsZWFudXAgVVJMIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGFsbG93ZWQgdG8gYmUgYWNjZXNzZWRcbi8vIFJldHVybnMgY2xlYW5lZCB1cCBVUkwsIG9yIGZhbHNlIGlmIGFjY2VzcyBpcyBub3QgYWxsb3dlZFxuZnVuY3Rpb24gc2FuaXRpemVVcmwob3B0KSB7XG4gIHZhciB1cmwgPSBvcHQudXJsO1xuICBpZiAoIXVybCAmJiBvcHQuZmlsZSkgeyByZXR1cm4gZmlsZVByb3RvY29sICsgb3B0LmZpbGU7IH1cblxuICAvLyBJbiBjYXNlIHRoaXMgaXMgYSByZWxhdGl2ZSB1cmwgKGhhcyBubyBob3N0KSwgcHJlcGVuZCBvcHQuYmFzZVVSTFxuICBpZiAob3B0LmJhc2VVUkwgJiYgIXByb3RvY29sX3JlLnRlc3QodXJsKSkge1xuICAgIGlmICghc3RhcnRzV2l0aCh1cmwsICcvJykgJiYgb3B0LmJhc2VVUkxbb3B0LmJhc2VVUkwubGVuZ3RoLTFdICE9PSAnLycpIHtcbiAgICAgIHVybCA9ICcvJyArIHVybDsgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBzbGFzaCBiZXR3ZWVuIHRoZSBiYXNlVVJMIChlLmcuIGhvc3RuYW1lKSBhbmQgdXJsXG4gICAgfVxuICAgIHVybCA9IG9wdC5iYXNlVVJMICsgdXJsO1xuICB9XG4gIC8vIHJlbGF0aXZlIHByb3RvY29sLCBzdGFydHMgd2l0aCAnLy8nXG4gIGlmICghbG9hZC51c2VYSFIgJiYgc3RhcnRzV2l0aCh1cmwsICcvLycpKSB7XG4gICAgdXJsID0gKG9wdC5kZWZhdWx0UHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6JyArIHVybDtcbiAgfVxuICAvLyBJZiBvcHQuZG9tYWluV2hpdGVMaXN0IGlzIHNldCwgb25seSBhbGxvd3MgdXJsLCB3aG9zZSBob3N0bmFtZVxuICAvLyAqIElzIHRoZSBzYW1lIGFzIHRoZSBvcmlnaW4gKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSlcbiAgLy8gKiBFcXVhbHMgb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICAvLyAqIElzIGEgcHJvcGVyIHN1YmRvbWFpbiBvZiBvbmUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgd2hpdGVsaXN0XG4gIGlmIChvcHQuZG9tYWluV2hpdGVMaXN0KSB7XG4gICAgdmFyIGRvbWFpbiwgb3JpZ2luO1xuICAgIGlmIChsb2FkLnVzZVhIUikge1xuICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICAvLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzM2NTEzL2hvdy1kby1pLXBhcnNlLWEtdXJsLWludG8taG9zdG5hbWUtYW5kLXBhdGgtaW4tamF2YXNjcmlwdFxuICAgICAgLy8gSUUgZG9lc24ndCBwb3B1bGF0ZSBhbGwgbGluayBwcm9wZXJ0aWVzIHdoZW4gc2V0dGluZyAuaHJlZiB3aXRoIGEgcmVsYXRpdmUgVVJMLFxuICAgICAgLy8gaG93ZXZlciAuaHJlZiB3aWxsIHJldHVybiBhbiBhYnNvbHV0ZSBVUkwgd2hpY2ggdGhlbiBjYW4gYmUgdXNlZCBvbiBpdHNlbGZcbiAgICAgIC8vIHRvIHBvcHVsYXRlIHRoZXNlIGFkZGl0aW9uYWwgZmllbGRzLlxuICAgICAgaWYgKGEuaG9zdCA9PT0gJycpIHtcbiAgICAgICAgYS5ocmVmID0gYS5ocmVmO1xuICAgICAgfVxuICAgICAgZG9tYWluID0gYS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWxhdGl2ZSBwcm90b2NvbCBpcyBicm9rZW46IGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtdXJsL2lzc3Vlcy81XG4gICAgICB2YXIgcGFydHMgPSByZXF1aXJlKCd1cmwnKS5wYXJzZSh1cmwpO1xuICAgICAgZG9tYWluID0gcGFydHMuaG9zdG5hbWU7XG4gICAgICBvcmlnaW4gPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGRvbWFpbikge1xuICAgICAgdmFyIHdoaXRlTGlzdGVkID0gb3B0LmRvbWFpbldoaXRlTGlzdC5zb21lKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGlkeCA9IGRvbWFpbi5sZW5ndGggLSBkLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGQgPT09IGRvbWFpbiB8fFxuICAgICAgICAgIChpZHggPiAxICYmIGRvbWFpbltpZHgtMV0gPT09ICcuJyAmJiBkb21haW4ubGFzdEluZGV4T2YoZCkgPT09IGlkeCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghd2hpdGVMaXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgJ1VSTCBpcyBub3Qgd2hpdGVsaXN0ZWQ6ICcgKyB1cmw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGxvYWQob3B0LCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlKSB7IHRocm93IGU7IH0sIHVybDtcblxuICB0cnkge1xuICAgIHVybCA9IGxvYWQuc2FuaXRpemVVcmwob3B0KTsgLy8gZW5hYmxlIG92ZXJyaWRlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICBlcnJvcignSW52YWxpZCBVUkw6ICcgKyBvcHQudXJsKTtcbiAgfSBlbHNlIGlmIChsb2FkLnVzZVhIUikge1xuICAgIC8vIG9uIGNsaWVudCwgdXNlIHhoclxuICAgIHJldHVybiB4aHIodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoc3RhcnRzV2l0aCh1cmwsIGZpbGVQcm90b2NvbCkpIHtcbiAgICAvLyBvbiBzZXJ2ZXIsIGlmIHVybCBzdGFydHMgd2l0aCAnZmlsZTovLycsIHN0cmlwIGl0IGFuZCBsb2FkIGZyb20gZmlsZVxuICAgIHJldHVybiBmaWxlKHVybC5zbGljZShmaWxlUHJvdG9jb2wubGVuZ3RoKSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHVybC5pbmRleE9mKCc6Ly8nKSA8IDApIHsgLy8gVE9ETyBiZXR0ZXIgcHJvdG9jb2wgY2hlY2s/XG4gICAgLy8gb24gc2VydmVyLCBpZiBubyBwcm90b2NvbCBhc3N1bWUgZmlsZVxuICAgIHJldHVybiBmaWxlKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciByZWd1bGFyIFVSTHMgb24gc2VydmVyXG4gICAgcmV0dXJuIGh0dHAodXJsLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24geGhySGFzUmVzcG9uc2UocmVxdWVzdCkge1xuICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICByZXR1cm4gdHlwZSAmJiB0eXBlICE9PSAndGV4dCcgP1xuICAgIHJlcXVlc3QucmVzcG9uc2UgOiAvLyBudWxsIG9uIGVycm9yXG4gICAgcmVxdWVzdC5yZXNwb25zZVRleHQ7IC8vICcnIG9uIGVycm9yXG59XG5cbmZ1bmN0aW9uIHhocih1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBhc3luYyA9ICEhY2FsbGJhY2s7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIC8vIElmIElFIGRvZXMgbm90IHN1cHBvcnQgQ09SUywgdXNlIFhEb21haW5SZXF1ZXN0IChjb3BpZWQgZnJvbSBkMy54aHIpXG4gIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0ICYmXG4gICAgICAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cbiAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgaWYgKCFzdGF0dXMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2socmVxdWVzdCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFzeW5jKSB7XG4gICAgaWYgKCdvbmxvYWQnIGluIHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMpIHJlc3BvbmQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIFxuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuICByZXF1ZXN0LnNlbmQoKTtcbiAgXG4gIGlmICghYXN5bmMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsZShmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4Jyk7XG4gIH1cbiAgZnMucmVhZEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaHR0cCh1cmwsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3luYy1yZXF1ZXN0JykoJ0dFVCcsIHVybCkuZ2V0Qm9keSgpO1xuICB9XG4gIFxuICB2YXIgb3B0aW9ucyA9IHt1cmw6IHVybCwgZW5jb2Rpbmc6IG51bGwsIGd6aXA6IHRydWV9O1xuICByZXF1aXJlKCdyZXF1ZXN0Jykob3B0aW9ucywgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgaWYgKCFlcnJvciAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9IGVycm9yIHx8XG4gICAgICAgICdMb2FkIGZhaWxlZCB3aXRoIHJlc3BvbnNlIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyAnLic7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICByZXR1cm4gc3RyaW5nID09IG51bGwgPyBmYWxzZSA6IHN0cmluZy5sYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcsIDApID09PSAwO1xufVxuXG5sb2FkLnNhbml0aXplVXJsID0gc2FuaXRpemVVcmw7XG5cbmxvYWQudXNlWEhSID0gKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5mdW5jdGlvbiByZWFkKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgdHlwZSA9IChmb3JtYXQgJiYgZm9ybWF0LnR5cGUpIHx8ICdqc29uJztcbiAgZGF0YSA9IGZvcm1hdHNbdHlwZV0oZGF0YSwgZm9ybWF0KTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucGFyc2UpIHBhcnNlKGRhdGEsIGZvcm1hdC5wYXJzZSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcykge1xuICB2YXIgY29scywgcGFyc2VycywgZCwgaSwgaiwgY2xlbiwgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgdHlwZXMgPSAodHlwZXM9PT0nYXV0bycpID8gdHlwZS5pbmZlckFsbChkYXRhKSA6IHV0aWwuZHVwbGljYXRlKHR5cGVzKTtcbiAgY29scyA9IHV0aWwua2V5cyh0eXBlcyk7XG4gIHBhcnNlcnMgPSBjb2xzLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiB0eXBlLnBhcnNlcnNbdHlwZXNbY11dOyB9KTtcblxuICBmb3IgKGk9MCwgY2xlbj1jb2xzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvciAoaj0wOyBqPGNsZW47ICsraikge1xuICAgICAgZFtjb2xzW2pdXSA9IHBhcnNlcnNbal0oZFtjb2xzW2pdXSk7XG4gICAgfVxuICB9XG4gIHR5cGUuYW5ub3RhdGlvbihkYXRhLCB0eXBlcyk7XG59XG5cbnJlYWQuZm9ybWF0cyA9IGZvcm1hdHM7XG5tb2R1bGUuZXhwb3J0cyA9IHJlYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBsb2FkID0gcmVxdWlyZSgnLi9sb2FkJyk7XG52YXIgcmVhZCA9IHJlcXVpcmUoJy4vcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxcbiAgLmtleXMocmVhZC5mb3JtYXRzKVxuICAucmVkdWNlKGZ1bmN0aW9uKG91dCwgdHlwZSkge1xuICAgIG91dFt0eXBlXSA9IGZ1bmN0aW9uKG9wdCwgZm9ybWF0LCBjYWxsYmFjaykge1xuICAgICAgLy8gcHJvY2VzcyBhcmd1bWVudHNcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG9wdCkpIHsgb3B0ID0ge3VybDogb3B0fTsgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdXRpbC5pc0Z1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHJlYWQgZm9ybWF0XG4gICAgICBmb3JtYXQgPSB1dGlsLmV4dGVuZCh7cGFyc2U6ICdhdXRvJ30sIGZvcm1hdCk7XG4gICAgICBmb3JtYXQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIGxvYWQgZGF0YVxuICAgICAgdmFyIGRhdGEgPSBsb2FkKG9wdCwgY2FsbGJhY2sgPyBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyb3IpIHsgY2FsbGJhY2soZXJyb3IsIG51bGwpOyByZXR1cm47IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChhc3luYylcbiAgICAgICAgICBkYXRhID0gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gOiB1bmRlZmluZWQpO1xuICAgICAgXG4gICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChzeW5jKVxuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIHJlYWQoZGF0YSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHJldHVybiBvdXQ7XG4gIH0sIHt9KTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgVFlQRVMgPSAnX190eXBlc19fJztcblxudmFyIFBBUlNFUlMgPSB7XG4gIGJvb2xlYW46IHV0aWwuYm9vbGVhbixcbiAgaW50ZWdlcjogdXRpbC5udW1iZXIsXG4gIG51bWJlcjogIHV0aWwubnVtYmVyLFxuICBkYXRlOiAgICB1dGlsLmRhdGUsXG4gIHN0cmluZzogIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0nJyA/IG51bGwgOiB4OyB9XG59O1xuXG52YXIgVEVTVFMgPSB7XG4gIGJvb2xlYW46IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0ndHJ1ZScgfHwgeD09PSdmYWxzZScgfHwgdXRpbC5pc0Jvb2xlYW4oeCk7IH0sXG4gIGludGVnZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFRFU1RTLm51bWJlcih4KSAmJiAoeD0reCkgPT09IH5+eDsgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oK3gpICYmICF1dGlsLmlzRGF0ZSh4KTsgfSxcbiAgZGF0ZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKERhdGUucGFyc2UoeCkpOyB9XG59O1xuXG5mdW5jdGlvbiBhbm5vdGF0aW9uKGRhdGEsIHR5cGVzKSB7XG4gIGlmICghdHlwZXMpIHJldHVybiBkYXRhICYmIGRhdGFbVFlQRVNdIHx8IG51bGw7XG4gIGRhdGFbVFlQRVNdID0gdHlwZXM7XG59XG5cbmZ1bmN0aW9uIHR5cGUodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuO1xuXG4gIC8vIGlmIGRhdGEgYXJyYXkgaGFzIHR5cGUgYW5ub3RhdGlvbnMsIHVzZSB0aGVtXG4gIGlmICh2YWx1ZXNbVFlQRVNdKSB7XG4gICAgdiA9IGYodmFsdWVzW1RZUEVTXSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodikpIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgIXV0aWwuaXNWYWxpZCh2KSAmJiBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuaXNEYXRlKHYpID8gJ2RhdGUnIDpcbiAgICB1dGlsLmlzTnVtYmVyKHYpICAgID8gJ251bWJlcicgOlxuICAgIHV0aWwuaXNCb29sZWFuKHYpICAgPyAnYm9vbGVhbicgOlxuICAgIHV0aWwuaXNTdHJpbmcodikgICAgPyAnc3RyaW5nJyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICByZXR1cm4gKHR5cGVzW2ZdID0gdHlwZShkYXRhLCBmKSwgdHlwZXMpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGluZmVyKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgaiwgdjtcblxuICAvLyB0eXBlcyB0byB0ZXN0IGZvciwgaW4gcHJlY2VkZW5jZSBvcmRlclxuICB2YXIgdHlwZXMgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGdldCBuZXh0IHZhbHVlIHRvIHRlc3RcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICAvLyB0ZXN0IHZhbHVlIGFnYWluc3QgcmVtYWluaW5nIHR5cGVzXG4gICAgZm9yIChqPTA7IGo8dHlwZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmICh1dGlsLmlzVmFsaWQodikgJiYgIVRFU1RTW3R5cGVzW2pdXSh2KSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGogLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm8gdHlwZXMgbGVmdCwgcmV0dXJuICdzdHJpbmcnXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdzdHJpbmcnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzWzBdO1xufVxuXG5mdW5jdGlvbiBpbmZlckFsbChkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICB0eXBlc1tmXSA9IGluZmVyKGRhdGEsIGYpO1xuICAgIHJldHVybiB0eXBlcztcbiAgfSwge30pO1xufVxuXG50eXBlLmFubm90YXRpb24gPSBhbm5vdGF0aW9uO1xudHlwZS5hbGwgPSB0eXBlQWxsO1xudHlwZS5pbmZlciA9IGluZmVyO1xudHlwZS5pbmZlckFsbCA9IGluZmVyQWxsO1xudHlwZS5wYXJzZXJzID0gUEFSU0VSUztcbm1vZHVsZS5leHBvcnRzID0gdHlwZTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgZGwgPSB7XG4gIHZlcnNpb246ICAgICcxLjQuNicsXG4gIGxvYWQ6ICAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L2xvYWQnKSxcbiAgcmVhZDogICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvcmVhZCcpLFxuICB0eXBlOiAgICAgICByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyksXG4gIEFnZ3JlZ2F0b3I6IHJlcXVpcmUoJy4vYWdncmVnYXRlL2FnZ3JlZ2F0b3InKSxcbiAgZ3JvdXBieTogICAgcmVxdWlyZSgnLi9hZ2dyZWdhdGUvZ3JvdXBieScpLFxuICBiaW5zOiAgICAgICByZXF1aXJlKCcuL2JpbnMvYmlucycpLFxuICAkYmluOiAgICAgICByZXF1aXJlKCcuL2JpbnMvaGlzdG9ncmFtJykuJGJpbixcbiAgaGlzdG9ncmFtOiAgcmVxdWlyZSgnLi9iaW5zL2hpc3RvZ3JhbScpLmhpc3RvZ3JhbSxcbiAgZm9ybWF0OiAgICAgcmVxdWlyZSgnLi9mb3JtYXQnKSxcbiAgcHJpbnQ6ICAgICAgcmVxdWlyZSgnLi9wcmludCcpLFxuICB0ZW1wbGF0ZTogICByZXF1aXJlKCcuL3RlbXBsYXRlJyksXG4gIHRpbWU6ICAgICAgIHJlcXVpcmUoJy4vdGltZScpXG59O1xuXG51dGlsLmV4dGVuZChkbCwgdXRpbCk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9nZW5lcmF0ZScpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL3N0YXRzJykpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vaW1wb3J0L3JlYWRlcnMnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGw7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpO1xudmFyIHN0YXRzID0gcmVxdWlyZSgnLi9zdGF0cycpO1xudmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG52YXIgRk1UID0ge1xuICAnZGF0ZSc6ICAgICd8dGltZTpcIiVtLyVkLyVZICVIOiVNOiVTXCInLFxuICAnbnVtYmVyJzogICd8bnVtYmVyOlwiLjRmXCInLFxuICAnaW50ZWdlcic6ICd8bnVtYmVyOlwiZFwiJ1xufTtcblxudmFyIFBPUyA9IHtcbiAgJ251bWJlcic6ICAnbGVmdCcsXG4gICdpbnRlZ2VyJzogJ2xlZnQnXG59O1xuXG5tb2R1bGUuZXhwb3J0cy50YWJsZSA9IGZ1bmN0aW9uKGRhdGEsIG9wdCkge1xuICBvcHQgPSB1dGlsLmV4dGVuZCh7c2VwYXJhdG9yOicgJywgbWlud2lkdGg6IDgsIG1heHdpZHRoOiAxNX0sIG9wdCk7XG4gIHZhciBmaWVsZHMgPSBvcHQuZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKSxcbiAgICAgIHR5cGVzID0gdHlwZS5hbGwoZGF0YSk7XG5cbiAgaWYgKG9wdC5zdGFydCB8fCBvcHQubGltaXQpIHtcbiAgICB2YXIgYSA9IG9wdC5zdGFydCB8fCAwLFxuICAgICAgICBiID0gb3B0LmxpbWl0ID8gYSArIG9wdC5saW1pdCA6IGRhdGEubGVuZ3RoO1xuICAgIGRhdGEgPSBkYXRhLnNsaWNlKGEsIGIpO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGNoYXIgd2lkdGggb2YgZmllbGRzXG4gIHZhciBsZW5zID0gZmllbGRzLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGZvcm1hdCA9IEZNVFt0eXBlc1tuYW1lXV0gfHwgJycsXG4gICAgICAgIHQgPSB0ZW1wbGF0ZSgne3snICsgbmFtZSArIGZvcm1hdCArICd9fScpLFxuICAgICAgICBsID0gc3RhdHMubWF4KGRhdGEsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHQoeCkubGVuZ3RoOyB9KTtcbiAgICBsID0gTWF0aC5tYXgoTWF0aC5taW4obmFtZS5sZW5ndGgsIG9wdC5taW53aWR0aCksIGwpO1xuICAgIHJldHVybiBvcHQubWF4d2lkdGggPiAwID8gTWF0aC5taW4obCwgb3B0Lm1heHdpZHRoKSA6IGw7XG4gIH0pO1xuXG4gIC8vIHByaW50IGhlYWRlciByb3dcbiAgdmFyIGhlYWQgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gdXRpbC50cnVuY2F0ZSh1dGlsLnBhZChuYW1lLCBsZW5zW2ldLCAnY2VudGVyJyksIGxlbnNbaV0pO1xuICB9KS5qb2luKG9wdC5zZXBhcmF0b3IpO1xuXG4gIC8vIGJ1aWxkIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciBlYWNoIHJvd1xuICB2YXIgdG1wbCA9IHRlbXBsYXRlKGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiAne3snICtcbiAgICAgIG5hbWUgK1xuICAgICAgKEZNVFt0eXBlc1tuYW1lXV0gfHwgJycpICtcbiAgICAgICgnfHBhZDonICsgbGVuc1tpXSArICcsJyArIChQT1NbdHlwZXNbbmFtZV1dIHx8ICdyaWdodCcpKSArXG4gICAgICAoJ3x0cnVuY2F0ZTonICsgbGVuc1tpXSkgK1xuICAgICd9fSc7XG4gIH0pLmpvaW4ob3B0LnNlcGFyYXRvcikpO1xuXG4gIC8vIHByaW50IHRhYmxlXG4gIHJldHVybiBoZWFkICsgXCJcXG5cIiArIGRhdGEubWFwKHRtcGwpLmpvaW4oJ1xcbicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3VtbWFyeSA9IGZ1bmN0aW9uKHMpIHtcbiAgcyA9IHMgPyBzLl9fc3VtbWFyeV9fID8gcyA6IHN0YXRzLnN1bW1hcnkocykgOiB0aGlzO1xuICB2YXIgc3RyID0gW10sIGksIG47XG4gIGZvciAoaT0wLCBuPXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHN0ci5wdXNoKCctLSAnICsgc1tpXS5maWVsZCArICcgLS0nKTtcbiAgICBpZiAoc1tpXS50eXBlID09PSAnc3RyaW5nJyB8fCBzW2ldLmRpc3RpbmN0IDwgMTApIHtcbiAgICAgIHN0ci5wdXNoKHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHNbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyLnB1c2gocHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHNbaV0pKTtcbiAgICB9XG4gICAgc3RyLnB1c2goJycpO1xuICB9XG4gIHJldHVybiBzdHIuam9pbignXFxuJyk7XG59O1xuXG5mdW5jdGlvbiBwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUocCkge1xuICByZXR1cm4gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ21pbjogICAgICAnICsgcC5taW4sXG4gICAgJ21heDogICAgICAnICsgcC5tYXgsXG4gICAgJ21lZGlhbjogICAnICsgcC5tZWRpYW4sXG4gICAgJ21lYW46ICAgICAnICsgcC5tZWFuLFxuICAgICdzdGRldjogICAgJyArIHAuc3RkZXYsXG4gICAgJ21vZGVza2V3OiAnICsgcC5tb2Rlc2tld1xuICBdLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmludENhdGVnb3JpY2FsUHJvZmlsZShwKSB7XG4gIHZhciBsaXN0ID0gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ3RvcCB2YWx1ZXM6ICdcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiAnIFxcJycgKyB2ICsgJ1xcJyAoJyArIHVbdl0gKyAnKSc7IH0pO1xuICByZXR1cm4gbGlzdC5jb25jYXQodG9wKS5qb2luKCdcXG4nKTtcbn0iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpO1xudmFyIHN0YXRzID0ge307XG5cbi8vIENvbGxlY3QgdW5pcXVlIHZhbHVlcy5cbi8vIE91dHB1dDogYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gZmlyc3Qtb2JzZXJ2ZWQgb3JkZXJcbnN0YXRzLnVuaXF1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcmVzdWx0cykge1xuICBmID0gdXRpbC4kKGYpO1xuICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICByZXN1bHRzLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgYXJyYXkuXG5zdGF0cy5jb3VudCA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggfHwgMDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2Ygbm9uLW51bGwsIG5vbi11bmRlZmluZWQsIG5vbi1OYU4gdmFsdWVzLlxuc3RhdHMuY291bnQudmFsaWQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIHZhbGlkID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB2YWxpZCArPSAxO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgbnVsbCBvciB1bmRlZmluZWQgdmFsdWVzLlxuc3RhdHMuY291bnQubWlzc2luZyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4vLyBOdWxsLCB1bmRlZmluZWQgYW5kIE5hTiBhcmUgZWFjaCBjb25zaWRlcmVkIGRpc3RpbmN0IHZhbHVlcy5cbnN0YXRzLmNvdW50LmRpc3RpbmN0ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB1ID0ge30sIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1hcCBmcm9tIGRpc3RpbmN0IHZhbHVlcyB0byBvY2N1cnJlbmNlIGNvdW50cy5cbnN0YXRzLmNvdW50Lm1hcCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWFwID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgbWFwW3ZdID0gKHYgaW4gbWFwKSA/IG1hcFt2XSArIDEgOiAxO1xuICB9XG4gIHJldHVybiBtYXA7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWRpYW4gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lZGlhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHJldHVybiBzdGF0cy5xdWFudGlsZSh2YWx1ZXMsIDAuNSk7XG59O1xuXG4vLyBDb21wdXRlcyB0aGUgcXVhcnRpbGUgYm91bmRhcmllcyBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMucXVhcnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICB2YXIgcSA9IHN0YXRzLnF1YW50aWxlO1xuICByZXR1cm4gW3EodmFsdWVzLCAwLjI1KSwgcSh2YWx1ZXMsIDAuNTApLCBxKHZhbHVlcywgMC43NSldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgcXVhbnRpbGUgb2YgYSBzb3J0ZWQgYXJyYXkgb2YgbnVtYmVycy5cbi8vIEFkYXB0ZWQgZnJvbSB0aGUgRDMuanMgaW1wbGVtZW50YXRpb24uXG5zdGF0cy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcCkge1xuICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7IHAgPSBmOyBmID0gdXRpbC5pZGVudGl0eTsgfVxuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgSCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwICsgMSxcbiAgICAgIGggPSBNYXRoLmZsb29yKEgpLFxuICAgICAgdiA9ICtmKHZhbHVlc1toIC0gMV0pLFxuICAgICAgZSA9IEggLSBoO1xuICByZXR1cm4gZSA/IHYgKyBlICogKGYodmFsdWVzW2hdKSAtIHYpIDogdjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHN1bSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3VtID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGZvciAodmFyIHN1bT0wLCBpPTAsIG49dmFsdWVzLmxlbmd0aCwgdjsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSBzdW0gKz0gdjtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVhbiAoYXZlcmFnZSkgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1lYW4gPSAwLCBkZWx0YSwgaSwgbiwgYywgdjtcbiAgZm9yIChpPTAsIGM9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHZhcmlhbmNlIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBNMiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWluID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVswXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5tYXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzFdO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBhbiBhcnJheSBvZiB2YWx1ZXMuXG5zdGF0cy5leHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHggPSAtMSwgeSA9IC0xLCBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IHggPSB5ID0gaTsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgICB9XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2ldICogYVtpXTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IGEodmFsdWVzW2ldKSAqIGIodmFsdWVzW2ldKTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgYXNjZW5kaW5nIHJhbmsgc2NvcmVzIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4vLyBUaWVzIGFyZSBhc3NpZ25lZCB0aGVpciBjb2xsZWN0aXZlIG1lYW4gcmFuay5cbnN0YXRzLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKSB8fCB1dGlsLmlkZW50aXR5O1xuICB2YXIgYSA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgcmV0dXJuIHtpZHg6IGksIHZhbDogZih2KX07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoJ3ZhbCcpKTtcblxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByID0gQXJyYXkobiksXG4gICAgICB0aWUgPSAtMSwgcCA9IHt9LCBpLCB2LCBtdTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gYVtpXS52YWw7XG4gICAgaWYgKHRpZSA8IDAgJiYgcCA9PT0gdikge1xuICAgICAgdGllID0gaSAtIDE7XG4gICAgfSBlbHNlIGlmICh0aWUgPiAtMSAmJiBwICE9PSB2KSB7XG4gICAgICBtdSA9IDEgKyAoaS0xICsgdGllKSAvIDI7XG4gICAgICBmb3IgKDsgdGllPGk7ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gICAgICB0aWUgPSAtMTtcbiAgICB9XG4gICAgclthW2ldLmlkeF0gPSBpICsgMTtcbiAgICBwID0gdjtcbiAgfVxuXG4gIGlmICh0aWUgPiAtMSkge1xuICAgIG11ID0gMSArIChuLTEgKyB0aWUpIC8gMjtcbiAgICBmb3IgKDsgdGllPG47ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBQZWFyc29uIHByb2R1Y3QtbW9tZW50IGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmNvciA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgZm4gPSBiO1xuICBiID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuICBhID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXM7XG5cbiAgdmFyIGRvdCA9IHN0YXRzLmRvdChhLCBiKSxcbiAgICAgIG11YSA9IHN0YXRzLm1lYW4oYSksXG4gICAgICBtdWIgPSBzdGF0cy5tZWFuKGIpLFxuICAgICAgc2RhID0gc3RhdHMuc3RkZXYoYSksXG4gICAgICBzZGIgPSBzdGF0cy5zdGRldihiKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHJldHVybiAoZG90IC0gbiptdWEqbXViKSAvICgobi0xKSAqIHNkYSAqIHNkYik7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTcGVhcm1hbiByYW5rIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgdmFsdWVzLlxuc3RhdHMuY29yLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHJhID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYSkpIDogc3RhdHMucmFuayh2YWx1ZXMpLFxuICAgICAgcmIgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChiKSkgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuXG4gIHZhciBBID0gc3RhdHMuZGlzdC5tYXQoWCksXG4gICAgICBCID0gc3RhdHMuZGlzdC5tYXQoWSksXG4gICAgICBuID0gQS5sZW5ndGgsXG4gICAgICBpLCBhYSwgYmIsIGFiO1xuXG4gIGZvciAoaT0wLCBhYT0wLCBiYj0wLCBhYj0wOyBpPG47ICsraSkge1xuICAgIGFhICs9IEFbaV0qQVtpXTtcbiAgICBiYiArPSBCW2ldKkJbaV07XG4gICAgYWIgKz0gQVtpXSpCW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChhYiAvIE1hdGguc3FydChhYSpiYikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgdmVjdG9yIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gRGVmYXVsdCBpcyBFdWNsaWRlYW4gKGV4cD0yKSBkaXN0YW5jZSwgY29uZmlndXJhYmxlIHZpYSBleHAgYXJndW1lbnQuXG5zdGF0cy5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBleHApIHtcbiAgdmFyIGYgPSB1dGlsLmlzRnVuY3Rpb24oYikgfHwgdXRpbC5pc1N0cmluZyhiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBMMiA9IGUgPT09IDIgfHwgZSA9PSBudWxsLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIHMgPSAwLCBkLCBpO1xuICBpZiAoZikge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgfVxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgcyArPSBMMiA/IGQqZCA6IE1hdGgucG93KE1hdGguYWJzKGQpLCBlKTtcbiAgfVxuICByZXR1cm4gTDIgPyBNYXRoLnNxcnQocykgOiBNYXRoLnBvdyhzLCAxL2UpO1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHApIEggKz0gcCAqIE1hdGgubG9nKHApO1xuICB9XG4gIHJldHVybiAtSCAvIE1hdGguTE4yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gW01JLCBNSV9kaXN0YW5jZV0gXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011dHVhbF9pbmZvcm1hdGlvblxuc3RhdHMubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICB5ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIHogPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChjb3VudHMpKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG4gICAgICBweSA9IHt9LFxuICAgICAgbiA9IHoubGVuZ3RoLFxuICAgICAgcyA9IDAsIEkgPSAwLCBIID0gMCwgcCwgdCwgaTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSA9IDA7XG4gICAgcHlbeVtpXV0gPSAwO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gKz0geltpXTtcbiAgICBweVt5W2ldXSArPSB6W2ldO1xuICAgIHMgKz0geltpXTtcbiAgfVxuXG4gIHQgPSAxIC8gKHMgKiBNYXRoLkxOMik7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGlmICh6W2ldID09PSAwKSBjb250aW51ZTtcbiAgICBwID0gKHMgKiB6W2ldKSAvIChweFt4W2ldXSAqIHB5W3lbaV1dKTtcbiAgICBJICs9IHpbaV0gKiB0ICogTWF0aC5sb2cocCk7XG4gICAgSCArPSB6W2ldICogdCAqIE1hdGgubG9nKHpbaV0vcyk7XG4gIH1cblxuICByZXR1cm4gW0ksIDEgKyBJL0hdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbnN0YXRzLm11dHVhbC5pbmZvID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuc3RhdHMubXV0dWFsLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVsxXTtcbn07XG5cbi8vIENvbXB1dGUgYSBwcm9maWxlIG9mIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSB2YXJpYWJsZS5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIG1lYW4gPSAwLFxuICAgICAgdmFsaWQgPSAwLFxuICAgICAgbWlzc2luZyA9IDAsXG4gICAgICBkaXN0aW5jdCA9IDAsXG4gICAgICBtaW4gPSBudWxsLFxuICAgICAgbWF4ID0gbnVsbCxcbiAgICAgIE0yID0gMCxcbiAgICAgIHZhbHMgPSBbXSxcbiAgICAgIHUgPSB7fSwgZGVsdGEsIHNkLCBpLCB2LCB4O1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcblxuICAgIC8vIHVwZGF0ZSB1bmlxdWUgdmFsdWVzXG4gICAgdVt2XSA9ICh2IGluIHUpID8gdVt2XSArIDEgOiAoZGlzdGluY3QgKz0gMSwgMSk7XG5cbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICArK21pc3Npbmc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgICAgeCA9ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpID8gdi5sZW5ndGggOiB2O1xuICAgICAgaWYgKG1pbj09PW51bGwgfHwgeCA8IG1pbikgbWluID0geDtcbiAgICAgIGlmIChtYXg9PT1udWxsIHx8IHggPiBtYXgpIG1heCA9IHg7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK3ZhbGlkKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAodmFsaWQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogICAgIHR5cGUodmFsdWVzLCBmKSxcbiAgICB1bmlxdWU6ICAgdSxcbiAgICBjb3VudDogICAgdmFsdWVzLmxlbmd0aCxcbiAgICB2YWxpZDogICAgdmFsaWQsXG4gICAgbWlzc2luZzogIG1pc3NpbmcsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgcTE6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLFxuICAgIHEzOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KSxcbiAgICBtb2Rlc2tldzogc2QgPT09IDAgPyAwIDogKG1lYW4gLSB2KSAvIHNkXG4gIH07XG59O1xuXG4vLyBDb21wdXRlIHByb2ZpbGVzIGZvciBhbGwgdmFyaWFibGVzIGluIGEgZGF0YSBzZXQuXG5zdGF0cy5zdW1tYXJ5ID0gZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHZhciBzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuJChmKSk7XG4gICAgcmV0dXJuIChwLmZpZWxkID0gZiwgcCk7XG4gIH0pO1xuICByZXR1cm4gKHMuX19zdW1tYXJ5X18gPSB0cnVlLCBzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBmb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuXG52YXIgY29udGV4dCA9IHtcbiAgZm9ybWF0czogICAgW10sXG4gIGZvcm1hdF9tYXA6IHt9LFxuICB0cnVuY2F0ZTogICB1dGlsLnRydW5jYXRlLFxuICBwYWQ6ICAgICAgICB1dGlsLnBhZFxufTtcblxuZnVuY3Rpb24gdGVtcGxhdGUodGV4dCkge1xuICB2YXIgc3JjID0gc291cmNlKHRleHQsICdkJyk7XG4gIHNyYyA9ICd2YXIgX190OyByZXR1cm4gJyArIHNyYyArICc7JztcblxuICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuICByZXR1cm4gKG5ldyBGdW5jdGlvbignZCcsIHNyYykpLmJpbmQoY29udGV4dCk7XG59XG5cbnRlbXBsYXRlLnNvdXJjZSA9IHNvdXJjZTtcbnRlbXBsYXRlLmNvbnRleHQgPSBjb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcblxuLy8gQ2xlYXIgY2FjaGUgb2YgZm9ybWF0IG9iamVjdHMuXG4vLyBUaGlzIGNhbiAqYnJlYWsqIHByaW9yIHRlbXBsYXRlIGZ1bmN0aW9ucywgc28gaW52b2tlIHdpdGggY2FyZSFcbnRlbXBsYXRlLmNsZWFyRm9ybWF0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY29udGV4dC5mb3JtYXRzID0gW107XG4gIGNvbnRleHQuZm9ybWF0X21hcCA9IHt9O1xufTtcblxuLy8gR2VuZXJhdGUgcHJvcGVydHkgYWNjZXNzIGNvZGUgZm9yIHVzZSB3aXRoaW4gdGVtcGxhdGUgc291cmNlLlxuLy8gb2JqZWN0OiB0aGUgbmFtZSBvZiB0aGUgb2JqZWN0ICh2YXJpYWJsZSkgY29udGFpbmluZyB0ZW1wbGF0ZSBkYXRhXG4vLyBwcm9wZXJ0eTogdGhlIHByb3BlcnR5IGFjY2VzcyBzdHJpbmcsIHZlcmJhdGltIGZyb20gdGVtcGxhdGUgdGFnXG50ZW1wbGF0ZS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIHNyYyA9IHV0aWwuZmllbGQocHJvcGVydHkpLm1hcCh1dGlsLnN0cikuam9pbignXVsnKTtcbiAgcmV0dXJuIG9iamVjdCArICdbJyArIHNyYyArICddJztcbn07XG5cbi8vIEdlbmVyYXRlIHNvdXJjZSBjb2RlIGZvciBhIHRlbXBsYXRlIGZ1bmN0aW9uLlxuLy8gdGV4dDogdGhlIHRlbXBsYXRlIHRleHRcbi8vIHZhcmlhYmxlOiB0aGUgbmFtZSBvZiB0aGUgZGF0YSBvYmplY3QgdmFyaWFibGUgKCdvYmonIGJ5IGRlZmF1bHQpXG4vLyBwcm9wZXJ0aWVzOiBvcHRpb25hbCBoYXNoIGZvciBjb2xsZWN0aW5nIGFsbCBhY2Nlc3NlZCBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBzb3VyY2UodGV4dCwgdmFyaWFibGUsIHByb3BlcnRpZXMpIHtcbiAgdmFyaWFibGUgPSB2YXJpYWJsZSB8fCAnb2JqJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHNyYyA9ICdcXCcnO1xuICB2YXIgcmVnZXggPSB0ZW1wbGF0ZV9yZTtcblxuICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICB0ZXh0LnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBpbnRlcnBvbGF0ZSwgb2Zmc2V0KSB7XG4gICAgc3JjICs9IHRleHRcbiAgICAgIC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgLnJlcGxhY2UodGVtcGxhdGVfZXNjYXBlciwgdGVtcGxhdGVfZXNjYXBlQ2hhcik7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgIHNyYyArPSAnXFwnXFxuKygoX190PSgnICtcbiAgICAgICAgdGVtcGxhdGVfdmFyKGludGVycG9sYXRlLCB2YXJpYWJsZSwgcHJvcGVydGllcykgK1xuICAgICAgICAnKSk9PW51bGw/XFwnXFwnOl9fdCkrXFxuXFwnJztcbiAgICB9XG5cbiAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcbiAgcmV0dXJuIHNyYyArICdcXCcnO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZV92YXIodGV4dCwgdmFyaWFibGUsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGZpbHRlcnMgPSB0ZXh0Lm1hdGNoKGZpbHRlcl9yZSk7XG4gIHZhciBwcm9wID0gZmlsdGVycy5zaGlmdCgpLnRyaW0oKTtcbiAgdmFyIHN0cmluZ0Nhc3QgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHN0cmNhbGwoZm4pIHtcbiAgICBmbiA9IGZuIHx8ICcnO1xuICAgIGlmIChzdHJpbmdDYXN0KSB7XG4gICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICBzcmMgPSAnU3RyaW5nKCcgKyBzcmMgKyAnKScgKyBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjICs9IGZuO1xuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG5cbiAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gJyh0eXBlb2YgJyArIHNyYyArICc9PT1cIm51bWJlclwiP25ldyBEYXRlKCcrc3JjKycpOicrc3JjKycpJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG51bWJlcl9mb3JtYXQoZm10LCBrZXkpIHtcbiAgICBhID0gdGVtcGxhdGVfZm9ybWF0KGFyZ3NbMF0sIGtleSwgZm10KTtcbiAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgc3JjID0gJ3RoaXMuZm9ybWF0c1snK2ErJ10oJytzcmMrJyknO1xuICB9XG4gIFxuICBmdW5jdGlvbiB0aW1lX2Zvcm1hdChmbXQsIGtleSkge1xuICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwga2V5LCBmbXQpO1xuICAgIHN0cmluZ0Nhc3QgPSBmYWxzZTtcbiAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK2RhdGUoKSsnKSc7XG4gIH1cblxuICBpZiAocHJvcGVydGllcykgcHJvcGVydGllc1twcm9wXSA9IDE7XG4gIHZhciBzcmMgPSB0ZW1wbGF0ZS5wcm9wZXJ0eSh2YXJpYWJsZSwgcHJvcCk7XG5cbiAgZm9yICh2YXIgaT0wOyBpPGZpbHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IGZpbHRlcnNbaV0sIGFyZ3MgPSBudWxsLCBwaWR4LCBhLCBiO1xuXG4gICAgaWYgKChwaWR4PWYuaW5kZXhPZignOicpKSA+IDApIHtcbiAgICAgIGYgPSBmLnNsaWNlKDAsIHBpZHgpO1xuICAgICAgYXJncyA9IGZpbHRlcnNbaV0uc2xpY2UocGlkeCsxKVxuICAgICAgICAubWF0Y2goYXJnc19yZSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfSk7XG4gICAgfVxuICAgIGYgPSBmLnRyaW0oKTtcblxuICAgIHN3aXRjaCAoZikge1xuICAgICAgY2FzZSAnbGVuZ3RoJzpcbiAgICAgICAgc3RyY2FsbCgnLmxlbmd0aCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG93ZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cHBlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b1VwcGVyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbG93ZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlTG93ZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cHBlci1sb2NhbGUnOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb2NhbGVVcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RyaW0nOlxuICAgICAgICBzdHJjYWxsKCcudHJpbSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKDAsJyArIGEgKyAnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoLScgKyBhICsnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGEgKyB1dGlsLm51bWJlcihhcmdzWzFdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKCsnK2ErJywnK2IrJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzbGljZSc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKCcrIGEgK1xuICAgICAgICAgIChhcmdzLmxlbmd0aCA+IDEgPyAnLCcgKyB1dGlsLm51bWJlcihhcmdzWzFdKSA6ICcnKSArXG4gICAgICAgICAgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cnVuY2F0ZSc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGFyZ3NbMV07XG4gICAgICAgIGIgPSAoYiE9PSdsZWZ0JyAmJiBiIT09J21pZGRsZScgJiYgYiE9PSdjZW50ZXInKSA/ICdyaWdodCcgOiBiO1xuICAgICAgICBzcmMgPSAndGhpcy50cnVuY2F0ZSgnICsgc3RyY2FsbCgpICsgJywnICsgYSArICcsXFwnJyArIGIgKyAnXFwnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFkJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYXJnc1sxXTtcbiAgICAgICAgYiA9IChiIT09J2xlZnQnICYmIGIhPT0nbWlkZGxlJyAmJiBiIT09J2NlbnRlcicpID8gJ3JpZ2h0JyA6IGI7XG4gICAgICAgIHNyYyA9ICd0aGlzLnBhZCgnICsgc3RyY2FsbCgpICsgJywnICsgYSArICcsXFwnJyArIGIgKyAnXFwnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgbnVtYmVyX2Zvcm1hdChmb3JtYXQubnVtYmVyLCAnbnVtYmVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIHRpbWVfZm9ybWF0KGZvcm1hdC50aW1lLCAndGltZScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbWUtdXRjJzpcbiAgICAgICAgdGltZV9mb3JtYXQoZm9ybWF0LnV0YywgJ3RpbWUtdXRjJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCB0ZW1wbGF0ZSBmaWx0ZXI6ICcgKyBmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuXG52YXIgdGVtcGxhdGVfcmUgPSAvXFx7XFx7KC4rPylcXH1cXH18JC9nLFxuICAgIGZpbHRlcl9yZSA9IC8oPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8W15cXHxcIl0rfFteXFx8XFwnXSspKy9nLFxuICAgIGFyZ3NfcmUgPSAvKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFteLFwiXSt8W14sXFwnXSspKy9nO1xuXG4vLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuLy8gc3RyaW5nIGxpdGVyYWwuXG52YXIgdGVtcGxhdGVfZXNjYXBlcyA9IHtcbiAgJ1xcJyc6ICAgICAnXFwnJyxcbiAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAnXFxyJzogICAgICdyJyxcbiAgJ1xcbic6ICAgICAnbicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG52YXIgdGVtcGxhdGVfZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuZnVuY3Rpb24gdGVtcGxhdGVfZXNjYXBlQ2hhcihtYXRjaCkge1xuICByZXR1cm4gJ1xcXFwnICsgdGVtcGxhdGVfZXNjYXBlc1ttYXRjaF07XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX2Zvcm1hdChwYXR0ZXJuLCBrZXksIGZtdCkge1xuICBpZiAoKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcXCcnKSB8fFxuICAgICAgKHBhdHRlcm5bMF0gPT09ICdcIicgICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcIicpKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKCdGb3JtYXQgcGF0dGVybiBtdXN0IGJlIHF1b3RlZDogJyArIHBhdHRlcm4pO1xuICB9XG4gIGtleSA9IGtleSArICc6JyArIHBhdHRlcm47XG4gIGlmICghY29udGV4dC5mb3JtYXRfbWFwW2tleV0pIHtcbiAgICB2YXIgZiA9IGZtdChwYXR0ZXJuKTtcbiAgICB2YXIgaSA9IGNvbnRleHQuZm9ybWF0cy5sZW5ndGg7XG4gICAgY29udGV4dC5mb3JtYXRzLnB1c2goZik7XG4gICAgY29udGV4dC5mb3JtYXRfbWFwW2tleV0gPSBpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZvcm1hdF9tYXBba2V5XTtcbn1cbiIsInZhciBkM190aW1lID0gcmVxdWlyZSgnZDMtdGltZScpO1xuXG52YXIgdGVtcERhdGUgPSBuZXcgRGF0ZSgpLFxuICAgIGJhc2VEYXRlID0gbmV3IERhdGUoMCwgMCwgMSkuc2V0RnVsbFllYXIoMCksIC8vIEphbiAxLCAwIEFEXG4gICAgdXRjQmFzZURhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygwLCAwLCAxKSkuc2V0VVRDRnVsbFllYXIoMCk7XG5cbmZ1bmN0aW9uIGRhdGUoZCkge1xuICByZXR1cm4gKHRlbXBEYXRlLnNldFRpbWUoK2QpLCB0ZW1wRGF0ZSk7XG59XG5cbi8vIGNyZWF0ZSBhIHRpbWUgdW5pdCBlbnRyeVxuZnVuY3Rpb24gZW50cnkodHlwZSwgZGF0ZSwgdW5pdCwgc3RlcCwgbWluLCBtYXgpIHtcbiAgdmFyIGUgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRlOiBkYXRlLFxuICAgIHVuaXQ6IHVuaXRcbiAgfTtcbiAgaWYgKHN0ZXApIHtcbiAgICBlLnN0ZXAgPSBzdGVwO1xuICB9IGVsc2Uge1xuICAgIGUubWluc3RlcCA9IDE7XG4gIH1cbiAgaWYgKG1pbiAhPSBudWxsKSBlLm1pbiA9IG1pbjtcbiAgaWYgKG1heCAhPSBudWxsKSBlLm1heCA9IG1heDtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlLCB1bml0LCBiYXNlLCBzdGVwLCBtaW4sIG1heCkge1xuICByZXR1cm4gZW50cnkodHlwZSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0Lm9mZnNldChiYXNlLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0LmNvdW50KGJhc2UsIGQpOyB9LFxuICAgIHN0ZXAsIG1pbiwgbWF4KTtcbn1cblxudmFyIGxvY2FsZSA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnNlY29uZCwgYmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUubWludXRlLCBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS5ob3VyLCAgIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLmRheSwgICAgYmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS5tb250aCwgIGJhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUueWVhciwgICBiYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0U2Vjb25kcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdtaW51dGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldE1pbnV0ZXMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnaG91cnMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0SG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDQrZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXREYXkoKTsgfSxcbiAgICBbMV0sIDAsIDZcbiAgKSxcbiAgZW50cnkoJ2RhdGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldERhdGUoKTsgfSxcbiAgICBbMV0sIDEsIDMxXG4gICksXG4gIGVudHJ5KCdtb250aHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIGQgJSAxMiwgMSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIHV0YyA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnV0Y1NlY29uZCwgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUudXRjTWludXRlLCB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS51dGNIb3VyLCAgIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLnV0Y0RheSwgICAgdXRjQmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS51dGNNb250aCwgIHV0Y0Jhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUudXRjWWVhciwgICB1dGNCYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ1NlY29uZHMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnbWludXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDTWludXRlcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdob3VycycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDSG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDQrZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF5KCk7IH0sXG4gICAgWzFdLCAwLCA2XG4gICksXG4gIGVudHJ5KCdkYXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF0ZSgpOyB9LFxuICAgIFsxXSwgMSwgMzFcbiAgKSxcbiAgZW50cnkoJ21vbnRocycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgZCAlIDEyLCAxKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIFNURVBTID0gW1xuICBbMzE1MzZlNiwgNV0sICAvLyAxLXllYXJcbiAgWzc3NzZlNiwgNF0sICAgLy8gMy1tb250aFxuICBbMjU5MmU2LCA0XSwgICAvLyAxLW1vbnRoXG4gIFsxMjA5NmU1LCAzXSwgIC8vIDItd2Vla1xuICBbNjA0OGU1LCAzXSwgICAvLyAxLXdlZWtcbiAgWzE3MjhlNSwgM10sICAgLy8gMi1kYXlcbiAgWzg2NGU1LCAzXSwgICAgLy8gMS1kYXlcbiAgWzQzMmU1LCAyXSwgICAgLy8gMTItaG91clxuICBbMjE2ZTUsIDJdLCAgICAvLyA2LWhvdXJcbiAgWzEwOGU1LCAyXSwgICAgLy8gMy1ob3VyXG4gIFszNmU1LCAyXSwgICAgIC8vIDEtaG91clxuICBbMThlNSwgMV0sICAgICAvLyAzMC1taW51dGVcbiAgWzllNSwgMV0sICAgICAgLy8gMTUtbWludXRlXG4gIFszZTUsIDFdLCAgICAgIC8vIDUtbWludXRlXG4gIFs2ZTQsIDFdLCAgICAgIC8vIDEtbWludXRlXG4gIFszZTQsIDBdLCAgICAgIC8vIDMwLXNlY29uZFxuICBbMTVlMywgMF0sICAgICAvLyAxNS1zZWNvbmRcbiAgWzVlMywgMF0sICAgICAgLy8gNS1zZWNvbmRcbiAgWzFlMywgMF0gICAgICAgLy8gMS1zZWNvbmRcbl07XG5cbmZ1bmN0aW9uIGZpbmQodW5pdHMsIHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgdmFyIHN0ZXAgPSBTVEVQU1swXSwgaSwgbiwgYmlucztcblxuICBmb3IgKGk9MSwgbj1TVEVQUy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgc3RlcCA9IFNURVBTW2ldO1xuICAgIGlmIChzcGFuID4gc3RlcFswXSkge1xuICAgICAgYmlucyA9IHNwYW4gLyBzdGVwWzBdO1xuICAgICAgaWYgKGJpbnMgPiBtYXhiKSB7XG4gICAgICAgIHJldHVybiB1bml0c1tTVEVQU1tpLTFdWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5zID49IG1pbmIpIHtcbiAgICAgICAgcmV0dXJuIHVuaXRzW3N0ZXBbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5pdHNbU1RFUFNbbi0xXVsxXV07XG59XG5cbmZ1bmN0aW9uIHRvVW5pdE1hcCh1bml0cykge1xuICB2YXIgbWFwID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPXVuaXRzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBtYXBbdW5pdHNbaV0udHlwZV0gPSB1bml0c1tpXTtcbiAgfVxuICBtYXAuZmluZCA9IGZ1bmN0aW9uKHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgICByZXR1cm4gZmluZCh1bml0cywgc3BhbiwgbWluYiwgbWF4Yik7XG4gIH07XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Vbml0TWFwKGxvY2FsZSk7XG5tb2R1bGUuZXhwb3J0cy51dGMgPSB0b1VuaXRNYXAodXRjKTtcbiIsInZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gICAgdXRjID0gdGltZS51dGM7XG5cbnZhciB1ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIEZOQU1FID0gJ19fbmFtZV9fJztcblxudS5uYW1lZGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBmKSB7IHJldHVybiAoZltGTkFNRV0gPSBuYW1lLCBmKTsgfTtcblxudS5uYW1lID0gZnVuY3Rpb24oZikgeyByZXR1cm4gZj09bnVsbCA/IG51bGwgOiBmW0ZOQU1FXTsgfTtcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IHUubmFtZWRmdW5jKCd0cnVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblxudS5mYWxzZSA9IHUubmFtZWRmdW5jKCdmYWxzZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuXG51LmR1cGxpY2F0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnUuZXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYik7XG59O1xuXG51LmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciB4LCBuYW1lLCBpPTEsIGxlbj1hcmd1bWVudHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKG5hbWUgaW4geCkgeyBvYmpbbmFtZV0gPSB4W25hbWVdOyB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbnUubGVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHgubGVuZ3RoICE9IG51bGwgPyB4Lmxlbmd0aCA6IG51bGw7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0LCBmKSB7XG4gIHJldHVybiAoZiA9IHUuJChmKSkgP1xuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialtmKHgpXSA9IDEsIG9iaik7IH0sIHt9KSA6XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW3hdID0gMSwgb2JqKTsgfSwge30pO1xufTtcblxudS5rZXlzdHIgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgLy8gdXNlIHRvIGVuc3VyZSBjb25zaXN0ZW50IGtleSBnZW5lcmF0aW9uIGFjcm9zcyBtb2R1bGVzXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgaWYgKCFuKSByZXR1cm4gJyc7XG4gIGZvciAodmFyIHM9U3RyaW5nKHZhbHVlc1swXSksIGk9MTsgaTxuOyArK2kpIHtcbiAgICBzICs9ICd8JyArIFN0cmluZyh2YWx1ZXNbaV0pO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLy8gdHlwZSBjaGVja2luZyBmdW5jdGlvbnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnUuaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmo7XG59O1xuXG51LmlzQnVmZmVyID0gKGJ1ZmZlci5CdWZmZXIgJiYgYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogK3M7XG59O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhcztcbn07XG5cbnUuZGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBEYXRlLnBhcnNlKHMpO1xufTtcblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdO1xufTtcblxudS5zdHIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB1LmlzQXJyYXkoeCkgPyAnWycgKyB4Lm1hcCh1LnN0cikgKyAnXSdcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/ICgnXFwnJyt1dGlsX2VzY2FwZV9zdHIoeCkrJ1xcJycpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsICckMVxcXFxcXCcnKTtcbn1cblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnZhciBmaWVsZF9yZSA9IC9cXFsoLio/KVxcXXxbXi5cXFtdKy9nO1xuXG51LmZpZWxkID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gU3RyaW5nKGYpLm1hdGNoKGZpZWxkX3JlKS5tYXAoZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkWzBdICE9PSAnWycgPyBkIDpcbiAgICAgIGRbMV0gIT09IFwiJ1wiICYmIGRbMV0gIT09ICdcIicgPyBkLnNsaWNlKDEsIC0xKSA6XG4gICAgICBkLnNsaWNlKDIsIC0yKS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLCAnJDEnKTtcbiAgfSk7XG59O1xuXG51LmFjY2Vzc29yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIGY9PW51bGwgfHwgdS5pc0Z1bmN0aW9uKGYpID8gZiA6XG4gICAgdS5uYW1lZGZ1bmMoZiwgKHMgPSB1LmZpZWxkKGYpKS5sZW5ndGggPiAxID9cbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHMucmVkdWNlKGZ1bmN0aW9uKHgsZikgeyByZXR1cm4geFtmXTsgfSwgeCk7IH0gOlxuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4geFtmXTsgfVxuICAgICk7XG59O1xuXG4vLyBzaG9ydC1jdXQgZm9yIGFjY2Vzc29yXG51LiQgPSB1LmFjY2Vzc29yO1xuXG51Lm11dGF0b3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gdS5pc1N0cmluZyhmKSAmJiAocz11LmZpZWxkKGYpKS5sZW5ndGggPiAxID9cbiAgICBmdW5jdGlvbih4LCB2KSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8cy5sZW5ndGgtMTsgKytpKSB4ID0geFtzW2ldXTtcbiAgICAgIHhbc1tpXV0gPSB2O1xuICAgIH0gOlxuICAgIGZ1bmN0aW9uKHgsIHYpIHsgeFtmXSA9IHY7IH07XG59O1xuXG5cbnUuJGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBvcCkge1xuICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgIGYgPSB1LiQoZikgfHwgdS5pZGVudGl0eTtcbiAgICB2YXIgbiA9IG5hbWUgKyAodS5uYW1lKGYpID8gJ18nK3UubmFtZShmKSA6ICcnKTtcbiAgICByZXR1cm4gdS5uYW1lZGZ1bmMobiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gb3AoZihkKSk7IH0pO1xuICB9O1xufTtcblxudS4kdmFsaWQgID0gdS4kZnVuYygndmFsaWQnLCB1LmlzVmFsaWQpO1xudS4kbGVuZ3RoID0gdS4kZnVuYygnbGVuZ3RoJywgdS5sZW5ndGgpO1xuXG51LiRpbiA9IGZ1bmN0aW9uKGYsIHZhbHVlcykge1xuICBmID0gdS4kKGYpO1xuICB2YXIgbWFwID0gdS5pc0FycmF5KHZhbHVlcykgPyB1LnRvTWFwKHZhbHVlcykgOiB2YWx1ZXM7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7IHJldHVybiAhIW1hcFtmKGQpXTsgfTtcbn07XG5cbnUuJHllYXIgICA9IHUuJGZ1bmMoJ3llYXInLCB0aW1lLnllYXIudW5pdCk7XG51LiRtb250aCAgPSB1LiRmdW5jKCdtb250aCcsIHRpbWUubW9udGhzLnVuaXQpO1xudS4kZGF0ZSAgID0gdS4kZnVuYygnZGF0ZScsIHRpbWUuZGF0ZXMudW5pdCk7XG51LiRkYXkgICAgPSB1LiRmdW5jKCdkYXknLCB0aW1lLndlZWtkYXlzLnVuaXQpO1xudS4kaG91ciAgID0gdS4kZnVuYygnaG91cicsIHRpbWUuaG91cnMudW5pdCk7XG51LiRtaW51dGUgPSB1LiRmdW5jKCdtaW51dGUnLCB0aW1lLm1pbnV0ZXMudW5pdCk7XG51LiRzZWNvbmQgPSB1LiRmdW5jKCdzZWNvbmQnLCB0aW1lLnNlY29uZHMudW5pdCk7XG5cbnUuJHV0Y1llYXIgICA9IHUuJGZ1bmMoJ3V0Y1llYXInLCB1dGMueWVhci51bml0KTtcbnUuJHV0Y01vbnRoICA9IHUuJGZ1bmMoJ3V0Y01vbnRoJywgdXRjLm1vbnRocy51bml0KTtcbnUuJHV0Y0RhdGUgICA9IHUuJGZ1bmMoJ3V0Y0RhdGUnLCB1dGMuZGF0ZXMudW5pdCk7XG51LiR1dGNEYXkgICAgPSB1LiRmdW5jKCd1dGNEYXknLCB1dGMud2Vla2RheXMudW5pdCk7XG51LiR1dGNIb3VyICAgPSB1LiRmdW5jKCd1dGNIb3VyJywgdXRjLmhvdXJzLnVuaXQpO1xudS4kdXRjTWludXRlID0gdS4kZnVuYygndXRjTWludXRlJywgdXRjLm1pbnV0ZXMudW5pdCk7XG51LiR1dGNTZWNvbmQgPSB1LiRmdW5jKCd1dGNTZWNvbmQnLCB1dGMuc2Vjb25kcy51bml0KTtcblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSAnLScpIHsgcyA9IC0xOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIGVsc2UgaWYgKGZbMF0gPT09ICcrJykgeyBzID0gKzE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgc2lnbi5wdXNoKHMpO1xuICAgIHJldHVybiB1LmFjY2Vzc29yKGYpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBpLCBuLCBmLCB4LCB5O1xuICAgIGZvciAoaT0wLCBuPXNvcnQubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgZiA9IHNvcnRbaV07IHggPSBmKGEpOyB5ID0gZihiKTtcbiAgICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xICogc2lnbltpXTtcbiAgICAgIGlmICh4ID4geSkgcmV0dXJuIHNpZ25baV07XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufTtcblxudS5jbXAgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGEgPj0gYikge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBOYU47XG59O1xuXG51Lm51bWNtcCA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuXG51LnN0YWJsZXNvcnQgPSBmdW5jdGlvbihhcnJheSwgc29ydEJ5LCBrZXlGbikge1xuICB2YXIgaW5kaWNlcyA9IGFycmF5LnJlZHVjZShmdW5jdGlvbihpZHgsIHYsIGkpIHtcbiAgICByZXR1cm4gKGlkeFtrZXlGbih2KV0gPSBpLCBpZHgpO1xuICB9LCB7fSk7XG5cbiAgYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHNhID0gc29ydEJ5KGEpLFxuICAgICAgICBzYiA9IHNvcnRCeShiKTtcbiAgICByZXR1cm4gc2EgPCBzYiA/IC0xIDogc2EgPiBzYiA/IDFcbiAgICAgICAgIDogKGluZGljZXNba2V5Rm4oYSldIC0gaW5kaWNlc1trZXlGbihiKV0pO1xuICB9KTtcblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5cbi8vIHN0cmluZyBmdW5jdGlvbnNcblxudS5wYWQgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgcGFkY2hhcikge1xuICBwYWRjaGFyID0gcGFkY2hhciB8fCBcIiBcIjtcbiAgdmFyIGQgPSBsZW5ndGggLSBzLmxlbmd0aDtcbiAgaWYgKGQgPD0gMCkgcmV0dXJuIHM7XG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gc3RycmVwKGQsIHBhZGNoYXIpICsgcztcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICByZXR1cm4gc3RycmVwKE1hdGguZmxvb3IoZC8yKSwgcGFkY2hhcikgK1xuICAgICAgICAgcyArIHN0cnJlcChNYXRoLmNlaWwoZC8yKSwgcGFkY2hhcik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzICsgc3RycmVwKGQsIHBhZGNoYXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJyZXAobiwgc3RyKSB7XG4gIHZhciBzID0gXCJcIiwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBzICs9IHN0cjtcbiAgcmV0dXJuIHM7XG59XG5cbnUudHJ1bmNhdGUgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgd29yZCwgZWxsaXBzaXMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IGxlbmd0aCkgcmV0dXJuIHM7XG4gIGVsbGlwc2lzID0gZWxsaXBzaXMgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhlbGxpcHNpcykgOiAnXFx1MjAyNic7XG4gIHZhciBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZWxsaXBzaXMubGVuZ3RoKTtcblxuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwsMSkgOiBzLnNsaWNlKGxlbi1sKSk7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdmFyIGwxID0gTWF0aC5jZWlsKGwvMiksIGwyID0gTWF0aC5mbG9vcihsLzIpO1xuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMSkgOiBzLnNsaWNlKDAsbDEpKSArXG4gICAgICAgIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwyLDEpIDogcy5zbGljZShsZW4tbDIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsKSA6IHMuc2xpY2UoMCxsKSkgKyBlbGxpcHNpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJ1bmNhdGVPbldvcmQocywgbGVuLCByZXYpIHtcbiAgdmFyIGNudCA9IDAsIHRvayA9IHMuc3BsaXQodHJ1bmNhdGVfd29yZF9yZSk7XG4gIGlmIChyZXYpIHtcbiAgICBzID0gKHRvayA9IHRvay5yZXZlcnNlKCkpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSlcbiAgICAgIC5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcyA9IHRvay5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KTtcbiAgfVxuICByZXR1cm4gcy5sZW5ndGggPyBzLmpvaW4oJycpLnRyaW0oKSA6IHRva1swXS5zbGljZSgwLCBsZW4pO1xufVxuXG52YXIgdHJ1bmNhdGVfd29yZF9yZSA9IC8oW1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUyMDI4XFx1MjAyOVxcdTMwMDBcXHVGRUZGXSkvO1xuIiwidmFyIHRzID0gRGF0ZS5ub3coKTtcblxuZnVuY3Rpb24gd3JpdGUobXNnKSB7XG4gIG1zZyA9ICdbVmVnYSBMb2ddICcgKyBtc2c7XG4gIGNvbnNvbGUubG9nKG1zZyk7XG59XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBtc2cgPSAnW1ZlZ2EgRXJyXSAnICsgbXNnO1xuICBjb25zb2xlLmVycm9yKG1zZyk7XG59XG5cbmZ1bmN0aW9uIGRlYnVnKGlucHV0LCBhcmdzKSB7XG4gIGlmICghZGVidWcuZW5hYmxlKSByZXR1cm47XG4gIHZhciBsb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgdmFyIHN0YXRlID0ge1xuICAgIHByZXZUaW1lOiAgRGF0ZS5ub3coKSAtIHRzLFxuICAgIHN0YW1wOiBpbnB1dC5zdGFtcFxuICB9O1xuXG4gIGlmIChpbnB1dC5hZGQpIHtcbiAgICBzdGF0ZS5hZGQgPSBpbnB1dC5hZGQubGVuZ3RoO1xuICAgIHN0YXRlLm1vZCA9IGlucHV0Lm1vZC5sZW5ndGg7XG4gICAgc3RhdGUucmVtID0gaW5wdXQucmVtLmxlbmd0aDtcbiAgICBzdGF0ZS5yZWZsb3cgPSAhIWlucHV0LnJlZmxvdztcbiAgfVxuXG4gIGxvZy5hcHBseShjb25zb2xlLCAoYXJncy5wdXNoKEpTT04uc3RyaW5naWZ5KHN0YXRlKSksIGFyZ3MpKTtcbiAgdHMgPSBEYXRlLm5vdygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nOiAgIHdyaXRlLFxuICBlcnJvcjogZXJyb3IsXG4gIGRlYnVnOiAoZGVidWcuZW5hYmxlID0gZmFsc2UsIGRlYnVnKVxufTtcbiIsInZhciBERVBTID0gcmVxdWlyZSgnLi9EZXBlbmRlbmNpZXMnKS5BTEw7XG5cbmZ1bmN0aW9uIGNyZWF0ZShjcywgcmVmbG93KSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgY29weShjcywgb3V0KTtcblxuICBvdXQuYWRkID0gW107XG4gIG91dC5tb2QgPSBbXTtcbiAgb3V0LnJlbSA9IFtdO1xuXG4gIG91dC5yZWZsb3cgPSByZWZsb3c7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gY29weShhLCBiKSB7XG4gIGIuc3RhbXAgPSBhID8gYS5zdGFtcCA6IDA7XG4gIGIuc29ydCAgPSBhID8gYS5zb3J0ICA6IG51bGw7XG4gIGIuZmFjZXQgPSBhID8gYS5mYWNldCA6IG51bGw7XG4gIGIudHJhbnMgPSBhID8gYS50cmFucyA6IG51bGw7XG4gIGIuZGlydHkgPSBhID8gYS5kaXJ0eSA6IFtdO1xuICBiLnJlcXVlc3QgPSBhID8gYS5yZXF1ZXN0IDogbnVsbDtcbiAgZm9yICh2YXIgZCwgaT0wLCBuPURFUFMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGJbZD1ERVBTW2ldXSA9IGEgPyBhW2RdIDoge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjb3B5OiBjb3B5XG59OyIsInZhciBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJy4vVHVwbGUnKSxcbiAgICBCYXNlID0gcmVxdWlyZSgnLi9Ob2RlJykucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3IoZ3JhcGgpIHtcbiAgQmFzZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9kYXRhID0gW107XG4gIHRoaXMucm91dGVyKHRydWUpLmNvbGxlY3Rvcih0cnVlKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IChDb2xsZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlKSk7XG5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsZWN0b3I7XG5cbnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9kYXRhO1xufTtcblxucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgbG9nLmRlYnVnKGlucHV0LCBbXCJjb2xsZWN0aW5nXCJdKTtcblxuICBpZiAoaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIHRoaXMuX2RhdGEgPSBUdXBsZS5pZEZpbHRlcih0aGlzLl9kYXRhLCBpbnB1dC5yZW0pO1xuICB9XG5cbiAgaWYgKGlucHV0LmFkZC5sZW5ndGgpIHtcbiAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YS5sZW5ndGggPyB0aGlzLl9kYXRhLmNvbmNhdChpbnB1dC5hZGQpIDogaW5wdXQuYWRkO1xuICB9XG5cbiAgaWYgKGlucHV0LnNvcnQpIHtcbiAgICB0aGlzLl9kYXRhLnNvcnQoaW5wdXQuc29ydCk7XG4gIH1cblxuICBpZiAoaW5wdXQucmVmbG93KSB7XG4gICAgaW5wdXQubW9kID0gaW5wdXQubW9kLmNvbmNhdChcbiAgICAgIFR1cGxlLmlkRmlsdGVyKHRoaXMuX2RhdGEsIGlucHV0LmFkZCwgaW5wdXQubW9kLCBpbnB1dC5yZW0pKTtcbiAgICBpbnB1dC5yZWZsb3cgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdG9yOyIsInZhciBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBDaGFuZ2VTZXQgPSByZXF1aXJlKCcuL0NoYW5nZVNldCcpLCBcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL0NvbGxlY3RvcicpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgnLi9UdXBsZScpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbmZ1bmN0aW9uIERhdGFTb3VyY2UoZ3JhcGgsIG5hbWUsIGZhY2V0KSB7XG4gIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9kYXRhID0gW107XG4gIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gIHRoaXMuX2ZhY2V0ICA9IGZhY2V0O1xuICB0aGlzLl9pbnB1dCAgPSBDaGFuZ2VTZXQuY3JlYXRlKCk7XG4gIHRoaXMuX291dHB1dCA9IG51bGw7IC8vIE91dHB1dCBjaGFuZ2VzZXRcblxuICB0aGlzLl9pbnB1dE5vZGUgID0gbnVsbDtcbiAgdGhpcy5fb3V0cHV0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX3BpcGVsaW5lICA9IG51bGw7IC8vIFBpcGVsaW5lIG9mIHRyYW5zZm9ybWF0aW9ucy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbnVsbDsgLy8gQ29sbGVjdG9yIHRvIG1hdGVyaWFsaXplIG91dHB1dCBvZiBwaXBlbGluZS5cbiAgdGhpcy5fbXV0YXRlcyA9IGZhbHNlOyAgLy8gRG9lcyBhbnkgcGlwZWxpbmUgb3BlcmF0b3IgbXV0YXRlIHR1cGxlcz9cbn1cblxudmFyIHByb3RvdHlwZSA9IERhdGFTb3VyY2UucHJvdG90eXBlO1xuXG5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbmFtZTtcbiAgcmV0dXJuICh0aGlzLl9uYW1lID0gbmFtZSwgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgcmV0dXJuICh0aGlzLl9zb3VyY2UgPSB0aGlzLl9ncmFwaC5kYXRhKHNyYykpO1xufTtcblxucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHR1cGxlcykge1xuICB0aGlzLl9pbnB1dC5hZGQgPSB0aGlzLl9pbnB1dC5hZGQuY29uY2F0KHR1cGxlcy5tYXAoVHVwbGUuaW5nZXN0KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHdoZXJlKSB7XG4gIHZhciByZW1vdmUgPSB0aGlzLl9kYXRhLmZpbHRlcih3aGVyZSk7XG4gIHRoaXMuX2lucHV0LnJlbSA9IHRoaXMuX2lucHV0LnJlbS5jb25jYXQocmVtb3ZlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24od2hlcmUsIGZpZWxkLCBmdW5jKSB7XG4gIHZhciBtb2QgPSB0aGlzLl9pbnB1dC5tb2QsXG4gICAgICBpZHMgPSBUdXBsZS5pZE1hcChtb2QpO1xuXG4gIHRoaXMuX2lucHV0LmZpZWxkc1tmaWVsZF0gPSAxO1xuXG4gIHRoaXMuX2RhdGEuZmlsdGVyKHdoZXJlKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcHJldiA9IHhbZmllbGRdLFxuICAgICAgICBuZXh0ID0gZnVuYyh4KTtcbiAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgVHVwbGUuc2V0KHgsIGZpZWxkLCBuZXh0KTtcbiAgICAgIGlmIChpZHNbeC5faWRdICE9PSAxKSB7XG4gICAgICAgIG1vZC5wdXNoKHgpO1xuICAgICAgICBpZHNbeC5faWRdID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fY29sbGVjdG9yLmRhdGEoKTtcblxuICAvLyBSZXBsYWNlIGJhY2tpbmcgZGF0YVxuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gIGlmIChkYXRhKSB7IHRoaXMuaW5zZXJ0KGRhdGEpOyB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm11dGF0ZXMgPSBmdW5jdGlvbihtKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX211dGF0ZXM7XG4gIHRoaXMuX211dGF0ZXMgPSB0aGlzLl9tdXRhdGVzIHx8IG07XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX291dHB1dDtcbn07XG5cbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYgKGlucHV0KSB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUodGhpcy5faW5wdXQsIHRoaXMuX3BpcGVsaW5lWzBdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGlwZWxpbmUgPSBmdW5jdGlvbihwaXBlbGluZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9waXBlbGluZTtcblxuICB2YXIgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIHN0YXR1cztcblxuICBwaXBlbGluZS51bnNoaWZ0KHRoaXMuX2lucHV0Tm9kZSA9IERhdGFTb3VyY2VJbnB1dCh0aGlzKSk7XG4gIHN0YXR1cyA9IGdyYXBoLnByZXByb2Nlc3MocGlwZWxpbmUpO1xuXG4gIGlmIChzdGF0dXMucm91dGVyKSB7XG4gICAgcGlwZWxpbmUucHVzaChzdGF0dXMuY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCkpO1xuICB9XG5cbiAgcGlwZWxpbmUucHVzaCh0aGlzLl9vdXRwdXROb2RlID0gRGF0YVNvdXJjZU91dHB1dCh0aGlzKSk7XG4gIHRoaXMuX2NvbGxlY3RvciA9IHN0YXR1cy5jb2xsZWN0b3I7XG4gIHRoaXMuX211dGF0ZXMgPSAhIXN0YXR1cy5tdXRhdGVzO1xuICBncmFwaC5jb25uZWN0KHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmUpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2dyYXBoLnN5bmNocm9uaXplKHRoaXMuX3BpcGVsaW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUubGlzdGVuZXIgPSBmdW5jdGlvbigpIHsgXG4gIHJldHVybiBEYXRhU291cmNlTGlzdGVuZXIodGhpcykuYWRkTGlzdGVuZXIodGhpcy5faW5wdXROb2RlKTtcbn07XG5cbnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYgKGwgaW5zdGFuY2VvZiBEYXRhU291cmNlKSB7XG4gICAgdGhpcy5fY29sbGVjdG9yLmFkZExpc3RlbmVyKGwubGlzdGVuZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fb3V0cHV0Tm9kZS5hZGRMaXN0ZW5lcihsKTsgICAgICBcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgdGhpcy5fb3V0cHV0Tm9kZS5yZW1vdmVMaXN0ZW5lcihsKTtcbn07XG5cbnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihkcykge1xuICByZXR1cm4gKGRzID8gdGhpcy5fY29sbGVjdG9yIDogdGhpcy5fb3V0cHV0Tm9kZSkubGlzdGVuZXJzKCk7XG59O1xuXG4vLyBJbnB1dCBub2RlIGFwcGxpZXMgdGhlIGRhdGFzb3VyY2UncyBkZWx0YSwgYW5kIHByb3BhZ2F0ZXMgaXQgdG8gXG4vLyB0aGUgcmVzdCBvZiB0aGUgcGlwZWxpbmUuIEl0IHJlY2VpdmVzIHRvdWNoZXMgdG8gcmVmbG93IGRhdGEuXG5mdW5jdGlvbiBEYXRhU291cmNlSW5wdXQoZHMpIHtcbiAgdmFyIGlucHV0ID0gbmV3IE5vZGUoZHMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIGlucHV0LmRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZHMuX2RhdGE7XG4gIH07XG5cbiAgaW5wdXQuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGxvZy5kZWJ1ZyhpbnB1dCwgWydpbnB1dCcsIGRzLl9uYW1lXSk7XG5cbiAgICB2YXIgZGVsdGEgPSBkcy5faW5wdXQsIFxuICAgICAgICBvdXQgPSBDaGFuZ2VTZXQuY3JlYXRlKGlucHV0KSwgZjtcblxuICAgIC8vIERlbHRhIG1pZ2h0IGNvbnRhaW4gZmllbGRzIHVwZGF0ZWQgdGhyb3VnaCBBUElcbiAgICBmb3IgKGYgaW4gZGVsdGEuZmllbGRzKSB7XG4gICAgICBvdXQuZmllbGRzW2ZdID0gMTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZGF0YVxuICAgIGlmIChkZWx0YS5yZW0ubGVuZ3RoKSB7XG4gICAgICBkcy5fZGF0YSA9IFR1cGxlLmlkRmlsdGVyKGRzLl9kYXRhLCBkZWx0YS5yZW0pO1xuICAgIH1cblxuICAgIGlmIChkZWx0YS5hZGQubGVuZ3RoKSB7XG4gICAgICBkcy5fZGF0YSA9IGRzLl9kYXRhLmNvbmNhdChkZWx0YS5hZGQpO1xuICAgIH1cblxuICAgIGlmIChkZWx0YS5zb3J0KSB7XG4gICAgICBkcy5fZGF0YS5zb3J0KGRlbHRhLnNvcnQpO1xuICAgIH1cblxuICAgIC8vIGlmIHJlZmxvd2luZywgYWRkIGFueSBvdGhlciB0dXBsZXMgbm90IGN1cnJlbnRseSBpbiBjaGFuZ2VzZXRcbiAgICBpZiAoaW5wdXQucmVmbG93KSB7XG4gICAgICBkZWx0YS5tb2QgPSBkZWx0YS5tb2QuY29uY2F0KFxuICAgICAgICBUdXBsZS5pZEZpbHRlcihkcy5fZGF0YSwgZGVsdGEuYWRkLCBkZWx0YS5tb2QsIGRlbHRhLnJlbSkpO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IGNoYW5nZSBsaXN0XG4gICAgZHMuX2lucHV0ID0gQ2hhbmdlU2V0LmNyZWF0ZSgpO1xuXG4gICAgb3V0LmFkZCA9IGRlbHRhLmFkZDsgXG4gICAgb3V0Lm1vZCA9IGRlbHRhLm1vZDtcbiAgICBvdXQucmVtID0gZGVsdGEucmVtO1xuICAgIG91dC5mYWNldCA9IGRzLl9mYWNldDtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHJldHVybiBpbnB1dDtcbn1cblxuLy8gT3V0cHV0IG5vZGUgY2FwdHVyZXMgdGhlIGxhc3QgY2hhbmdlc2V0IHNlZW4gYnkgdGhpcyBkYXRhc291cmNlXG4vLyAobmVlZGVkIGZvciBqb2lucyBhbmQgYnVpbGRzKSBhbmQgbWF0ZXJpYWxpemVzIGFueSBuZXN0ZWQgZGF0YS5cbi8vIElmIHRoaXMgZGF0YXNvdXJjZSBpcyBmYWNldGVkLCBtYXRlcmlhbGl6ZXMgdGhlIHZhbHVlcyBpbiB0aGUgZmFjZXQuXG5mdW5jdGlvbiBEYXRhU291cmNlT3V0cHV0KGRzKSB7XG4gIHZhciBvdXRwdXQgPSBuZXcgTm9kZShkcy5fZ3JhcGgpXG4gICAgLnJvdXRlcih0cnVlKVxuICAgIC5yZWZsb3dzKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICBvdXRwdXQuZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkcy5fY29sbGVjdG9yID8gZHMuX2NvbGxlY3Rvci5kYXRhKCkgOiBkcy5fZGF0YTtcbiAgfTtcblxuICBvdXRwdXQuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGxvZy5kZWJ1ZyhpbnB1dCwgWydvdXRwdXQnLCBkcy5fbmFtZV0pO1xuXG4gICAgdmFyIG91dCA9IENoYW5nZVNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xuXG4gICAgaWYgKGRzLl9mYWNldCkge1xuICAgICAgZHMuX2ZhY2V0LnZhbHVlcyA9IGRzLnZhbHVlcygpO1xuICAgICAgaW5wdXQuZmFjZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGRzLl9vdXRwdXQgPSBpbnB1dDtcbiAgICBvdXQuZGF0YVtkcy5fbmFtZV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gRGF0YVNvdXJjZUxpc3RlbmVyKGRzKSB7XG4gIHZhciBsID0gbmV3IE5vZGUoZHMuX2dyYXBoKS5yb3V0ZXIodHJ1ZSk7XG5cbiAgbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgLy8gVHVwbGUgZGVyaXZhdGlvbiBjYXJyaWVzIGEgY29zdC4gU28gb25seSBkZXJpdmUgaWYgdGhlIHBpcGVsaW5lIGhhc1xuICAgIC8vIG9wZXJhdG9ycyB0aGF0IG11dGF0ZSwgYW5kIHRodXMgd291bGQgb3ZlcnJpZGUgdGhlIHNvdXJjZSBkYXRhLlxuICAgIGlmIChkcy5tdXRhdGVzKCkpIHsgIFxuICAgICAgdmFyIG1hcCA9IGRzLl9zcmNNYXAgfHwgKGRzLl9zcmNNYXAgPSB7fSksIC8vIHRvIHByb3BhZ2F0ZSB0dXBsZXMgY29ycmVjdGx5XG4gICAgICAgICAgb3V0cHV0ID0gQ2hhbmdlU2V0LmNyZWF0ZShpbnB1dCk7XG5cbiAgICAgIG91dHB1dC5hZGQgPSBpbnB1dC5hZGQubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIChtYXBbdC5faWRdID0gVHVwbGUuZGVyaXZlKHQpKTtcbiAgICAgIH0pO1xuXG4gICAgICBvdXRwdXQubW9kID0gaW5wdXQubW9kLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBUdXBsZS5yZWRlcml2ZSh0LCBtYXBbdC5faWRdKTtcbiAgICAgIH0pO1xuXG4gICAgICBvdXRwdXQucmVtID0gaW5wdXQucmVtLm1hcChmdW5jdGlvbih0KSB7IFxuICAgICAgICB2YXIgbyA9IG1hcFt0Ll9pZF07XG4gICAgICAgIHJldHVybiAobWFwW3QuX2lkXSA9IG51bGwsIG8pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiAoZHMuX2lucHV0ID0gb3V0cHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChkcy5faW5wdXQgPSBpbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2U7XG4iLCJ2YXIgZGVwcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBBTEw6IFsnZGF0YScsICdmaWVsZHMnLCAnc2NhbGVzJywgJ3NpZ25hbHMnXVxufTtcbmRlcHMuQUxMLmZvckVhY2goZnVuY3Rpb24oaykgeyBkZXBzW2sudG9VcHBlckNhc2UoKV0gPSBrOyB9KTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBIZWFwID0gcmVxdWlyZSgnLi9IZWFwJyksXG4gICAgQ2hhbmdlU2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VTZXQnKSxcbiAgICBEYXRhU291cmNlID0gcmVxdWlyZSgnLi9EYXRhU291cmNlJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgICBUdXBsZSA9IHJlcXVpcmUoJy4vVHVwbGUnKSxcbiAgICBTaWduYWwgPSByZXF1aXJlKCcuL1NpZ25hbCcpLFxuICAgIERlcHMgPSByZXF1aXJlKCcuL0RlcGVuZGVuY2llcycpO1xuXG5mdW5jdGlvbiBHcmFwaCgpIHtcbn1cblxudmFyIHByb3RvdHlwZSA9IEdyYXBoLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhbXAgPSAwO1xuICB0aGlzLl9yYW5rICA9IDA7XG5cbiAgdGhpcy5fZGF0YSA9IHt9O1xuICB0aGlzLl9zaWduYWxzID0ge307XG5cbiAgdGhpcy5kb05vdFByb3BhZ2F0ZSA9IHt9O1xufTtcblxucHJvdG90eXBlLnJhbmsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICsrdGhpcy5fcmFuaztcbn07XG5cbnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbih0eXBlLCBuYW1lcywgaGFzaCkge1xuICB2YXIgZGF0YSA9ICh0eXBlID09PSBEZXBzLlNJR05BTFMgPyB0aGlzLl9zaWduYWxzIDogdGhpcy5fZGF0YSksXG4gICAgICBuID0gKG5hbWVzICE9PSB1bmRlZmluZWQgPyBuYW1lcyA6IGRsLmtleXMoZGF0YSkpLFxuICAgICAgdmFscywgaTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShuKSkge1xuICAgIHZhbHMgPSBoYXNoIHx8IHt9O1xuICAgIGZvciAoaT0wOyBpPG4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhbHNbbltpXV0gPSBkYXRhW25baV1dLnZhbHVlcygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YVtuXS52YWx1ZXMoKTtcbiAgfVxufTtcblxuLy8gUmV0YWluIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxucHJvdG90eXBlLmRhdGFWYWx1ZXMgPSBmdW5jdGlvbihuYW1lcykge1xuICByZXR1cm4gdGhpcy52YWx1ZXMoRGVwcy5EQVRBLCBuYW1lcyk7XG59O1xuXG4vLyBSZXRhaW4gZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG5wcm90b3R5cGUuc2lnbmFsVmFsdWVzID0gZnVuY3Rpb24obmFtZXMpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVzKERlcHMuU0lHTkFMUywgbmFtZXMpO1xufTtcblxucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbihuYW1lLCBwaXBlbGluZSwgZmFjZXQpIHtcbiAgdmFyIGRiID0gdGhpcy5fZGF0YTtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdmFyIGFsbCA9IFtdLCBrZXk7XG4gICAgZm9yIChrZXkgaW4gZGIpIHsgYWxsLnB1c2goZGJba2V5XSk7IH1cbiAgICByZXR1cm4gYWxsO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZGJbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChkYltuYW1lXSA9IG5ldyBEYXRhU291cmNlKHRoaXMsIG5hbWUsIGZhY2V0KS5waXBlbGluZShwaXBlbGluZSkpO1xuICB9XG59O1xuXG5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaW5pdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuYW1lKSA/XG4gICAgICBuYW1lLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBtLl9zaWduYWxzW25dOyB9KSA6XG4gICAgICB0aGlzLl9zaWduYWxzW25hbWVdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodGhpcy5fc2lnbmFsc1tuYW1lXSA9IG5ldyBTaWduYWwodGhpcywgbmFtZSwgaW5pdCkpO1xuICB9XG59O1xuXG5wcm90b3R5cGUuc2lnbmFsUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyZWYpKSB7XG4gICAgcmVmID0gZGwuZmllbGQocmVmKTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHRoaXMuc2lnbmFsKHJlZlswXSkudmFsdWUoKTtcbiAgaWYgKHJlZi5sZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaT0xLCBuPXJlZi5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW3JlZltpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIFN0YW1wIHNob3VsZCBiZSBzcGVjaWZpZWQgd2l0aCBjYXV0aW9uLiBJdCBpcyBuZWNlc3NhcnkgZm9yIGlubGluZSBkYXRhc291cmNlcyxcbi8vIHdoaWNoIG5lZWQgdG8gYmUgcG9wdWxhdGVkIGR1cmluZyB0aGUgc2FtZSBjeWNsZSBldmVuIHRob3VnaCBwcm9wYWdhdGlvbiBoYXNcbi8vIHBhc3NlZCB0aGF0IHBhcnQgb2YgdGhlIGRhdGFmbG93IGdyYXBoLiAgXG5wcm90b3R5cGUucHJvcGFnYXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUsIHN0YW1wKSB7XG4gIHZhciBwdWxzZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycywgbmV4dCwgbnBsc2UsIHRwbHMsIG50cGxzLCBpLCBsZW47XG5cbiAgLy8gbmV3IFBRIHdpdGggZWFjaCBwcm9wYWdhdGlvbiBjeWNsZSBzbyB0aGF0IHdlIGNhbiBwdWxzZSBicmFuY2hlc1xuICAvLyBvZiB0aGUgZGF0YWZsb3cgZ3JhcGggZHVyaW5nIGEgcHJvcGFnYXRpb24gKGUuZy4sIHdoZW4gY3JlYXRpbmdcbiAgLy8gYSBuZXcgaW5saW5lIGRhdGFzb3VyY2UpLlxuICB2YXIgcHEgPSBuZXcgSGVhcChmdW5jdGlvbihhLCBiKSB7XG4gICAgLy8gU29ydCBvbiBxcmFuayAocXVldWUtcmFuaykuXG4gICAgLy8gUmFuayBjYW4gY2hhbmdlIGR1cmluZyBwcm9wYWdhdGlvbiBkdWUgdG8gcmV3aXJpbmcuXG4gICAgcmV0dXJuIGEuX3FyYW5rIC0gYi5fcXJhbms7XG4gIH0pO1xuXG4gIGlmIChwdWxzZS5zdGFtcCkgdGhyb3cgRXJyb3IoJ1B1bHNlIGFscmVhZHkgaGFzIGEgbm9uLXplcm8gc3RhbXAuJyk7XG5cbiAgcHVsc2Uuc3RhbXAgPSBzdGFtcCB8fCArK3RoaXMuX3N0YW1wO1xuICBwdWxzZXNbbm9kZS5faWRdID0gcHVsc2U7XG4gIHBxLnB1c2gobm9kZS5xcmFuayh0cnVlKSk7XG5cbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICBub2RlICA9IHBxLnBlZWsoKTtcbiAgICBwdWxzZSA9IHB1bHNlc1tub2RlLl9pZF07XG5cbiAgICBpZiAobm9kZS5yYW5rKCkgIT09IG5vZGUucXJhbmsoKSkge1xuICAgICAgLy8gQSBub2RlJ3MgcmFuayBtaWdodCBjaGFuZ2UgZHVyaW5nIGEgcHJvcGFnYXRpb24uIFJlLXF1ZXVlIGlmIHNvLlxuICAgICAgcHEucmVwbGFjZShub2RlLnFyYW5rKHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZhbHVhdGUgbm9kZSBhbmQgcHJvcGFnYXRlIHB1bHNlLlxuICAgICAgcHEucG9wKCk7XG4gICAgICBwdWxzZXNbbm9kZS5faWRdID0gbnVsbDtcbiAgICAgIGxpc3RlbmVycyA9IG5vZGUuX2xpc3RlbmVycztcbiAgICAgIHB1bHNlID0gdGhpcy5ldmFsdWF0ZShwdWxzZSwgbm9kZSk7XG5cbiAgICAgIC8vIFByb3BhZ2F0ZSB0aGUgcHVsc2UuIFxuICAgICAgaWYgKHB1bHNlICE9PSB0aGlzLmRvTm90UHJvcGFnYXRlKSB7XG4gICAgICAgIC8vIEVuc3VyZSByZWZsb3cgcHVsc2VzIGFsd2F5cyBzZW5kIHJlZmxvdyBwdWxzZXMgZXZlbiBpZiBza2lwcGVkLlxuICAgICAgICBpZiAoIXB1bHNlLnJlZmxvdyAmJiBub2RlLnJlZmxvd3MoKSkge1xuICAgICAgICAgIHB1bHNlID0gQ2hhbmdlU2V0LmNyZWF0ZShwdWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGk9MCwgbGVuPWxpc3RlbmVycy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgICBuZXh0ID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICAgICAgaWYgKChucGxzZSA9IHB1bHNlc1tuZXh0Ll9pZF0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChucGxzZSA9PT0gbnVsbCkgdGhyb3cgRXJyb3IoJ0FscmVhZHkgcHJvcGFnYXRlZCB0byBub2RlLicpO1xuICAgICAgICAgICAgaWYgKG5wbHNlID09PSBwdWxzZSkgY29udGludWU7ICAvLyBSZS1xdWV1ZWluZyB0aGUgc2FtZSBwdWxzZS5cblxuICAgICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBub2RlLiBFbnN1cmUgdGhlcmUgc2hvdWxkIGJlIGF0IG1vc3Qgb25lXG4gICAgICAgICAgICAvLyBwdWxzZSB3aXRoIHR1cGxlcyAoYWRkL21vZC9yZW0pLCBhbmQgdGhlIHJlbWFpbmRlciB3aWxsIGJlIHJlZmxvd3MuIFxuICAgICAgICAgICAgdHBscyAgPSBwdWxzZS5hZGQubGVuZ3RoIHx8IHB1bHNlLm1vZC5sZW5ndGggfHwgcHVsc2UucmVtLmxlbmd0aDtcbiAgICAgICAgICAgIG50cGxzID0gbnBsc2UuYWRkLmxlbmd0aCB8fCBucGxzZS5tb2QubGVuZ3RoIHx8IG5wbHNlLnJlbS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICh0cGxzICYmIG50cGxzKSB0aHJvdyBFcnJvcignTXVsdGlwbGUgY2hhbmdlc2V0IHB1bHNlcyB0byBzYW1lIG5vZGUnKTtcblxuICAgICAgICAgICAgLy8gQ29tYmluZSByZWZsb3cgYW5kIHR1cGxlcyBpbnRvIGEgc2luZ2xlIHB1bHNlLiBcbiAgICAgICAgICAgIHB1bHNlc1tuZXh0Ll9pZF0gPSB0cGxzID8gcHVsc2UgOiBucGxzZTtcbiAgICAgICAgICAgIHB1bHNlc1tuZXh0Ll9pZF0ucmVmbG93ID0gcHVsc2UucmVmbG93IHx8IG5wbHNlLnJlZmxvdztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSdyZSBzZWVpbmcgdGhpcyBub2RlLCBxdWV1ZSBpdCBmb3IgcHJvcGFnYXRpb24uXG4gICAgICAgICAgICBwcS5wdXNoKG5leHQucXJhbmsodHJ1ZSkpO1xuICAgICAgICAgICAgcHVsc2VzW25leHQuX2lkXSA9IHB1bHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gUHJvY2VzcyBhIG5ldyBicmFuY2ggb2YgdGhlIGRhdGFmbG93IGdyYXBoIHByaW9yIHRvIGNvbm5lY3Rpb246XG4vLyAoMSkgSW5zZXJ0IG5ldyBDb2xsZWN0b3Igbm9kZXMgYXMgbmVlZGVkLiBcbi8vICgyKSBUcmFjayArIHJldHVybiBtdXRhdGlvbi9yb3V0aW5nIHN0YXR1cyBvZiB0aGUgYnJhbmNoLlxucHJvdG90eXBlLnByZXByb2Nlc3MgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgdmFyIGdyYXBoID0gdGhpcyxcbiAgICAgIG11dGF0ZXMgPSAwLFxuICAgICAgbm9kZSwgcm91dGVyLCBjb2xsZWN0b3IsIGNvbGxlY3RzO1xuXG4gIGZvciAodmFyIGk9MDsgaTxicmFuY2gubGVuZ3RoOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuXG4gICAgLy8gQmF0Y2ggbm9kZXMgbmVlZCBhY2Nlc3MgdG8gYSBtYXRlcmlhbGl6ZWQgZGF0YXNldC4gXG4gICAgaWYgKG5vZGUuYmF0Y2goKSAmJiAhbm9kZS5fY29sbGVjdG9yKSB7XG4gICAgICBpZiAocm91dGVyIHx8ICFjb2xsZWN0b3IpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBDb2xsZWN0b3IoZ3JhcGgpO1xuICAgICAgICBicmFuY2guc3BsaWNlKGksIDAsIG5vZGUpO1xuICAgICAgICByb3V0ZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuX2NvbGxlY3RvciA9IGNvbGxlY3RvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKGNvbGxlY3RzID0gbm9kZS5jb2xsZWN0b3IoKSkpIGNvbGxlY3RvciA9IG5vZGU7XG4gICAgcm91dGVyICA9IHJvdXRlciAgfHwgbm9kZS5yb3V0ZXIoKSAmJiAhY29sbGVjdHM7XG4gICAgbXV0YXRlcyA9IG11dGF0ZXMgfHwgbm9kZS5tdXRhdGVzKCk7XG5cbiAgICAvLyBBIGNvbGxlY3RvciBuZWVkcyB0byBiZSBpbnNlcnRlZCBhZnRlciB0dXBsZS1wcm9kdWNpbmdcbiAgICAvLyBub2RlcyBmb3IgY29ycmVjdCBwcmV2aW91cyB2YWx1ZSB0cmFja2luZy5cbiAgICBpZiAobm9kZS5wcm9kdWNlcygpKSB7XG4gICAgICBicmFuY2guc3BsaWNlKGkrMSwgMCwgbmV3IENvbGxlY3RvcihncmFwaCkpO1xuICAgICAgcm91dGVyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtyb3V0ZXI6IHJvdXRlciwgY29sbGVjdG9yOiBjb2xsZWN0b3IsIG11dGF0ZXM6IG11dGF0ZXN9O1xufTtcblxucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgdmFyIGNvbGxlY3Rvciwgbm9kZSwgZGF0YSwgc2lnbmFscywgaSwgbiwgaiwgbSwgeCwgeTtcblxuICAvLyBjb25uZWN0IHRoZSBwaXBlbGluZVxuICBmb3IgKGk9MCwgbj1icmFuY2gubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIG5vZGUgPSBicmFuY2hbaV07XG4gICAgaWYgKG5vZGUuY29sbGVjdG9yKCkpIGNvbGxlY3RvciA9IG5vZGU7XG5cbiAgICBkYXRhID0gbm9kZS5kZXBlbmRlbmN5KERlcHMuREFUQSk7XG4gICAgZm9yIChqPTAsIG09ZGF0YS5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoISh4PXRoaXMuZGF0YSh5PWRhdGFbal0pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YSBzb3VyY2UgJyArIGRsLnN0cih5KSk7XG4gICAgICB9XG5cbiAgICAgIHguYWRkTGlzdGVuZXIoY29sbGVjdG9yKTtcbiAgICB9XG5cbiAgICBzaWduYWxzID0gbm9kZS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUyk7XG4gICAgZm9yIChqPTAsIG09c2lnbmFscy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoISh4PXRoaXMuc2lnbmFsKHk9c2lnbmFsc1tqXSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaWduYWwgJyArIGRsLnN0cih5KSk7XG4gICAgICB9XG5cbiAgICAgIHguYWRkTGlzdGVuZXIoY29sbGVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoaSA+IDApIGJyYW5jaFtpLTFdLmFkZExpc3RlbmVyKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGJyYW5jaDtcbn07XG5cbnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oYnJhbmNoKSB7XG4gIHZhciBjb2xsZWN0b3IsIG5vZGUsIGRhdGEsIHNpZ25hbHMsIGksIG4sIGosIG07XG5cbiAgZm9yIChpPTAsIG49YnJhbmNoLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuICAgIGlmIChub2RlLmNvbGxlY3RvcigpKSBjb2xsZWN0b3IgPSBub2RlO1xuXG4gICAgZGF0YSA9IG5vZGUuZGVwZW5kZW5jeShEZXBzLkRBVEEpO1xuICAgIGZvciAoaj0wLCBtPWRhdGEubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5kYXRhKGRhdGFbal0pLnJlbW92ZUxpc3RlbmVyKGNvbGxlY3Rvcik7XG4gICAgfVxuXG4gICAgc2lnbmFscyA9IG5vZGUuZGVwZW5kZW5jeShEZXBzLlNJR05BTFMpO1xuICAgIGZvciAoaj0wLCBtPXNpZ25hbHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5zaWduYWwoc2lnbmFsc1tqXSkucmVtb3ZlTGlzdGVuZXIoY29sbGVjdG9yKTtcbiAgICB9XG5cbiAgICBub2RlLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIHJldHVybiBicmFuY2g7XG59O1xuXG5wcm90b3R5cGUuc3luY2hyb25pemUgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgdmFyIGlkcyA9IHt9LFxuICAgICAgbm9kZSwgZGF0YSwgaSwgbiwgaiwgbSwgZCwgaWQ7XG5cbiAgZm9yIChpPTAsIG49YnJhbmNoLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuICAgIGlmICghbm9kZS5jb2xsZWN0b3IoKSkgY29udGludWU7XG5cbiAgICBmb3IgKGo9MCwgZGF0YT1ub2RlLmRhdGEoKSwgbT1kYXRhLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlkID0gKGQgPSBkYXRhW2pdKS5faWQ7XG4gICAgICBpZiAoaWRzW2lkXSkgY29udGludWU7IFxuICAgICAgVHVwbGUucHJldl91cGRhdGUoZCk7XG4gICAgICBpZHNbaWRdID0gMTsgXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIHZhciByZWZsb3dlZCA9IHB1bHNlLnJlZmxvdyAmJiBub2RlLmxhc3QoKSA+PSBwdWxzZS5zdGFtcCxcbiAgICAgIHJ1biA9IG5vZGUucm91dGVyKCkgfHwgcHVsc2UuYWRkLmxlbmd0aCB8fCBwdWxzZS5yZW0ubGVuZ3RoO1xuXG4gIHJldHVybiBydW4gfHwgIXJlZmxvd2VkIHx8IG5vZGUucmVldmFsdWF0ZShwdWxzZSk7XG59O1xuXG5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICBpZiAoIXRoaXMucmVldmFsdWF0ZShwdWxzZSwgbm9kZSkpIHJldHVybiBwdWxzZTtcbiAgcHVsc2UgPSBub2RlLmV2YWx1YXRlKHB1bHNlKTtcbiAgbm9kZS5sYXN0KHB1bHNlLnN0YW1wKTtcbiAgcmV0dXJuIHB1bHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcbiIsImZ1bmN0aW9uIEhlYXAoY29tcGFyYXRvcikge1xuICB0aGlzLmNtcCA9IGNvbXBhcmF0b3I7XG4gIHRoaXMubm9kZXMgPSBbXTtcbn1cblxudmFyIHByb3RvdHlwZSA9IEhlYXAucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG59O1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLm5vZGVzID0gW10sIHRoaXMpO1xufTtcblxucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG59O1xuXG5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGFycmF5ID0gdGhpcy5ub2RlcztcbiAgYXJyYXkucHVzaCh4KTtcbiAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoLTEsIHRoaXMuY21wKTtcbn07XG5cbnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFycmF5ID0gdGhpcy5ub2RlcyxcbiAgICAgIGxhc3QgPSBhcnJheS5wb3AoKSxcbiAgICAgIGl0ZW07XG5cbiAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgIGl0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGxhc3Q7XG4gICAgX3NpZnR1cChhcnJheSwgMCwgdGhpcy5jbXApO1xuICB9IGVsc2Uge1xuICAgIGl0ZW0gPSBsYXN0O1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihpdGVtKSB7XG4gIHZhciBhcnJheSA9IHRoaXMubm9kZXMsXG4gICAgICByZXR2YWwgPSBhcnJheVswXTtcbiAgYXJyYXlbMF0gPSBpdGVtO1xuICBfc2lmdHVwKGFycmF5LCAwLCB0aGlzLmNtcCk7XG4gIHJldHVybiByZXR2YWw7XG59O1xuXG5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdmFyIGFycmF5ID0gdGhpcy5ub2RlcywgcmVmID0gYXJyYXlbMF07XG4gIGlmIChhcnJheS5sZW5ndGggJiYgdGhpcy5jbXAocmVmLCBpdGVtKSA8IDApIHtcbiAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgaXRlbSA9IHJlZjtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCB0aGlzLmNtcCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0LCBpZHgsIGNtcCkge1xuICB2YXIgaXRlbSwgcGFyZW50LCBwaWR4O1xuXG4gIGl0ZW0gPSBhcnJheVtpZHhdO1xuICB3aGlsZSAoaWR4ID4gc3RhcnQpIHtcbiAgICBwaWR4ID0gKGlkeCAtIDEpID4+IDE7XG4gICAgcGFyZW50ID0gYXJyYXlbcGlkeF07XG4gICAgaWYgKGNtcChpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgYXJyYXlbaWR4XSA9IHBhcmVudDtcbiAgICAgIGlkeCA9IHBpZHg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIChhcnJheVtpZHhdID0gaXRlbSk7XG59XG5cbmZ1bmN0aW9uIF9zaWZ0dXAoYXJyYXksIGlkeCwgY21wKSB7XG4gIHZhciBzdGFydCA9IGlkeCxcbiAgICAgIGVuZCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGl0ZW0gPSBhcnJheVtpZHhdLFxuICAgICAgY2lkeCA9IDIgKiBpZHggKyAxLCByaWR4O1xuXG4gIHdoaWxlIChjaWR4IDwgZW5kKSB7XG4gICAgcmlkeCA9IGNpZHggKyAxO1xuICAgIGlmIChyaWR4IDwgZW5kICYmIGNtcChhcnJheVtjaWR4XSwgYXJyYXlbcmlkeF0pID49IDApIHtcbiAgICAgIGNpZHggPSByaWR4O1xuICAgIH1cbiAgICBhcnJheVtpZHhdID0gYXJyYXlbY2lkeF07XG4gICAgaWR4ID0gY2lkeDtcbiAgICBjaWR4ID0gMiAqIGlkeCArIDE7XG4gIH1cbiAgYXJyYXlbaWR4XSA9IGl0ZW07XG4gIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0LCBpZHgsIGNtcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhcDtcbiIsInZhciBERVBTID0gcmVxdWlyZSgnLi9EZXBlbmRlbmNpZXMnKS5BTEwsXG4gICAgbm9kZUlEID0gMDtcblxuZnVuY3Rpb24gTm9kZShncmFwaCkge1xuICBpZiAoZ3JhcGgpIHRoaXMuaW5pdChncmFwaCk7XG59XG5cbnZhciBGbGFncyA9IE5vZGUuRmxhZ3MgPSB7XG4gIFJvdXRlcjogICAgIDB4MDEsIC8vIFJlc3BvbnNpYmxlIGZvciBwcm9wYWdhdGluZyB0dXBsZXMsIGNhbm5vdCBiZSBza2lwcGVkLlxuICBDb2xsZWN0b3I6ICAweDAyLCAvLyBIb2xkcyBhIG1hdGVyaWFsaXplZCBkYXRhc2V0LCBwdWxzZSBub2RlIHRvIHJlZmxvdy5cbiAgUHJvZHVjZXM6ICAgMHgwNCwgLy8gUHJvZHVjZXMgbmV3IHR1cGxlcy4gXG4gIE11dGF0ZXM6ICAgIDB4MDgsIC8vIFNldHMgcHJvcGVydGllcyBvZiBpbmNvbWluZyB0dXBsZXMuXG4gIFJlZmxvd3M6ICAgIDB4MTAsIC8vIEZvcndhcmRzIGEgcmVmbG93IHB1bHNlLlxuICBCYXRjaDogICAgICAweDIwICAvLyBQZXJmb3JtcyBiYXRjaCBkYXRhIHByb2Nlc3NpbmcsIG5lZWRzIGNvbGxlY3Rvci5cbn07XG5cbnZhciBwcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihncmFwaCkge1xuICB0aGlzLl9pZCA9ICsrbm9kZUlEO1xuICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICB0aGlzLl9yYW5rICA9IGdyYXBoLnJhbmsoKTsgLy8gVG9wb2xvZ2ljYWwgc29ydCBieSByYW5rXG4gIHRoaXMuX3FyYW5rID0gbnVsbDsgLy8gUmFuayB3aGVuIGVucXVldWVkIGZvciBwcm9wYWdhdGlvblxuICB0aGlzLl9zdGFtcCA9IDA7ICAgIC8vIExhc3Qgc3RhbXAgc2VlblxuXG4gIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICB0aGlzLl9saXN0ZW5lcnMuX2lkcyA9IHt9OyAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0ZSBsaXN0ZW5lcnNcblxuICAvLyBJbml0aWFsaXplIGRlcGVuZGVuY2llcy5cbiAgdGhpcy5fZGVwcyA9IHt9O1xuICBmb3IgKHZhciBpPTAsIG49REVQUy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdGhpcy5fZGVwc1tERVBTW2ldXSA9IFtdO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBzdGF0dXMgZmxhZ3MuXG4gIHRoaXMuX2ZsYWdzID0gMDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yYW5rID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yYW5rO1xufTtcblxucHJvdG90eXBlLnFyYW5rID0gZnVuY3Rpb24oLyogc2V0ICovKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3FyYW5rO1xuICByZXR1cm4gKHRoaXMuX3FyYW5rID0gdGhpcy5fcmFuaywgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKHN0YW1wKSB7IFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zdGFtcDtcbiAgcmV0dXJuICh0aGlzLl9zdGFtcCA9IHN0YW1wLCB0aGlzKTtcbn07XG5cbi8vIC0tIHN0YXR1cyBmbGFncyAtLS1cblxucHJvdG90eXBlLl9zZXRmID0gZnVuY3Rpb24odiwgYikge1xuICBpZiAoYikgeyB0aGlzLl9mbGFncyB8PSB2OyB9IGVsc2UgeyB0aGlzLl9mbGFncyAmPSB+djsgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3V0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAodGhpcy5fZmxhZ3MgJiBGbGFncy5Sb3V0ZXIpO1xuICByZXR1cm4gdGhpcy5fc2V0ZihGbGFncy5Sb3V0ZXIsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5jb2xsZWN0b3IgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAodGhpcy5fZmxhZ3MgJiBGbGFncy5Db2xsZWN0b3IpO1xuICByZXR1cm4gdGhpcy5fc2V0ZihGbGFncy5Db2xsZWN0b3IsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5wcm9kdWNlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuICh0aGlzLl9mbGFncyAmIEZsYWdzLlByb2R1Y2VzKTtcbiAgcmV0dXJuIHRoaXMuX3NldGYoRmxhZ3MuUHJvZHVjZXMsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5tdXRhdGVzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gKHRoaXMuX2ZsYWdzICYgRmxhZ3MuTXV0YXRlcyk7XG4gIHJldHVybiB0aGlzLl9zZXRmKEZsYWdzLk11dGF0ZXMsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5yZWZsb3dzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gKHRoaXMuX2ZsYWdzICYgRmxhZ3MuUmVmbG93cyk7XG4gIHJldHVybiB0aGlzLl9zZXRmKEZsYWdzLlJlZmxvd3MsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuICh0aGlzLl9mbGFncyAmIEZsYWdzLkJhdGNoKTtcbiAgcmV0dXJuIHRoaXMuX3NldGYoRmxhZ3MuQmF0Y2gsIHN0YXRlKTtcbn07XG5cbnByb3RvdHlwZS5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICB2YXIgZCA9IHRoaXMuX2RlcHNbdHlwZV0sXG4gICAgICBuID0gZC5fbmFtZXMgfHwgKGQuX25hbWVzID0ge30pOyAgLy8gVG8gcHJldmVudCBkdXBlIGRlcHNcblxuICAvLyBHZXQgZGVwZW5kZW5jaWVzIG9mIHRoZSBnaXZlbiB0eXBlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH1cblxuICBpZiAoZGVwcyA9PT0gbnVsbCkge1xuICAgIC8vIENsZWFyIGRlcGVuZGVuY2llcyBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgIGQuc3BsaWNlKDAsIGQubGVuZ3RoKTtcbiAgICBkLl9uYW1lcyA9IHt9O1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgLy8gU2VwYXJhdGUgdGhpcyBjYXNlIHRvIGF2b2lkIGNvc3Qgb2YgYXJyYXkgY3JlYXRpb25cbiAgICBpZiAobltkZXBzXSkgcmV0dXJuIHRoaXM7XG4gICAgZC5wdXNoKGRlcHMpO1xuICAgIG5bZGVwc10gPSAxO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWRlcHMubGVuZ3RoLCBkZXA7IGk8bGVuOyArK2kpIHtcbiAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICBpZiAobltkZXBdKSBjb250aW51ZTtcbiAgICAgIGQucHVzaChkZXApO1xuICAgICAgbltkZXBdID0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycztcbn07XG5cbnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYgKCEobCBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0xpc3RlbmVyIGlzIG5vdCBhIE5vZGUnKTtcbiAgfVxuICBpZiAodGhpcy5fbGlzdGVuZXJzLl9pZHNbbC5faWRdKSByZXR1cm4gdGhpcztcblxuICB0aGlzLl9saXN0ZW5lcnMucHVzaChsKTtcbiAgdGhpcy5fbGlzdGVuZXJzLl9pZHNbbC5faWRdID0gMTtcbiAgaWYgKHRoaXMuX3JhbmsgPiBsLl9yYW5rKSB7XG4gICAgdmFyIHEgPSBbbF0sXG4gICAgICAgIGcgPSB0aGlzLl9ncmFwaCwgY3VyO1xuICAgIHdoaWxlIChxLmxlbmd0aCkge1xuICAgICAgY3VyID0gcS5zaGlmdCgpO1xuICAgICAgY3VyLl9yYW5rID0gZy5yYW5rKCk7XG4gICAgICBxLnVuc2hpZnQuYXBwbHkocSwgY3VyLmxpc3RlbmVycygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYgKCF0aGlzLl9saXN0ZW5lcnMuX2lkc1tsLl9pZF0pIHJldHVybiBmYWxzZTtcbiAgXG4gIHZhciBpZHggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsKSxcbiAgICAgIGIgPSBpZHggPj0gMDtcblxuICBpZiAoYikge1xuICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB0aGlzLl9saXN0ZW5lcnMuX2lkc1tsLl9pZF0gPSBudWxsO1xuICB9XG4gIHJldHVybiBiO1xufTtcblxucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX2xpc3RlbmVycy5faWRzID0ge307XG59O1xuXG4vLyBFdmFsdWF0ZSB0aGlzIGRhdGFmbG93IG5vZGUgZm9yIHRoZSBjdXJyZW50IHB1bHNlLlxuLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdG8gcGVyZm9ybSBjdXN0b20gcHJvY2Vzc2luZy5cbnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHJldHVybiBwdWxzZTtcbn07XG5cbi8vIFNob3VsZCB0aGlzIG5vZGUgYmUgcmUtZXZhbHVhdGVkIGZvciB0aGUgY3VycmVudCBwdWxzZT9cbi8vIFNlYXJjaGVzIHB1bHNlIHRvIHNlZSBpZiBhbnkgZGVwZW5kZW5jaWVzIGhhdmUgdXBkYXRlZC5cbnByb3RvdHlwZS5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UpIHtcbiAgdmFyIHByb3AsIGRlcCwgaSwgbiwgaiwgbTtcblxuICBmb3IgKGk9MCwgbj1ERVBTLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gREVQU1tpXTtcbiAgICBkZXAgPSB0aGlzLl9kZXBzW3Byb3BdO1xuICAgIGZvciAoaj0wLCBtPWRlcC5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAocHVsc2VbcHJvcF1bZGVwW2pdXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuTm9kZS5yZXNldCA9IGZ1bmN0aW9uKCkgeyBub2RlSUQgPSAwOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG4iLCJ2YXIgQ2hhbmdlU2V0ID0gcmVxdWlyZSgnLi9DaGFuZ2VTZXQnKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIEJhc2UgPSBOb2RlLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gU2lnbmFsKGdyYXBoLCBuYW1lLCBpbml0aWFsVmFsdWUpIHtcbiAgQmFzZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9uYW1lICA9IG5hbWU7XG4gIHRoaXMuX3ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICB0aGlzLl92ZXJib3NlID0gZmFsc2U7IC8vIFZlcmJvc2Ugc2lnbmFscyByZS1wdWxzZSB0aGUgZ3JhcGggZXZlbiBpZiBwcmV2ID09PSB2YWwuXG4gIHRoaXMuX2hhbmRsZXJzID0gW107XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG90eXBlID0gKFNpZ25hbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNpZ25hbDtcblxucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25hbWU7XG59O1xuXG5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIHJldHVybiAodGhpcy5fdmFsdWUgPSB2YWwsIHRoaXMpO1xufTtcblxuLy8gQWxpYXMgdG8gdmFsdWUsIGZvciBzaGFyZWQgQVBJIHdpdGggRGF0YVNvdXJjZVxucHJvdG90eXBlLnZhbHVlcyA9IHByb3RvdHlwZS52YWx1ZTtcblxucHJvdG90eXBlLnZlcmJvc2UgPSBmdW5jdGlvbih2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3ZlcmJvc2U7XG4gIHJldHVybiAodGhpcy5fdmVyYm9zZSA9ICEhdiwgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gaW5wdXQuc2lnbmFsc1t0aGlzLl9uYW1lXSA/IGlucHV0IDogdGhpcy5fZ3JhcGguZG9Ob3RQcm9wYWdhdGU7XG59O1xuXG5wcm90b3R5cGUuZmlyZSA9IGZ1bmN0aW9uKGNzKSB7XG4gIGlmICghY3MpIGNzID0gQ2hhbmdlU2V0LmNyZWF0ZShudWxsLCB0cnVlKTtcbiAgY3Muc2lnbmFsc1t0aGlzLl9uYW1lXSA9IDE7XG4gIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShjcywgdGhpcyk7XG59O1xuXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIHZhciBzaWduYWwgPSB0aGlzLFxuICAgICAgbm9kZSA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKTtcblxuICBub2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBoYW5kbGVyKHNpZ25hbC5uYW1lKCksIHNpZ25hbC52YWx1ZSgpKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgdGhpcy5faGFuZGxlcnMucHVzaCh7XG4gICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICBub2RlOiBub2RlXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKG5vZGUpO1xufTtcblxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIGggPSB0aGlzLl9oYW5kbGVycywgaSwgeDtcblxuICBmb3IgKGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICB4ID0gaC5zcGxpY2UoaSwgMSlbMF07XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHgubm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hbDtcbiIsInZhciB0dXBsZUlEID0gMDtcblxuZnVuY3Rpb24gaW5nZXN0KGRhdHVtKSB7XG4gIGRhdHVtID0gKGRhdHVtID09PSBPYmplY3QoZGF0dW0pKSA/IGRhdHVtIDoge2RhdGE6IGRhdHVtfTtcbiAgZGF0dW0uX2lkID0gKyt0dXBsZUlEO1xuICBpZiAoZGF0dW0uX3ByZXYpIGRhdHVtLl9wcmV2ID0gbnVsbDtcbiAgcmV0dXJuIGRhdHVtO1xufVxuXG5mdW5jdGlvbiBpZE1hcChhLCBpZHMpIHtcbiAgaWRzID0gaWRzIHx8IHt9O1xuICBmb3IgKHZhciBpPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgaWRzW2FbaV0uX2lkXSA9IDE7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cblxuZnVuY3Rpb24gY29weSh0LCBjKSB7XG4gIGMgPSBjIHx8IHt9O1xuICBmb3IgKHZhciBrIGluIHQpIHtcbiAgICBpZiAoayAhPT0gJ19wcmV2JyAmJiBrICE9PSAnX2lkJykgY1trXSA9IHRba107XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmdlc3Q6IGluZ2VzdCxcbiAgaWRNYXA6IGlkTWFwLFxuXG4gIGRlcml2ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBpbmdlc3QoY29weShkKSk7XG4gIH0sXG5cbiAgcmVkZXJpdmU6IGZ1bmN0aW9uKGQsIHQpIHtcbiAgICByZXR1cm4gY29weShkLCB0KTtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uKHQsIGssIHYpIHtcbiAgICByZXR1cm4gdFtrXSA9PT0gdiA/IDAgOiAodFtrXSA9IHYsIDEpO1xuICB9LFxuXG4gIHByZXY6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5fcHJldiB8fCB0O1xuICB9LFxuXG4gIHByZXZfaW5pdDogZnVuY3Rpb24odCkge1xuICAgIGlmICghdC5fcHJldikgeyB0Ll9wcmV2ID0ge19pZDogdC5faWR9OyB9XG4gIH0sXG5cbiAgcHJldl91cGRhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgcCA9IHQuX3ByZXYsIGssIHY7XG4gICAgaWYgKHApIGZvciAoayBpbiB0KSB7XG4gICAgICBpZiAoayAhPT0gJ19wcmV2JyAmJiBrICE9PSAnX2lkJykge1xuICAgICAgICBwW2tdID0gKCh2PXRba10pIGluc3RhbmNlb2YgT2JqZWN0ICYmIHYuX3ByZXYpID8gdi5fcHJldiA6IHY7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHsgdHVwbGVJRCA9IDA7IH0sXG5cbiAgaWRGaWx0ZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgaWRzID0ge307XG4gICAgZm9yICh2YXIgaT1hcmd1bWVudHMubGVuZ3RoOyAtLWk+MDspIHtcbiAgICAgIGlkTWFwKGFyZ3VtZW50c1tpXSwgaWRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpZHNbeC5faWRdOyB9KTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBDaGFuZ2VTZXQ6ICAgIHJlcXVpcmUoJy4vQ2hhbmdlU2V0JyksXG4gIENvbGxlY3RvcjogICAgcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgRGF0YVNvdXJjZTogICByZXF1aXJlKCcuL0RhdGFTb3VyY2UnKSxcbiAgRGVwZW5kZW5jaWVzOiByZXF1aXJlKCcuL0RlcGVuZGVuY2llcycpLFxuICBHcmFwaDogICAgICAgIHJlcXVpcmUoJy4vR3JhcGgnKSxcbiAgTm9kZTogICAgICAgICByZXF1aXJlKCcuL05vZGUnKSxcbiAgU2lnbmFsOiAgICAgICByZXF1aXJlKCcuL1NpZ25hbCcpLFxuICBUdXBsZTogICAgICAgIHJlcXVpcmUoJy4vVHVwbGUnKSxcbiAgZGVidWc6ICAgICAgICByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKS5kZWJ1Z1xufTtcbiIsImZ1bmN0aW9uIHRvTWFwKGxpc3QpIHtcbiAgdmFyIG1hcCA9IHt9LCBpLCBuO1xuICBmb3IgKGk9MCwgbj1saXN0Lmxlbmd0aDsgaTxuOyArK2kpIG1hcFtsaXN0W2ldXSA9IDE7XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHZhciBsaXN0ID0gW10sIGs7XG4gIGZvciAoayBpbiBvYmplY3QpIGxpc3QucHVzaChrKTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGNvbnN0YW50cyA9IG9wdC5jb25zdGFudHMgfHwgcmVxdWlyZSgnLi9jb25zdGFudHMnKSxcbiAgICAgIGZ1bmN0aW9ucyA9IChvcHQuZnVuY3Rpb25zIHx8IHJlcXVpcmUoJy4vZnVuY3Rpb25zJykpKGNvZGVnZW4pLFxuICAgICAgaWRXaGl0ZUxpc3QgPSBvcHQuaWRXaGl0ZUxpc3QgPyB0b01hcChvcHQuaWRXaGl0ZUxpc3QpIDogbnVsbCxcbiAgICAgIGlkQmxhY2tMaXN0ID0gb3B0LmlkQmxhY2tMaXN0ID8gdG9NYXAob3B0LmlkQmxhY2tMaXN0KSA6IG51bGwsXG4gICAgICBtZW1iZXJEZXB0aCA9IDAsXG4gICAgICBGSUVMRF9WQVIgPSBvcHQuZmllbGRWYXIgfHwgJ2RhdHVtJyxcbiAgICAgIEdMT0JBTF9WQVIgPSBvcHQuZ2xvYmFsVmFyIHx8ICdzaWduYWxzJyxcbiAgICAgIGdsb2JhbHMgPSB7fSxcbiAgICAgIGZpZWxkcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNvZGVnZW5fd3JhcChhc3QpIHsgICAgXG4gICAgdmFyIHJldHZhbCA9IHtcbiAgICAgIGNvZGU6IGNvZGVnZW4oYXN0KSxcbiAgICAgIGdsb2JhbHM6IGtleXMoZ2xvYmFscyksXG4gICAgICBmaWVsZHM6IGtleXMoZmllbGRzKVxuICAgIH07XG4gICAgZ2xvYmFscyA9IHt9O1xuICAgIGZpZWxkcyA9IHt9O1xuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBHbG9iYWwoaWQpIHtcbiAgICByZXR1cm4gR0xPQkFMX1ZBUiArICdbXCInICsgaWQgKyAnXCJdJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGVnZW4oYXN0KSB7XG4gICAgaWYgKHR5cGVvZiBhc3QgPT09ICdzdHJpbmcnKSByZXR1cm4gYXN0O1xuICAgIHZhciBnZW5lcmF0b3IgPSBDT0RFR0VOX1RZUEVTW2FzdC50eXBlXTtcbiAgICBpZiAoZ2VuZXJhdG9yID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIGFzdC50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRvcihhc3QpO1xuICB9XG5cbiAgdmFyIENPREVHRU5fVFlQRVMgPSB7XG4gICAgJ0xpdGVyYWwnOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLnJhdztcbiAgICAgIH0sXG4gICAgJ0lkZW50aWZpZXInOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBpZCA9IG4ubmFtZTtcbiAgICAgICAgaWYgKG1lbWJlckRlcHRoID4gMCkge1xuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHJldHVybiBjb25zdGFudHNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZFdoaXRlTGlzdCkge1xuICAgICAgICAgIGlmIChpZFdoaXRlTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsc1tpZF0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cEdsb2JhbChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZEJsYWNrTGlzdCAmJiBpZEJsYWNrTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaWRlbnRpZmllcjogJyArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9LFxuICAgICdQcm9ncmFtJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi5ib2R5Lm1hcChjb2RlZ2VuKS5qb2luKCdcXG4nKTtcbiAgICAgIH0sXG4gICAgJ01lbWJlckV4cHJlc3Npb24nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBkID0gIW4uY29tcHV0ZWQ7XG4gICAgICAgIHZhciBvID0gY29kZWdlbihuLm9iamVjdCk7XG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgICB2YXIgcCA9IGNvZGVnZW4obi5wcm9wZXJ0eSk7XG4gICAgICAgIGlmIChvID09PSBGSUVMRF9WQVIpIHsgZmllbGRzW3BdID0gMTsgfSAvLyBIQUNLaXNoLi4uXG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgICByZXR1cm4gbyArIChkID8gJy4nK3AgOiAnWycrcCsnXScpO1xuICAgICAgfSxcbiAgICAnQ2FsbEV4cHJlc3Npb24nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmIChuLmNhbGxlZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY2FsbGVlIHR5cGU6ICcgKyBuLmNhbGxlZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGVlID0gbi5jYWxsZWUubmFtZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBuLmFyZ3VtZW50cztcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb25zLmhhc093blByb3BlcnR5KGNhbGxlZSkgJiYgZnVuY3Rpb25zW2NhbGxlZV07XG4gICAgICAgIGlmICghZm4pIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGZ1bmN0aW9uOiAnICsgY2FsbGVlKTtcbiAgICAgICAgcmV0dXJuIGZuIGluc3RhbmNlb2YgRnVuY3Rpb24gP1xuICAgICAgICAgIGZuKGFyZ3MpIDpcbiAgICAgICAgICBmbiArICcoJyArIGFyZ3MubWFwKGNvZGVnZW4pLmpvaW4oJywnKSArICcpJztcbiAgICAgIH0sXG4gICAgJ0FycmF5RXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICdbJyArIG4uZWxlbWVudHMubWFwKGNvZGVnZW4pLmpvaW4oJywnKSArICddJztcbiAgICAgIH0sXG4gICAgJ0JpbmFyeUV4cHJlc3Npb24nOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiAnKCcgKyBjb2RlZ2VuKG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLnJpZ2h0KSArICcpJztcbiAgICAgIH0sXG4gICAgJ1VuYXJ5RXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICcoJyArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4uYXJndW1lbnQpICsgJyknO1xuICAgICAgfSxcbiAgICAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gJygnICsgY29kZWdlbihuLnRlc3QpICtcbiAgICAgICAgICAnPycgKyBjb2RlZ2VuKG4uY29uc2VxdWVudCkgK1xuICAgICAgICAgICc6JyArIGNvZGVnZW4obi5hbHRlcm5hdGUpICtcbiAgICAgICAgICAnKSc7XG4gICAgICB9LFxuICAgICdMb2dpY2FsRXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICcoJyArIGNvZGVnZW4obi5sZWZ0KSArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4ucmlnaHQpICsgJyknO1xuICAgICAgfSxcbiAgICAnT2JqZWN0RXhwcmVzc2lvbic6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuICd7JyArIG4ucHJvcGVydGllcy5tYXAoY29kZWdlbikuam9pbignLCcpICsgJ30nO1xuICAgICAgfSxcbiAgICAnUHJvcGVydHknOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICAgIHZhciBrID0gY29kZWdlbihuLmtleSk7XG4gICAgICAgIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICAgIHJldHVybiBrICsgJzonICsgY29kZWdlbihuLnZhbHVlKTtcbiAgICAgIH0sXG4gICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuKG4uZXhwcmVzc2lvbik7XG4gICAgICB9XG4gIH07XG5cbiAgY29kZWdlbl93cmFwLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgY29kZWdlbl93cmFwLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgcmV0dXJuIGNvZGVnZW5fd3JhcDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ05hTic6ICAgICAnTmFOJyxcbiAgJ0UnOiAgICAgICAnTWF0aC5FJyxcbiAgJ0xOMic6ICAgICAnTWF0aC5MTjInLFxuICAnTE4xMCc6ICAgICdNYXRoLkxOMTAnLFxuICAnTE9HMkUnOiAgICdNYXRoLkxPRzJFJyxcbiAgJ0xPRzEwRSc6ICAnTWF0aC5MT0cxMEUnLFxuICAnUEknOiAgICAgICdNYXRoLlBJJyxcbiAgJ1NRUlQxXzInOiAnTWF0aC5TUVJUMV8yJyxcbiAgJ1NRUlQyJzogICAnTWF0aC5TUVJUMidcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb2RlZ2VuKSB7XG5cbiAgZnVuY3Rpb24gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpIHtcbiAgICB2YXIgb2JqID0gY29kZWdlbihhcmdzWzBdKTtcbiAgICBpZiAoY2FzdCkge1xuICAgICAgb2JqID0gY2FzdCArICcoJyArIG9iaiArICcpJztcbiAgICAgIGlmIChjYXN0Lmxhc3RJbmRleE9mKCduZXcgJywgMCkgPT09IDApIG9iaiA9ICcoJyArIG9iaiArICcpJztcbiAgICB9XG4gICAgcmV0dXJuIG9iaiArICcuJyArIG5hbWUgKyAodHlwZSA8IDAgPyAnJyA6IHR5cGUgPT09IDAgP1xuICAgICAgJygpJyA6XG4gICAgICAnKCcgKyBhcmdzLnNsaWNlKDEpLm1hcChjb2RlZ2VuKS5qb2luKCcsJykgKyAnKScpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4obmFtZSwgY2FzdCwgdHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICByZXR1cm4gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpO1xuICAgIH07XG4gIH1cblxuICB2YXIgREFURSA9ICduZXcgRGF0ZScsXG4gICAgICBTVFJJTkcgPSAnU3RyaW5nJyxcbiAgICAgIFJFR0VYUCA9ICdSZWdFeHAnO1xuXG4gIHJldHVybiB7XG4gICAgLy8gTUFUSCBmdW5jdGlvbnNcbiAgICAnaXNOYU4nOiAgICAnaXNOYU4nLFxuICAgICdpc0Zpbml0ZSc6ICdpc0Zpbml0ZScsXG4gICAgJ2Ficyc6ICAgICAgJ01hdGguYWJzJyxcbiAgICAnYWNvcyc6ICAgICAnTWF0aC5hY29zJyxcbiAgICAnYXNpbic6ICAgICAnTWF0aC5hc2luJyxcbiAgICAnYXRhbic6ICAgICAnTWF0aC5hdGFuJyxcbiAgICAnYXRhbjInOiAgICAnTWF0aC5hdGFuMicsXG4gICAgJ2NlaWwnOiAgICAgJ01hdGguY2VpbCcsXG4gICAgJ2Nvcyc6ICAgICAgJ01hdGguY29zJyxcbiAgICAnZXhwJzogICAgICAnTWF0aC5leHAnLFxuICAgICdmbG9vcic6ICAgICdNYXRoLmZsb29yJyxcbiAgICAnbG9nJzogICAgICAnTWF0aC5sb2cnLFxuICAgICdtYXgnOiAgICAgICdNYXRoLm1heCcsXG4gICAgJ21pbic6ICAgICAgJ01hdGgubWluJyxcbiAgICAncG93JzogICAgICAnTWF0aC5wb3cnLFxuICAgICdyYW5kb20nOiAgICdNYXRoLnJhbmRvbScsXG4gICAgJ3JvdW5kJzogICAgJ01hdGgucm91bmQnLFxuICAgICdzaW4nOiAgICAgICdNYXRoLnNpbicsXG4gICAgJ3NxcnQnOiAgICAgJ01hdGguc3FydCcsXG4gICAgJ3Rhbic6ICAgICAgJ01hdGgudGFuJyxcblxuICAgICdjbGFtcCc6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhcmd1bWVudHMgdG8gY2xhbXAgZnVuY3Rpb24uJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSBhcmd1bWVudHMgdG8gY2xhbXAgZnVuY3Rpb24uJyk7XG4gICAgICB2YXIgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgcmV0dXJuICdNYXRoLm1heCgnK2FbMV0rJywgTWF0aC5taW4oJythWzJdKycsJythWzBdKycpKSc7XG4gICAgfSxcblxuICAgIC8vIERBVEUgZnVuY3Rpb25zXG4gICAgJ25vdyc6ICAgICAgICAgICAgICdEYXRlLm5vdycsXG4gICAgJ2RhdGV0aW1lJzogICAgICAgIERBVEUsXG4gICAgJ2RhdGUnOiAgICAgICAgICAgIGZuKCdnZXREYXRlJywgREFURSwgMCksXG4gICAgJ2RheSc6ICAgICAgICAgICAgIGZuKCdnZXREYXknLCBEQVRFLCAwKSxcbiAgICAneWVhcic6ICAgICAgICAgICAgZm4oJ2dldEZ1bGxZZWFyJywgREFURSwgMCksXG4gICAgJ21vbnRoJzogICAgICAgICAgIGZuKCdnZXRNb250aCcsIERBVEUsIDApLFxuICAgICdob3Vycyc6ICAgICAgICAgICBmbignZ2V0SG91cnMnLCBEQVRFLCAwKSxcbiAgICAnbWludXRlcyc6ICAgICAgICAgZm4oJ2dldE1pbnV0ZXMnLCBEQVRFLCAwKSxcbiAgICAnc2Vjb25kcyc6ICAgICAgICAgZm4oJ2dldFNlY29uZHMnLCBEQVRFLCAwKSxcbiAgICAnbWlsbGlzZWNvbmRzJzogICAgZm4oJ2dldE1pbGxpc2Vjb25kcycsIERBVEUsIDApLFxuICAgICd0aW1lJzogICAgICAgICAgICBmbignZ2V0VGltZScsIERBVEUsIDApLFxuICAgICd0aW1lem9uZW9mZnNldCc6ICBmbignZ2V0VGltZXpvbmVPZmZzZXQnLCBEQVRFLCAwKSxcbiAgICAndXRjZGF0ZSc6ICAgICAgICAgZm4oJ2dldFVUQ0RhdGUnLCBEQVRFLCAwKSxcbiAgICAndXRjZGF5JzogICAgICAgICAgZm4oJ2dldFVUQ0RheScsIERBVEUsIDApLFxuICAgICd1dGN5ZWFyJzogICAgICAgICBmbignZ2V0VVRDRnVsbFllYXInLCBEQVRFLCAwKSxcbiAgICAndXRjbW9udGgnOiAgICAgICAgZm4oJ2dldFVUQ01vbnRoJywgREFURSwgMCksXG4gICAgJ3V0Y2hvdXJzJzogICAgICAgIGZuKCdnZXRVVENIb3VycycsIERBVEUsIDApLFxuICAgICd1dGNtaW51dGVzJzogICAgICBmbignZ2V0VVRDTWludXRlcycsIERBVEUsIDApLFxuICAgICd1dGNzZWNvbmRzJzogICAgICBmbignZ2V0VVRDU2Vjb25kcycsIERBVEUsIDApLFxuICAgICd1dGNtaWxsaXNlY29uZHMnOiBmbignZ2V0VVRDTWlsbGlzZWNvbmRzJywgREFURSwgMCksXG5cbiAgICAvLyBzaGFyZWQgc2VxdWVuY2UgZnVuY3Rpb25zXG4gICAgJ2xlbmd0aCc6ICAgICAgZm4oJ2xlbmd0aCcsIG51bGwsIC0xKSxcbiAgICAnaW5kZXhvZic6ICAgICBmbignaW5kZXhPZicsIG51bGwpLFxuICAgICdsYXN0aW5kZXhvZic6IGZuKCdsYXN0SW5kZXhPZicsIG51bGwpLFxuXG4gICAgLy8gU1RSSU5HIGZ1bmN0aW9uc1xuICAgICdwYXJzZUZsb2F0JzogICdwYXJzZUZsb2F0JyxcbiAgICAncGFyc2VJbnQnOiAgICAncGFyc2VJbnQnLFxuICAgICd1cHBlcic6ICAgICAgIGZuKCd0b1VwcGVyQ2FzZScsIFNUUklORywgMCksXG4gICAgJ2xvd2VyJzogICAgICAgZm4oJ3RvTG93ZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICAnc2xpY2UnOiAgICAgICBmbignc2xpY2UnLCBTVFJJTkcpLFxuICAgICdzdWJzdHJpbmcnOiAgIGZuKCdzdWJzdHJpbmcnLCBTVFJJTkcpLFxuXG4gICAgLy8gUkVHRVhQIGZ1bmN0aW9uc1xuICAgICdyZWdleHAnOiAgUkVHRVhQLFxuICAgICd0ZXN0JzogICAgZm4oJ3Rlc3QnLCBSRUdFWFApLFxuXG4gICAgLy8gQ29udHJvbCBGbG93IGZ1bmN0aW9uc1xuICAgICdpZic6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLicpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi4nKTtcbiAgICAgICAgdmFyIGEgPSBhcmdzLm1hcChjb2RlZ2VuKTtcbiAgICAgICAgcmV0dXJuIGFbMF0rJz8nK2FbMV0rJzonK2FbMl07XG4gICAgICB9XG4gIH07XG59OyIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpLFxuICAgIGNvZGVnZW4gPSByZXF1aXJlKCcuL2NvZGVnZW4nKTtcbiAgICBcbnZhciBleHByID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbihpbnB1dCwgb3B0KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCcoJytpbnB1dCsnKScsIG9wdCk7XG4gICAgfSxcbiAgY29kZTogZnVuY3Rpb24ob3B0KSB7XG4gICAgICByZXR1cm4gY29kZWdlbihvcHQpO1xuICAgIH0sXG4gIGNvbXBpbGVyOiBmdW5jdGlvbihhcmdzLCBvcHQpIHtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gY29kZWdlbihvcHQpLFxuICAgICAgICAgIGxlbiA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGNvbXBpbGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdlbmVyYXRvcihleHByLnBhcnNlKHN0cikpO1xuICAgICAgICAgICAgYXJnc1tsZW5dID0gJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyB2YWx1ZS5jb2RlICsgJyk7JztcbiAgICAgICAgICAgIHZhbHVlLmZuID0gRnVuY3Rpb24uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfTtcbiAgICAgIGNvbXBpbGUuY29kZWdlbiA9IGdlbmVyYXRvcjtcbiAgICAgIHJldHVybiBjb21waWxlO1xuICAgIH0sXG4gIGZ1bmN0aW9uczogcmVxdWlyZSgnLi9mdW5jdGlvbnMnKSxcbiAgY29uc3RhbnRzOiByZXF1aXJlKCcuL2NvbnN0YW50cycpXG59O1xuIiwiLypcbiAgVGhlIGZvbGxvd2luZyBleHByZXNzaW9uIHBhcnNlciBpcyBiYXNlZCBvbiBFc3ByaW1hIChodHRwOi8vZXNwcmltYS5vcmcvKS5cbiAgT3JpZ2luYWwgaGVhZGVyIGNvbW1lbnQgYW5kIGxpY2Vuc2UgZm9yIEVzcHJpbWEgaXMgaW5jbHVkZWQgaGVyZTpcblxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVG9rZW4sXG4gICAgICBUb2tlbk5hbWUsXG4gICAgICBTeW50YXgsXG4gICAgICBQcm9wZXJ0eUtpbmQsXG4gICAgICBNZXNzYWdlcyxcbiAgICAgIFJlZ2V4LFxuICAgICAgc291cmNlLFxuICAgICAgc3RyaWN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsaW5lTnVtYmVyLFxuICAgICAgbGluZVN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgbG9va2FoZWFkLFxuICAgICAgc3RhdGUsXG4gICAgICBleHRyYTtcblxuICBUb2tlbiA9IHtcbiAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgRU9GOiAyLFxuICAgICAgSWRlbnRpZmllcjogMyxcbiAgICAgIEtleXdvcmQ6IDQsXG4gICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgIE51bWVyaWNMaXRlcmFsOiA2LFxuICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgIFN0cmluZ0xpdGVyYWw6IDgsXG4gICAgICBSZWd1bGFyRXhwcmVzc2lvbjogOVxuICB9O1xuXG4gIFRva2VuTmFtZSA9IHt9O1xuICBUb2tlbk5hbWVbVG9rZW4uQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gIFRva2VuTmFtZVtUb2tlbi5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcbiAgVG9rZW5OYW1lW1Rva2VuLktleXdvcmRdID0gJ0tleXdvcmQnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuICBUb2tlbk5hbWVbVG9rZW4uUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG4gIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuICBUb2tlbk5hbWVbVG9rZW4uUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcblxuICBTeW50YXggPSB7XG4gICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJ1xuICB9O1xuXG4gIFByb3BlcnR5S2luZCA9IHtcbiAgICAgIERhdGE6IDEsXG4gICAgICBHZXQ6IDIsXG4gICAgICBTZXQ6IDRcbiAgfTtcblxuICAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuICBNZXNzYWdlcyA9IHtcbiAgICAgIFVuZXhwZWN0ZWRUb2tlbjogICdVbmV4cGVjdGVkIHRva2VuICUwJyxcbiAgICAgIFVuZXhwZWN0ZWROdW1iZXI6ICAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgVW5leHBlY3RlZFN0cmluZzogICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxuICAgICAgVW5leHBlY3RlZFJlc2VydmVkOiAgJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICBVbmV4cGVjdGVkRU9TOiAgJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICAgIE5ld2xpbmVBZnRlclRocm93OiAgJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAgJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxuICAgICAgSW52YWxpZExIU0luRm9ySW46ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxuICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXG4gICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICBTdHJpY3RNb2RlV2l0aDogICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RWYXJOYW1lOiAgJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RQYXJhbU5hbWU6ICAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAgJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXG4gICAgICBTdHJpY3REZWxldGU6ICAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgIFN0cmljdER1cGxpY2F0ZVByb3BlcnR5OiAgJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIEFjY2Vzc29yRGF0YVByb3BlcnR5OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBkYXRhIGFuZCBhY2Nlc3NvciBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgQWNjZXNzb3JHZXRTZXQ6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIG11bHRpcGxlIGdldC9zZXQgYWNjZXNzb3JzIHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAgJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUG9zdGZpeDogICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUHJlZml4OiAgJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFJlc2VydmVkV29yZDogICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnXG4gIH07XG5cbiAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cbiAgUmVnZXggPSB7XG4gICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEIyXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gIC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSk7ICAgLy8gMC4uOVxuICB9XG5cbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICB9XG5cbiAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gIH1cblxuICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgIChjaCA9PT0gMHg1QykgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICB9XG5cbiAgLy8gNy42LjEuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgY2FzZSAnZW51bSc6XG4gICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgY2FzZSAnZXh0ZW5kcyc6XG4gICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICBjYXNlICdwcm90ZWN0ZWQnOlxuICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICBjYXNlICd5aWVsZCc6XG4gICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICAvLyA3LjYuMS4xIEtleXdvcmRzXG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gJ2NvbnN0JyBpcyBzcGVjaWFsaXplZCBhcyBLZXl3b3JkIGluIFY4LlxuICAgICAgLy8gJ3lpZWxkJyBhbmQgJ2xldCcgYXJlIGZvciBjb21wYXRpYmxpdHkgd2l0aCBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHQuXG4gICAgICAvLyBTb21lIG90aGVycyBhcmUgZnJvbSBmdXR1cmUgcmVzZXJ2ZWQgd29yZHMuXG5cbiAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tpcENvbW1lbnQoKSB7XG4gICAgICB2YXIgY2gsIHN0YXJ0O1xuXG4gICAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgIGlmIChpc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgdmFyIGksIGxlbiwgY2gsIGNvZGUgPSAwO1xuXG4gICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICAgICAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgY29kZSA9IDA7XG5cbiAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBVVEYtMTYgRW5jb2RpbmdcbiAgICAgIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgfVxuICAgICAgY3UxID0gKChjb2RlIC0gMHgxMDAwMCkgPj4gMTApICsgMHhEODAwO1xuICAgICAgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1MSwgY3UyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIGNoLCBpZDtcblxuICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgICAgIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZCA9IGNoO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICBzdGFydCA9IGluZGV4Kys7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVzY2FwZWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgaWQgPSAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDVDKSA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cbiAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAoaXNLZXl3b3JkKGlkKSkge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLk51bGxMaXRlcmFsO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgICAgICBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpLFxuICAgICAgICAgIGNvZGUyLFxuICAgICAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICAgICAgY2gyLFxuICAgICAgICAgIGNoMyxcbiAgICAgICAgICBjaDQ7XG5cbiAgICAgIHN3aXRjaCAoY29kZSkge1xuXG4gICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgIGNhc2UgMHgyRTogIC8vIC4gZG90XG4gICAgICBjYXNlIDB4Mjg6ICAvLyAoIG9wZW4gYnJhY2tldFxuICAgICAgY2FzZSAweDI5OiAgLy8gKSBjbG9zZSBicmFja2V0XG4gICAgICBjYXNlIDB4M0I6ICAvLyA7IHNlbWljb2xvblxuICAgICAgY2FzZSAweDJDOiAgLy8gLCBjb21tYVxuICAgICAgY2FzZSAweDdCOiAgLy8geyBvcGVuIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4N0Q6ICAvLyB9IGNsb3NlIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4NUI6ICAvLyBbXG4gICAgICBjYXNlIDB4NUQ6ICAvLyBdXG4gICAgICBjYXNlIDB4M0E6ICAvLyA6XG4gICAgICBjYXNlIDB4M0Y6ICAvLyA/XG4gICAgICBjYXNlIDB4N0U6ICAvLyB+XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDdCKSB7XG4gICAgICAgICAgICAgICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICAgIC8vICc9JyAoVSswMDNEKSBtYXJrcyBhbiBhc3NpZ25tZW50IG9yIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gICAgICAgICAgaWYgKGNvZGUyID09PSAweDNEKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDB4MkI6ICAvLyArXG4gICAgICAgICAgICAgIGNhc2UgMHgyRDogIC8vIC1cbiAgICAgICAgICAgICAgY2FzZSAweDJGOiAgLy8gL1xuICAgICAgICAgICAgICBjYXNlIDB4M0M6ICAvLyA8XG4gICAgICAgICAgICAgIGNhc2UgMHgzRTogIC8vID5cbiAgICAgICAgICAgICAgY2FzZSAweDVFOiAgLy8gXlxuICAgICAgICAgICAgICBjYXNlIDB4N0M6ICAvLyB8XG4gICAgICAgICAgICAgIGNhc2UgMHgyNTogIC8vICVcbiAgICAgICAgICAgICAgY2FzZSAweDI2OiAgLy8gJlxuICAgICAgICAgICAgICBjYXNlIDB4MkE6ICAvLyAqXG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXG4gICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBjYXNlIDB4MjE6IC8vICFcbiAgICAgICAgICAgICAgY2FzZSAweDNEOiAvLyA9XG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuXG4gICAgICAgICAgICAgICAgICAvLyAhPT0gYW5kID09PVxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3I6ID4+Pj1cblxuICAgICAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgICAgIGlmIChjaDQgPT09ICc+Pj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoNCxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgIGNoMyA9IGNoNC5zdWJzdHIoMCwgMyk7XG5cbiAgICAgIGlmIChjaDMgPT09ICc+Pj4nIHx8IGNoMyA9PT0gJzw8PScgfHwgY2gzID09PSAnPj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMyxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiArKyAtLSA8PCA+PiAmJiB8fFxuICAgICAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcblxuICAgICAgaWYgKChjaDEgPT09IGNoMlsxXSAmJiAoJystPD4mfCcuaW5kZXhPZihjaDEpID49IDApKSB8fCBjaDIgPT09ICc9PicpIHtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDIsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPCA+ID0gISArIC0gKiAlICYgfCBeIC9cblxuICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gxLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICB9XG5cbiAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gIGZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICB2YXIgbnVtYmVyID0gJyc7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpIHtcbiAgICAgIHZhciBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCA4KSxcbiAgICAgICAgICBvY3RhbDogdHJ1ZSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgIG51bWJlciA9ICcnO1xuICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICBudW1iZXIgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkhleExpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBkZWNpbWFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcgc3VjaCBhcyAnMDknIGlzIGlsbGVnYWwuXG4gICAgICAgICAgICAgIGlmIChjaCAmJiBpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICB2YXIgc3RyID0gJycsIHF1b3RlLCBzdGFydCwgY2gsIGNvZGUsIHVuZXNjYXBlZCwgcmVzdG9yZSwgb2N0YWwgPSBmYWxzZSwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydExpbmVTdGFydDtcbiAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICsraW5kZXg7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZCA9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICBzdGFydExpbmVTdGFydDogc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgIHZhciB0bXAgPSBwYXR0ZXJuLFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uXG4gICAgICAgICAgLy8gcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAgICAgICAgLy8gYC91YCBmbGFnLlxuICAgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgICAgICAgIC8vIHBlcmZlY3RseSB2YWxpZCBwYXR0ZXJuIHRoYXQgaXMgZXF1aXZhbGVudCB0byBgW2EtYl1gLCBidXQgaXRcbiAgICAgICAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICB0bXAgPSB0bXBcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3gnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csICd4Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAodG1wKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgICAgIC8vIHVzZXMuXG4gICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cEJvZHkoKSB7XG4gICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgLy8gRUNNQS0yNjIgNy44LjVcbiAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBib2R5LFxuICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgc3RyID0gJyc7XG4gICAgICBmbGFncyA9ICcnO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZmxhZ3MsXG4gICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuXG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIGJvZHkgPSBzY2FuUmVnRXhwQm9keSgpO1xuICAgICAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgICAgIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlJlZ3VsYXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpdGVyYWw6IGJvZHkubGl0ZXJhbCArIGZsYWdzLmxpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlZ2V4ID0gc2NhblJlZ0V4cCgpO1xuXG4gICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgfTtcblxuICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sIHdoaWNoIGlzIGxpa2VseSAnLycgb3IgJy89J1xuICAgICAgICAgIGlmIChleHRyYS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmICh0b2tlbi5yYW5nZVswXSA9PT0gcG9zICYmIHRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLycgfHwgdG9rZW4udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICByZWdleDogcmVnZXgucmVnZXgsXG4gICAgICAgICAgICAgIHJhbmdlOiBbcG9zLCBpbmRleF0sXG4gICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlU2xhc2goKSB7XG4gICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgIGNoZWNrVG9rZW47XG4gICAgICAvLyBVc2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICBwcmV2VG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFwcmV2VG9rZW4pIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICddJykge1xuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlblBhcmVuVG9rZW4gLSAxXTtcbiAgICAgICAgICAgICAgaWYgKGNoZWNrVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChjaGVja1Rva2VuLnZhbHVlID09PSAnaWYnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aGlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2ZvcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3dpdGgnKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnfScpIHtcbiAgICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10gJiZcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXS50eXBlID09PSAnS2V5d29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdICYmXG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA1XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJiBwcmV2VG9rZW4udmFsdWUgIT09ICd0aGlzJykge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgIHZhciBjaDtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLkVPRixcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cbiAgICAgIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSAmJiBjaCA9PT0gMHgyRikge1xuICAgICAgICAgIHJldHVybiBhZHZhbmNlU2xhc2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0VG9rZW4oKSB7XG4gICAgICB2YXIgbG9jLCB0b2tlbiwgdmFsdWUsIGVudHJ5O1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgbG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0b2tlbiA9IGFkdmFuY2UoKTtcbiAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICB9O1xuXG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdmFsdWUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICByYW5nZTogW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdLFxuICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogdG9rZW4ucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiB0b2tlbi5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgIHZhciB0b2tlbjtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBpbmRleCA9IHRva2VuLmVuZDtcbiAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG5cbiAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydDtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgaW5kZXggPSBwb3M7XG4gICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgdGhpcy5jb2x1bW4gPSBpbmRleCAtIGxpbmVTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKSB7XG4gICAgICBpZiAoc3RhcnRUb2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgICAgbGluZTogc3RhcnRUb2tlbi5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4uc3RhcnRMaW5lU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgICAvLyBTa2lwIGNvbW1lbnQuXG4gICAgICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIGxpbmVOdW1iZXIgPSBsb29rYWhlYWQuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5zdGFydExpbmVTdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZU51bWJlciA9IGxvb2thaGVhZC5saW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5saW5lU3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICB0aGlzLnJhbmdlID0gW2luZGV4LCAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbigpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pIHtcbiAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRUb2tlbi5zdGFydCwgMF07XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgdGhpcy5sb2MgPSBuZXcgV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIFdyYXBwaW5nTm9kZS5wcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZSA9IHtcblxuICAgICAgZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFuZ2VbMV0gPSBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgaWYgKGV4dHJhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyYXlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChjYWxsZWUsIGFyZ3MpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5JZGVudGlmaWVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5MaXRlcmFsO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucmF3ID09ICcvLycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdyA9ICcvKD86KS8nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChhY2Nlc3Nvciwgb2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBhY2Nlc3NvciA9PT0gJ1snO1xuICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hQcm9ncmFtOiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9ncmFtO1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICBmdW5jdGlvbiBwZWVrTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydCwgZm91bmQ7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBmb3VuZCA9IGxpbmVOdW1iZXIgIT09IGxpbmU7XG4gICAgICBpbmRleCA9IHBvcztcbiAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3IodG9rZW4sIG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgYXNzZXJ0KGluZGV4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIHRva2VuLmxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIGxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IuZGVzY3JpcHRpb24gPSBtc2c7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3JUb2xlcmFudCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3dFcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICBmdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIGlmIChpc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICBmdW5jdGlvbiBleHBlY3QodmFsdWUpIHtcbiAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBleHBlY3RUb2xlcmFudFxuICAgKiBAZGVzY3JpcHRpb24gUXVpZXRseSBleHBlY3QgdGhlIGdpdmVuIHRva2VuIHZhbHVlIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlc1xuICAgKiB0byA8Y29kZT5leHBlY3QodmFsdWUpPC9jb2RlPlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHdlIGFyZSBleHBlY3RpbmcgdGhlIGxvb2thaGVhZCB0b2tlbiB0byBoYXZlXG4gICAqIEBzaW5jZSAyLjBcbiAgICovXG4gIGZ1bmN0aW9uIGV4cGVjdFRvbGVyYW50KHZhbHVlKSB7XG4gICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cbiAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lU2VtaWNvbG9uKCkge1xuICAgICAgdmFyIGxpbmU7XG5cbiAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0OiBpbW1lZGlhdGVseSBhIHNlbWljb2xvbiAoVSswMDNCKS5cbiAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IGxpbmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GICYmICFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG4gIH1cblxuICAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuICBmdW5jdGlvbiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV4KCk7XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cyk7XG4gIH1cblxuICAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciB0b2tlbiwga2V5LCBpZCwgdmFsdWUsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZCA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGlkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFtdLCBwcm9wZXJ0eSwgbmFtZSwga2V5LCBraW5kLCBtYXAgPSB7fSwgdG9TdHJpbmcgPSBTdHJpbmcsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5KCk7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eS5rZXkubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2luZCA9IChwcm9wZXJ0eS5raW5kID09PSAnaW5pdCcpID8gUHJvcGVydHlLaW5kLkRhdGEgOiAocHJvcGVydHkua2luZCA9PT0gJ2dldCcpID8gUHJvcGVydHlLaW5kLkdldCA6IFByb3BlcnR5S2luZC5TZXQ7XG5cbiAgICAgICAgICBrZXkgPSAnJCcgKyBuYW1lO1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChtYXBba2V5XSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYga2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBba2V5XSAmIGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXBba2V5XSB8PSBraW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0ga2luZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIC8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByO1xuXG4gICAgICBleHBlY3QoJygnKTtcblxuICAgICAgKytzdGF0ZS5wYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG5cbiAgLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbiAgdmFyIGxlZ2FsS2V5d29yZHMgPSB7XCJpZlwiOjEsIFwidGhpc1wiOjF9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgdHlwZSwgdG9rZW4sIGV4cHIsIG5vZGU7XG5cbiAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fCBsZWdhbEtleXdvcmRzW2xvb2thaGVhZC52YWx1ZV0pIHtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgbG9va2FoZWFkLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChsb29rYWhlYWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwobGV4KCkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSAodG9rZW4udmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChjb2xsZWN0UmVnZXgoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChzY2FuUmVnRXhwKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWVrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmdzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJyknKTtcblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSB7XG4gICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICBpZiAoIWlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgZXhwZWN0KCcuJyk7XG5cbiAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KCddJyk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5LCBzdGFydFRva2VuLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4zIFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICBmdW5jdGlvbiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgaWYgKChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkgJiYgIXBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCBtYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCBtYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgIHZhciBwcmVjID0gMDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgcHJlYyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICBwcmVjID0gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgcHJlYyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIHByZWMgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgICBwcmVjID0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPT0nOlxuICAgICAgY2FzZSAnIT0nOlxuICAgICAgY2FzZSAnPT09JzpcbiAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgcHJlYyA9IDY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgY2FzZSAnPic6XG4gICAgICBjYXNlICc8PSc6XG4gICAgICBjYXNlICc+PSc6XG4gICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICBwcmVjID0gNztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHByZWMgPSBhbGxvd0luID8gNyA6IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzw8JzpcbiAgICAgIGNhc2UgJz4+JzpcbiAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgcHJlYyA9IDg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcHJlYyA9IDk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnLyc6XG4gICAgICBjYXNlICclJzpcbiAgICAgICAgICBwcmVjID0gMTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVjO1xuICB9XG5cbiAgLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNyBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuICAvLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4gIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG4gIC8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuICAvLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgbWFya2VyLCBtYXJrZXJzLCBleHByLCB0b2tlbiwgcHJlYywgc3RhY2ssIHJpZ2h0LCBvcGVyYXRvciwgbGVmdCwgaTtcblxuICAgICAgbWFya2VyID0gbG9va2FoZWFkO1xuICAgICAgbGVmdCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIHN0YXRlLmFsbG93SW4pO1xuICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgbGV4KCk7XG5cbiAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgcmlnaHQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgc3RhdGUuYWxsb3dJbikpID4gMCkge1xuXG4gICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaGlmdC5cbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIGV4cHIgPSBzdGFja1tpXTtcbiAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICB3aGlsZSAoaSA+IDEpIHtcbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzLnBvcCgpKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBleHByKTtcbiAgICAgICAgICBpIC09IDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTIgQ29uZGl0aW9uYWwgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBwcmV2aW91c0FsbG93SW4sIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgc3RhcnRUb2tlbjtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBpZiAobWF0Y2goJz8nKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBvbGRQYXJlbnRoZXNpc0NvdW50LCB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgb2xkUGFyZW50aGVzaXNDb3VudCA9IHN0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIG5vIHNlcXVlbmNlIGV4cHJlc3Npb25zXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDEyIFN0YXRlbWVudHNcblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgIHZhciB0eXBlID0gbG9va2FoZWFkLnR5cGUsXG4gICAgICAgICAgZXhwcixcbiAgICAgICAgICBub2RlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBibG9jayBzdGF0ZW1lbnRcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBlbXB0eSBzdGF0ZW1lbnRcbiAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGtleXdvcmRcbiAgICAgIH1cblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDE0IFByb2dyYW1cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnQoKSB7XG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50cygpIHtcbiAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQgKyAxLCB0b2tlbi5lbmQgLSAxKTtcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICB2YXIgYm9keSwgbm9kZTtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHBlZWsoKTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgc3RyaWN0ID0gdHJ1ZTsgLy8gYXNzdW1lIHN0cmljdFxuXG4gICAgICBib2R5ID0gcGFyc2VTb3VyY2VFbGVtZW50cygpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvZ3JhbShib2R5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLnRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChlbnRyeS5yZWdleCkge1xuICAgICAgICAgICAgICB0b2tlbi5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGVudHJ5LnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBmbGFnczogZW50cnkucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICB0b2tlbnM7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICB9O1xuXG4gICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgb3B0aW9ucy50b2tlbnMgPSB0cnVlO1xuICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHR3byBmaWVsZHMgYXJlIG5lY2Vzc2FyeSB0byBjb21wdXRlIHRoZSBSZWdleCB0b2tlbnMuXG4gICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IC0xO1xuICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2gobGV4RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGxleEVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIHBhcmVudGhlc2lzQ291bnQ6IDAsXG4gICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgIH07XG5cbiAgICAgIGV4dHJhID0ge307XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV4dHJhLnNvdXJjZSA9IHRvU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplLFxuICAgIHBhcnNlOiBwYXJzZVxuICB9O1xuXG59KSgpOyIsInZhciBleHByID0gcmVxdWlyZSgndmVnYS1leHByZXNzaW9uJyksXG4gICAgYXJncyA9IFsnZGF0dW0nLCAnZXZlbnQnLCAnc2lnbmFscyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cHIuY29tcGlsZXIoYXJncywge1xuICBpZFdoaXRlTGlzdDogYXJncyxcbiAgZmllbGRWYXI6ICAgIGFyZ3NbMF0sXG4gIGdsb2JhbFZhcjogICBhcmdzWzJdLFxuICBmdW5jdGlvbnM6ICAgZnVuY3Rpb24oY29kZWdlbikge1xuICAgIHZhciBmbiA9IGV4cHIuZnVuY3Rpb25zKGNvZGVnZW4pO1xuICAgIGZuLmV2ZW50SXRlbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2V2ZW50LnZnLml0ZW0nOyB9O1xuICAgIGZuLmV2ZW50R3JvdXAgPSAnZXZlbnQudmcuZ2V0R3JvdXAnO1xuICAgIGZuLmV2ZW50WCA9ICdldmVudC52Zy5nZXRYJztcbiAgICBmbi5ldmVudFkgPSAnZXZlbnQudmcuZ2V0WSc7XG4gICAgZm4ub3BlbiA9ICd3aW5kb3cub3Blbic7XG4gICAgcmV0dXJuIGZuO1xuICB9XG59KTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgbG9nID0gcmVxdWlyZSgndmVnYS1sb2dnaW5nJyksXG4gICAgQ2hhbmdlU2V0ID0gZGYuQ2hhbmdlU2V0LFxuICAgIFR1cGxlID0gZGYuVHVwbGUsXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEZhY2V0b3IgPSByZXF1aXJlKCcuL0ZhY2V0b3InKTtcblxuZnVuY3Rpb24gQWdncmVnYXRlKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcblxuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZ3JvdXBieToge3R5cGU6ICdhcnJheTxmaWVsZD4nfSxcbiAgICBzdW1tYXJpemU6IHtcbiAgICAgIHR5cGU6ICdjdXN0b20nLCBcbiAgICAgIHNldDogZnVuY3Rpb24oc3VtbWFyaXplKSB7XG4gICAgICAgIHZhciBzaWduYWxEZXBzID0ge30sXG4gICAgICAgICAgICB0eCA9IHRoaXMuX3RyYW5zZm9ybSxcbiAgICAgICAgICAgIGksIGxlbiwgZiwgZmllbGRzLCBuYW1lLCBvcHM7XG5cbiAgICAgICAgaWYgKCFkbC5pc0FycmF5KGZpZWxkcyA9IHN1bW1hcml6ZSkpIHsgLy8gT2JqZWN0IHN5bnRheCBmcm9tIGRsXG4gICAgICAgICAgZmllbGRzID0gW107XG4gICAgICAgICAgZm9yIChuYW1lIGluIHN1bW1hcml6ZSkge1xuICAgICAgICAgICAgb3BzID0gZGwuYXJyYXkoc3VtbWFyaXplW25hbWVdKTtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHtmaWVsZDogbmFtZSwgb3BzOiBvcHN9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZyh4KSB7IGlmICh4LnNpZ25hbCkgc2lnbmFsRGVwc1t4LnNpZ25hbF0gPSAxOyB9XG5cbiAgICAgICAgZm9yIChpPTAsIGxlbj1maWVsZHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgICAgZiA9IGZpZWxkc1tpXTtcbiAgICAgICAgICBpZiAoZi5maWVsZC5zaWduYWwpIHsgc2lnbmFsRGVwc1tmLmZpZWxkLnNpZ25hbF0gPSAxOyB9XG4gICAgICAgICAgZGwuYXJyYXkoZi5vcHMpLmZvckVhY2goc2cpO1xuICAgICAgICAgIGRsLmFycmF5KGYuYXMpLmZvckVhY2goc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHguX2ZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdHguX2FnZ3IgPSBudWxsO1xuICAgICAgICB0eC5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgZGwua2V5cyhzaWduYWxEZXBzKSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuX2FnZ3IgID0gbnVsbDsgLy8gZGwuQWdncmVnYXRvclxuICB0aGlzLl9pbnB1dCA9IG51bGw7IC8vIFVzZWQgYnkgRmFjZXRvci5fb25fa2VlcC5cbiAgdGhpcy5fYXJncyAgPSBudWxsOyAvLyBUbyBjdWxsIHJlLWNvbXB1dGF0aW9uLlxuICB0aGlzLl9maWVsZHMgPSBbXTtcbiAgdGhpcy5fb3V0ID0gW107XG5cbiAgdGhpcy5fdHlwZSA9IFRZUEVTLlRVUExFOyBcbiAgdGhpcy5fYWNjID0ge2dyb3VwYnk6IGRsLnRydWUsIHZhbHVlOiBkbC50cnVlfTtcblxuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSkucHJvZHVjZXModHJ1ZSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoQWdncmVnYXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtLnByb3RvdHlwZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWdncmVnYXRlO1xuXG52YXIgVFlQRVMgPSBBZ2dyZWdhdGUuVFlQRVMgPSB7XG4gIFZBTFVFOiAxLCBcbiAgVFVQTEU6IDIsIFxuICBNVUxUSTogM1xufTtcblxuQWdncmVnYXRlLlZBTElEX09QUyA9IFtcbiAgJ3ZhbHVlcycsICdjb3VudCcsICd2YWxpZCcsICdtaXNzaW5nJywgJ2Rpc3RpbmN0JywgXG4gICdzdW0nLCAnbWVhbicsICdhdmVyYWdlJywgJ3ZhcmlhbmNlJywgJ3ZhcmlhbmNlcCcsICdzdGRldicsIFxuICAnc3RkZXZwJywgJ21lZGlhbicsICdxMScsICdxMycsICdtb2Rlc2tldycsICdtaW4nLCAnbWF4JywgXG4gICdhcmdtaW4nLCAnYXJnbWF4J1xuXTtcblxucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKSB7IFxuICByZXR1cm4gKHRoaXMuX3R5cGUgPSB0eXBlLCB0aGlzKTsgXG59O1xuXG5wcm90b3R5cGUuYWNjZXNzb3JzID0gZnVuY3Rpb24oZ3JvdXBieSwgdmFsdWUpIHtcbiAgdmFyIGFjYyA9IHRoaXMuX2FjYztcbiAgYWNjLmdyb3VwYnkgPSBkbC4kKGdyb3VwYnkpIHx8IGRsLnRydWU7XG4gIGFjYy52YWx1ZSA9IGRsLiQodmFsdWUpIHx8IGRsLnRydWU7XG59O1xuXG5wcm90b3R5cGUuYWdnciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fYWdncikgcmV0dXJuIHRoaXMuX2FnZ3I7XG5cbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGhhc0dldHRlciA9IGZhbHNlLFxuICAgICAgYXJncyA9IFtdLFxuICAgICAgZ3JvdXBieSA9IHRoaXMucGFyYW0oJ2dyb3VwYnknKS5maWVsZCxcbiAgICAgIHZhbHVlID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geC5zaWduYWwgPyBnLnNpZ25hbFJlZih4LnNpZ25hbCkgOiB4OyB9O1xuXG4gIC8vIFByZXBhcmUgc3VtbWFyaXplIGZpZWxkcy5cbiAgdmFyIGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBmaWVsZCA9IHtcbiAgICAgIG5hbWU6IHZhbHVlKGYuZmllbGQpLFxuICAgICAgYXM6ICAgZGwuYXJyYXkoZi5hcyksXG4gICAgICBvcHM6ICBkbC5hcnJheSh2YWx1ZShmLm9wcykpLm1hcCh2YWx1ZSksXG4gICAgICBnZXQ6ICBmLmdldFxuICAgIH07XG4gICAgaGFzR2V0dGVyID0gaGFzR2V0dGVyIHx8IGZpZWxkLmdldCAhPSBudWxsO1xuICAgIGFyZ3MucHVzaChmaWVsZC5uYW1lKTtcbiAgICByZXR1cm4gZmllbGQ7XG4gIH0pO1xuXG4gIC8vIElmIHRoZXJlIGlzIGFuIGFyYml0cmFyeSBnZXR0ZXIsIGFsbCBiZXRzIGFyZSBvZmYuXG4gIC8vIE90aGVyd2lzZSwgd2UgY2FuIGNoZWNrIGFyZ3VtZW50IGZpZWxkcyB0byBjdWxsIHJlLWNvbXB1dGF0aW9uLlxuICBncm91cGJ5LmZvckVhY2goZnVuY3Rpb24oZykge1xuICAgIGlmIChnLmdldCkgaGFzR2V0dGVyID0gdHJ1ZTtcbiAgICBhcmdzLnB1c2goZy5uYW1lIHx8IGcpO1xuICB9KTtcbiAgdGhpcy5fYXJncyA9IGhhc0dldHRlciB8fCAhZmllbGRzLmxlbmd0aCA/IG51bGwgOiBhcmdzO1xuXG4gIGlmICghZmllbGRzLmxlbmd0aCkgZmllbGRzID0geycqJzogJ3ZhbHVlcyd9O1xuXG4gIC8vIEluc3RhdGlhdGUgb3VyIGFnZ3JlZ2F0b3IgaW5zdGFuY2UuXG4gIC8vIEZhY2V0b3IgaXMgYSBzcGVjaWFsIHN1YmNsYXNzIHRoYXQgY2FuIGZhY2V0IGludG8gZGF0YSBwaXBlbGluZXMuXG4gIHZhciBhZ2dyID0gdGhpcy5fYWdnciA9IG5ldyBGYWNldG9yKClcbiAgICAuZ3JvdXBieShncm91cGJ5KVxuICAgIC5zdHJlYW0odHJ1ZSlcbiAgICAuc3VtbWFyaXplKGZpZWxkcyk7XG5cbiAgLy8gQ29sbGVjdCBvdXRwdXQgZmllbGRzIHNldHMgYnkgdGhpcyBhZ2dyZWdhdGUuXG4gIHRoaXMuX291dCA9IGdldEZpZWxkcyhhZ2dyKTtcblxuICAvLyBJZiB3ZSBhcmUgcHJvY2Vzc2luZyB0dXBsZXMsIGtleSB0aGVtIGJ5ICdfaWQnLlxuICBpZiAodGhpcy5fdHlwZSAhPT0gVFlQRVMuVkFMVUUpIHsgYWdnci5rZXkoJ19pZCcpOyB9XG5cbiAgcmV0dXJuIGFnZ3I7XG59O1xuXG5mdW5jdGlvbiBnZXRGaWVsZHMoYWdncikge1xuICAvLyBDb2xsZWN0IHRoZSBvdXRwdXQgZmllbGRzIHNldCBieSB0aGlzIGFnZ3JlZ2F0ZS5cbiAgdmFyIGYgPSBbXSwgaSwgbiwgaiwgbSwgZGltcywgdmFscywgbWVhcztcblxuICBkaW1zID0gYWdnci5fZGltcztcbiAgZm9yIChpPTAsIG49ZGltcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZi5wdXNoKGRpbXNbaV0ubmFtZSk7XG4gIH1cblxuICB2YWxzID0gYWdnci5fYWdncjtcbiAgZm9yIChpPTAsIG49dmFscy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgbWVhcyA9IHZhbHNbaV0ubWVhc3VyZXMuZmllbGRzO1xuICAgIGZvciAoaj0wLCBtPW1lYXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgZi5wdXNoKG1lYXNbal0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmO1xufVxuXG5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGxvZy5kZWJ1ZyhpbnB1dCwgWydhZ2dyZWdhdGUnXSk7XG5cbiAgdmFyIG91dHB1dCA9IENoYW5nZVNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgYWdnciA9IHRoaXMuYWdncigpLFxuICAgICAgb3V0ID0gdGhpcy5fb3V0LFxuICAgICAgYXJncyA9IHRoaXMuX2FyZ3MsXG4gICAgICByZWV2YWwgPSB0cnVlLFxuICAgICAgcCA9IFR1cGxlLnByZXYsXG4gICAgICBhZGQsIHJlbSwgbW9kLCBpO1xuXG4gIC8vIFVwb24gcmVzZXQsIHJldHJhY3QgcHJpb3IgdHVwbGVzIGFuZCByZS1pbml0aWFsaXplLlxuICBpZiAocmVzZXQpIHtcbiAgICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgYWdnci5yZXN1bHQoKSk7XG4gICAgYWdnci5jbGVhcigpO1xuICAgIHRoaXMuX2FnZ3IgPSBudWxsO1xuICAgIGFnZ3IgPSB0aGlzLmFnZ3IoKTtcbiAgfVxuXG4gIC8vIEdldCB1cGRhdGUgbWV0aG9kcyBhY2NvcmRpbmcgdG8gaW5wdXQgdHlwZS5cbiAgaWYgKHRoaXMuX3R5cGUgPT09IFRZUEVTLlRVUExFKSB7XG4gICAgYWRkID0gZnVuY3Rpb24oeCkgeyBhZ2dyLl9hZGQoeCk7IFR1cGxlLnByZXZfaW5pdCh4KTsgfTtcbiAgICByZW0gPSBmdW5jdGlvbih4KSB7IGFnZ3IuX3JlbShwKHgpKTsgfTtcbiAgICBtb2QgPSBmdW5jdGlvbih4KSB7IGFnZ3IuX21vZCh4LCBwKHgpKTsgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2J5ID0gdGhpcy5fYWNjLmdyb3VwYnksXG4gICAgICAgIHZhbCA9IHRoaXMuX2FjYy52YWx1ZSxcbiAgICAgICAgZ2V0ID0gdGhpcy5fdHlwZSA9PT0gVFlQRVMuVkFMVUUgPyB2YWwgOiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHsgX2lkOiB4Ll9pZCwgZ3JvdXBieTogZ2J5KHgpLCB2YWx1ZTogdmFsKHgpIH07XG4gICAgICAgIH07XG4gICAgYWRkID0gZnVuY3Rpb24oeCkgeyBhZ2dyLl9hZGQoZ2V0KHgpKTsgVHVwbGUucHJldl9pbml0KHgpOyB9O1xuICAgIHJlbSA9IGZ1bmN0aW9uKHgpIHsgYWdnci5fcmVtKGdldChwKHgpKSk7IH07XG4gICAgbW9kID0gZnVuY3Rpb24oeCkgeyBhZ2dyLl9tb2QoZ2V0KHgpLCBnZXQocCh4KSkpOyB9O1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goYWRkKTtcbiAgaWYgKHJlc2V0KSB7XG4gICAgLy8gQSBzaWduYWwgY2hhbmdlIHRyaWdnZXJlZCByZWZsb3cuIEFkZCBldmVyeXRoaW5nLlxuICAgIC8vIE5vIG5lZWQgZm9yIHJlbSwgd2UgY2xlYXJlZCB0aGUgYWdncmVnYXRvci5cbiAgICBpbnB1dC5tb2QuZm9yRWFjaChhZGQpO1xuICB9IGVsc2Uge1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHJlbSk7XG5cbiAgICAvLyBJZiBwb3NzaWJsZSwgY2hlY2sgYXJndW1lbnQgZmllbGRzIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlLXByb2Nlc3MgbW9kcy5cbiAgICBpZiAoYXJncykgZm9yIChpPTAsIHJlZXZhbD1mYWxzZTsgaTxhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaW5wdXQuZmllbGRzW2FyZ3NbaV1dKSB7IHJlZXZhbCA9IHRydWU7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChyZWV2YWwpIGlucHV0Lm1vZC5mb3JFYWNoKG1vZCk7XG4gIH1cblxuICAvLyBJbmRpY2F0ZSBvdXRwdXQgZmllbGRzIGFuZCByZXR1cm4gYWdncmVnYXRlIHR1cGxlcy5cbiAgZm9yIChpPTA7IGk8b3V0Lmxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0LmZpZWxkc1tvdXRbaV1dID0gMTtcbiAgfVxuICByZXR1cm4gKGFnZ3IuX2lucHV0ID0gaW5wdXQsIGFnZ3IuY2hhbmdlcyhvdXRwdXQpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRlOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBBZ2dyZWdhdG9yID0gZGwuQWdncmVnYXRvcixcbiAgICBCYXNlID0gQWdncmVnYXRvci5wcm90b3R5cGUsXG4gICAgZGYgPSByZXF1aXJlKCd2ZWdhLWRhdGFmbG93JyksXG4gICAgVHVwbGUgPSBkZi5UdXBsZSxcbiAgICBsb2cgPSByZXF1aXJlKCd2ZWdhLWxvZ2dpbmcnKSxcbiAgICBmYWNldElEID0gMDtcblxuZnVuY3Rpb24gRmFjZXRvcigpIHtcbiAgQWdncmVnYXRvci5jYWxsKHRoaXMpO1xuICB0aGlzLl9mYWNldCA9IG51bGw7XG4gIHRoaXMuX2ZhY2V0SUQgPSArK2ZhY2V0SUQ7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoRmFjZXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZhY2V0b3I7XG5cbnByb3RvdHlwZS5mYWNldCA9IGZ1bmN0aW9uKGYpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5fZmFjZXQgPSBmLCB0aGlzKSA6IHRoaXMuX2ZhY2V0O1xufTtcblxucHJvdG90eXBlLl9pbmdlc3QgPSBmdW5jdGlvbih0KSB7IFxuICByZXR1cm4gVHVwbGUuaW5nZXN0KHQsIG51bGwpO1xufTtcblxucHJvdG90eXBlLl9hc3NpZ24gPSBUdXBsZS5zZXQ7XG5cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RfY2VsbChmYWNldCkge1xuICBsb2cuZGVidWcoe30sIFsnZGlzY29ubmVjdGluZyBjZWxsJywgdGhpcy50dXBsZS5faWRdKTtcbiAgdmFyIHBpcGVsaW5lID0gdGhpcy5kcy5waXBlbGluZSgpO1xuICBmYWNldC5yZW1vdmVMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gIGZhY2V0Ll9ncmFwaC5yZW1vdmVMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gIGZhY2V0Ll9ncmFwaC5kaXNjb25uZWN0KHBpcGVsaW5lKTtcbn1cblxucHJvdG90eXBlLl9uZXdjZWxsID0gZnVuY3Rpb24oeCwga2V5KSB7XG4gIHZhciBjZWxsICA9IEJhc2UuX25ld2NlbGwuY2FsbCh0aGlzLCB4LCBrZXkpLFxuICAgICAgZmFjZXQgPSB0aGlzLl9mYWNldDtcblxuICBpZiAoZmFjZXQpIHtcbiAgICB2YXIgZ3JhcGggPSBmYWNldC5fZ3JhcGgsXG4gICAgICAgIHR1cGxlID0gY2VsbC50dXBsZSxcbiAgICAgICAgcGlwZWxpbmUgPSBmYWNldC5wYXJhbSgndHJhbnNmb3JtJyk7XG4gICAgY2VsbC5kcyA9IGdyYXBoLmRhdGEodHVwbGUuX2ZhY2V0SUQsIHBpcGVsaW5lLCB0dXBsZSk7XG4gICAgY2VsbC5kaXNjb25uZWN0ID0gZGlzY29ubmVjdF9jZWxsO1xuICAgIGZhY2V0LmFkZExpc3RlbmVyKHBpcGVsaW5lWzBdKTtcbiAgfVxuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG90eXBlLl9uZXd0dXBsZSA9IGZ1bmN0aW9uKHgsIGtleSkge1xuICB2YXIgdCA9IEJhc2UuX25ld3R1cGxlLmNhbGwodGhpcywgeCk7XG4gIGlmICh0aGlzLl9mYWNldCkge1xuICAgIFR1cGxlLnNldCh0LCAna2V5Jywga2V5KTtcbiAgICBUdXBsZS5zZXQodCwgJ19mYWNldElEJywgdGhpcy5fZmFjZXRJRCArICdfJyArIGtleSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLl9jZWxscykge1xuICAgICAgdGhpcy5fY2VsbHNba10uZGlzY29ubmVjdCh0aGlzLl9mYWNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBCYXNlLmNsZWFyLmNhbGwodGhpcyk7XG59O1xuXG5wcm90b3R5cGUuX29uX2FkZCA9IGZ1bmN0aW9uKHgsIGNlbGwpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSBjZWxsLmRzLl9pbnB1dC5hZGQucHVzaCh4KTtcbn07XG5cbnByb3RvdHlwZS5fb25fcmVtID0gZnVuY3Rpb24oeCwgY2VsbCkge1xuICBpZiAodGhpcy5fZmFjZXQpIGNlbGwuZHMuX2lucHV0LnJlbS5wdXNoKHgpO1xufTtcblxucHJvdG90eXBlLl9vbl9tb2QgPSBmdW5jdGlvbih4LCBwcmV2LCBjZWxsMCwgY2VsbDEpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSB7IC8vIFByb3BhZ2F0ZSB0dXBsZXNcbiAgICBpZiAoY2VsbDAgPT09IGNlbGwxKSB7XG4gICAgICBjZWxsMC5kcy5faW5wdXQubW9kLnB1c2goeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGwwLmRzLl9pbnB1dC5yZW0ucHVzaCh4KTtcbiAgICAgIGNlbGwxLmRzLl9pbnB1dC5hZGQucHVzaCh4KTtcbiAgICB9XG4gIH1cbn07XG5cbnByb3RvdHlwZS5fb25fZHJvcCA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgaWYgKHRoaXMuX2ZhY2V0KSBjZWxsLmRpc2Nvbm5lY3QodGhpcy5fZmFjZXQpO1xufTtcblxucHJvdG90eXBlLl9vbl9rZWVwID0gZnVuY3Rpb24oY2VsbCkge1xuICAvLyBwcm9wYWdhdGUgc29ydCwgc2lnbmFscywgZmllbGRzLCBldGMuXG4gIGlmICh0aGlzLl9mYWNldCkgZGYuQ2hhbmdlU2V0LmNvcHkodGhpcy5faW5wdXQsIGNlbGwuZHMuX2lucHV0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXRvcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgRGVwcyA9IHJlcXVpcmUoJ3ZlZ2EtZGF0YWZsb3cnKS5EZXBlbmRlbmNpZXMsXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKTtcblxudmFyIGFycmF5VHlwZSA9IC9hcnJheS9pLFxuICAgIGRhdGFUeXBlICA9IC9kYXRhL2ksXG4gICAgZmllbGRUeXBlID0gL2ZpZWxkL2ksXG4gICAgZXhwclR5cGUgID0gL2V4cHIvaSxcbiAgICB2YWxUeXBlICAgPSAvdmFsdWUvaTtcblxuZnVuY3Rpb24gUGFyYW1ldGVyKG5hbWUsIHR5cGUsIHRyYW5zZm9ybSkge1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAvLyBJZiBwYXJhbWV0ZXIgaXMgZGVmaW5lZCB3L3NpZ25hbHMsIGl0IG11c3QgYmUgcmVzb2x2ZWRcbiAgLy8gb24gZXZlcnkgcHVsc2UuXG4gIHRoaXMuX3ZhbHVlID0gW107XG4gIHRoaXMuX2FjY2Vzc29ycyA9IFtdO1xuICB0aGlzLl9yZXNvbHV0aW9uID0gZmFsc2U7XG4gIHRoaXMuX3NpZ25hbHMgPSB7fTtcbn1cblxudmFyIHByb3RvdHlwZSA9IFBhcmFtZXRlci5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGdldCgpIHtcbiAgdmFyIGlzQXJyYXkgPSBhcnJheVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpO1xuXG4gIHZhciB2YWwgPSBpc0FycmF5ID8gdGhpcy5fdmFsdWUgOiB0aGlzLl92YWx1ZVswXSxcbiAgICAgIGFjYyA9IGlzQXJyYXkgPyB0aGlzLl9hY2Nlc3NvcnMgOiB0aGlzLl9hY2Nlc3NvcnNbMF07XG5cbiAgaWYgKCFkbC5pc1ZhbGlkKGFjYykgJiYgdmFsVHlwZS50ZXN0KHRoaXMuX3R5cGUpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNEYXRhID8geyBuYW1lOiB2YWwsIHNvdXJjZTogYWNjIH0gOlxuICAgIGlzRmllbGQgPyB7IGZpZWxkOiB2YWwsIGFjY2Vzc29yOiBhY2MgfSA6IHZhbDtcbiAgfVxufVxuXG5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBncmFwaCA9IHRoaXMuX3RyYW5zZm9ybS5fZ3JhcGgsIFxuICAgICAgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBzLCBpZHgsIHZhbDtcblxuICAvLyBJZiB3ZSBkb24ndCByZXF1aXJlIHJlc29sdXRpb24sIHJldHVybiB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXG4gIGlmICghdGhpcy5fcmVzb2x1dGlvbikgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuXG4gIGlmIChpc0RhdGEpIHtcbiAgICB0aGlzLl9hY2Nlc3NvcnMgPSB0aGlzLl92YWx1ZS5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gZ3JhcGguZGF0YSh2KTsgfSk7XG4gICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpOyAvLyBUT0RPOiBzdXBwb3J0IHNpZ25hbCBhcyBkYXRhVHlwZXNcbiAgfVxuXG4gIGZvciAocyBpbiB0aGlzLl9zaWduYWxzKSB7XG4gICAgaWR4ID0gdGhpcy5fc2lnbmFsc1tzXTtcbiAgICB2YWwgPSBncmFwaC5zaWduYWxSZWYocyk7XG5cbiAgICBpZiAoaXNGaWVsZCkge1xuICAgICAgdGhpcy5fYWNjZXNzb3JzW2lkeF0gPSB0aGlzLl92YWx1ZVtpZHhdICE9IHZhbCA/IFxuICAgICAgICBkbC5hY2Nlc3Nvcih2YWwpIDogdGhpcy5fYWNjZXNzb3JzW2lkeF07XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWVbaWR4XSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgcCA9IHRoaXMsXG4gICAgICBpc0V4cHIgPSBleHByVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSk7XG5cbiAgdGhpcy5fdmFsdWUgPSBkbC5hcnJheSh2YWx1ZSkubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcodikpIHtcbiAgICAgIGlmIChpc0V4cHIpIHtcbiAgICAgICAgdmFyIGUgPSBleHByKHYpO1xuICAgICAgICBwLl90cmFuc2Zvcm0uZGVwZW5kZW5jeShEZXBzLkZJRUxEUywgIGUuZmllbGRzKTtcbiAgICAgICAgcC5fdHJhbnNmb3JtLmRlcGVuZGVuY3koRGVwcy5TSUdOQUxTLCBlLmdsb2JhbHMpO1xuICAgICAgICByZXR1cm4gZS5mbjtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaWVsZCkgeyAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgcC5fYWNjZXNzb3JzW2ldID0gZGwuYWNjZXNzb3Iodik7XG4gICAgICAgIHAuX3RyYW5zZm9ybS5kZXBlbmRlbmN5KERlcHMuRklFTERTLCBkbC5maWVsZCh2KSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGF0YSkge1xuICAgICAgICBwLl9yZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICAgICAgcC5fdHJhbnNmb3JtLmRlcGVuZGVuY3koRGVwcy5EQVRBLCB2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSBpZiAodi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdi52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHYuZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcC5fYWNjZXNzb3JzW2ldID0gZGwuYWNjZXNzb3Iodi5maWVsZCk7XG4gICAgICBwLl90cmFuc2Zvcm0uZGVwZW5kZW5jeShEZXBzLkZJRUxEUywgZGwuZmllbGQodi5maWVsZCkpO1xuICAgICAgcmV0dXJuIHYuZmllbGQ7XG4gICAgfSBlbHNlIGlmICh2LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwLl9yZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICAgIHAuX3NpZ25hbHNbdi5zaWduYWxdID0gaTtcbiAgICAgIHAuX3RyYW5zZm9ybS5kZXBlbmRlbmN5KERlcHMuU0lHTkFMUywgdi5zaWduYWwpO1xuICAgICAgcmV0dXJuIHYuc2lnbmFsO1xuICAgIH1cblxuICAgIHJldHVybiB2O1xuICB9KTtcblxuICByZXR1cm4gcC5fdHJhbnNmb3JtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbWV0ZXI7IiwidmFyIGRmID0gcmVxdWlyZSgndmVnYS1kYXRhZmxvdycpLFxuICAgIEJhc2UgPSBkZi5Ob2RlLnByb3RvdHlwZSwgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgRGVwcyA9IGRmLkRlcGVuZGVuY2llcyxcbiAgICBQYXJhbWV0ZXIgPSByZXF1aXJlKCcuL1BhcmFtZXRlcicpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oZ3JhcGgpIHtcbiAgaWYgKGdyYXBoKSBCYXNlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG59XG5cblRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocHJvdG8sIHBhcmFtcykge1xuICBwcm90by5fcGFyYW1ldGVycyA9IHByb3RvLl9wYXJhbWV0ZXJzIHx8IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIHBhcmFtcykge1xuICAgIHZhciBwID0gcGFyYW1zW25hbWVdLFxuICAgICAgICBwYXJhbSA9IG5ldyBQYXJhbWV0ZXIobmFtZSwgcC50eXBlLCBwcm90byk7XG5cbiAgICBwcm90by5fcGFyYW1ldGVyc1tuYW1lXSA9IHBhcmFtO1xuXG4gICAgaWYgKHAudHlwZSA9PT0gJ2N1c3RvbScpIHtcbiAgICAgIGlmIChwLnNldCkgcGFyYW0uc2V0ID0gcC5zZXQuYmluZChwYXJhbSk7XG4gICAgICBpZiAocC5nZXQpIHBhcmFtLmdldCA9IHAuZ2V0LmJpbmQocGFyYW0pO1xuICAgIH1cblxuICAgIGlmIChwLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHBhcmFtLnNldChwLmRlZmF1bHQpO1xuICB9XG59O1xuXG52YXIgcHJvdG90eXBlID0gKFRyYW5zZm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybTtcblxucHJvdG90eXBlLnBhcmFtID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHBhcmFtID0gdGhpcy5fcGFyYW1ldGVyc1tuYW1lXTtcbiAgcmV0dXJuIChwYXJhbSA9PT0gdW5kZWZpbmVkKSA/IHRoaXMgOlxuICAgIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSA/IHBhcmFtLmdldCgpIDogcGFyYW0uc2V0KHZhbHVlKTtcbn07XG5cbi8vIFBlcmZvcm0gdHJhbnNmb3JtYXRpb24uIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlLlxucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LyosIHJlc2V0ICovKSB7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIE1hbnkgdHJhbnNmb3JtcyBzdG9yZSBjYWNoZXMgdGhhdCBtdXN0IGJlIGludmFsaWRhdGVkIGlmXG4gIC8vIGEgc2lnbmFsIHZhbHVlIGhhcyBjaGFuZ2VkLiBcbiAgdmFyIHJlc2V0ID0gdGhpcy5fc3RhbXAgPCBpbnB1dC5zdGFtcCAmJlxuICAgIHRoaXMuZGVwZW5kZW5jeShEZXBzLlNJR05BTFMpLnJlZHVjZShmdW5jdGlvbihjLCBzKSB7XG4gICAgICByZXR1cm4gYyArPSBpbnB1dC5zaWduYWxzW3NdID8gMSA6IDA7XG4gICAgfSwgMCk7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybShpbnB1dCwgcmVzZXQpO1xufTtcblxucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKG1hcCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fb3V0cHV0KSB7XG4gICAgaWYgKG1hcFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX291dHB1dFtrZXldID0gbWFwW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgdmxFbmNEZWYgPSByZXF1aXJlKCcuL2VuY2RlZicpLFxuICB2bGVuYyA9IHJlcXVpcmUoJy4vZW5jJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRW5jb2Rpbmcoc3BlYywgdGhlbWUpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSBzY2hlbWEuaW5zdGFudGlhdGUoKSxcbiAgICAgIHNwZWNFeHRlbmRlZCA9IHNjaGVtYS51dGlsLm1lcmdlKGRlZmF1bHRzLCB0aGVtZSB8fCB7fSwgc3BlYykgO1xuXG4gICAgdGhpcy5fZGF0YSA9IHNwZWNFeHRlbmRlZC5kYXRhO1xuICAgIHRoaXMuX21hcmt0eXBlID0gc3BlY0V4dGVuZGVkLm1hcmt0eXBlO1xuICAgIHRoaXMuX2VuYyA9IHNwZWNFeHRlbmRlZC5lbmNvZGluZztcbiAgICB0aGlzLl9jb25maWcgPSBzcGVjRXh0ZW5kZWQuY29uZmlnO1xuICB9XG5cbiAgdmFyIHByb3RvID0gRW5jb2RpbmcucHJvdG90eXBlO1xuXG4gIEVuY29kaW5nLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgdGhlbWUpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gICAgICAgIHNwbGl0ID0gc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pLFxuICAgICAgICBtYXJrdHlwZSA9IHNwbGl0LnNoaWZ0KCkuc3BsaXQoYy5hc3NpZ24pWzFdLnRyaW0oKSxcbiAgICAgICAgZW5jID0gdmxlbmMuZnJvbVNob3J0aGFuZChzcGxpdCk7XG5cbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBtYXJrdHlwZTogbWFya3R5cGUsXG4gICAgICBlbmNvZGluZzogZW5jLFxuICAgICAgY29uZmlnOiBjb25maWdcbiAgICB9LCB0aGVtZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCB0aGVtZSkge1xuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoc3BlYywgdGhlbWUpO1xuICB9O1xuXG4gIHByb3RvLnRvU2hvcnRoYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICAgIHJldHVybiAnbWFyaycgKyBjLmFzc2lnbiArIHRoaXMuX21hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQodGhpcy5fZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyBzcGVjLm1hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc3BlY0Zyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgZXhjbHVkZUNvbmZpZykge1xuICAgIHJldHVybiBFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnKS50b1NwZWMoZXhjbHVkZUNvbmZpZyk7XG4gIH07XG5cbiAgcHJvdG8udG9TcGVjID0gZnVuY3Rpb24oZXhjbHVkZUNvbmZpZywgZXhjbHVkZURhdGEpIHtcbiAgICB2YXIgZW5jID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fZW5jKSxcbiAgICAgIHNwZWM7XG5cbiAgICBzcGVjID0ge1xuICAgICAgbWFya3R5cGU6IHRoaXMuX21hcmt0eXBlLFxuICAgICAgZW5jb2Rpbmc6IGVuY1xuICAgIH07XG5cbiAgICBpZiAoIWV4Y2x1ZGVDb25maWcpIHtcbiAgICAgIHNwZWMuY29uZmlnID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4Y2x1ZGVEYXRhKSB7XG4gICAgICBzcGVjLmRhdGEgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9kYXRhKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZGVmYXVsdHNcbiAgICB2YXIgZGVmYXVsdHMgPSBzY2hlbWEuaW5zdGFudGlhdGUoKTtcbiAgICByZXR1cm4gc2NoZW1hLnV0aWwuc3VidHJhY3Qoc3BlYywgZGVmYXVsdHMpO1xuICB9O1xuXG5cbiAgcHJvdG8ubWFya3R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGU7XG4gIH07XG5cbiAgcHJvdG8uaXMgPSBmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt0eXBlID09PSBtO1xuICB9O1xuXG4gIHByb3RvLmhhcyA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICAvLyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgdmxlbmMuaGFzKHRoaXMuX2VuYywgZW5jVHlwZSlcbiAgICByZXR1cm4gdGhpcy5fZW5jW2VuY1R5cGVdLm5hbWUgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBwcm90by5lbmNEZWYgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdO1xuICB9O1xuXG4gIC8vIGdldCBcImZpZWxkXCIgcmVmZXJlbmNlIGZvciB2ZWdhXG4gIHByb3RvLmZpZWxkUmVmID0gZnVuY3Rpb24oZXQsIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICByZXR1cm4gdmxFbmNEZWYuZmllbGRSZWYodGhpcy5fZW5jW2V0XSwgb3B0KTtcbiAgfTtcblxuICAvKlxuICAgKiByZXR1cm4ga2V5LXZhbHVlIHBhaXJzIG9mIGZpZWxkIG5hbWUgYW5kIGxpc3Qgb2YgZmllbGRzIG9mIHRoYXQgZmllbGQgbmFtZVxuICAgKi9cbiAgcHJvdG8uZmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZsZW5jLmZpZWxkcyh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIHByb3RvLmZpZWxkVGl0bGUgPSBmdW5jdGlvbihldCkge1xuICAgIGlmICh2bEVuY0RlZi5pc0NvdW50KHRoaXMuX2VuY1tldF0pKSB7XG4gICAgICByZXR1cm4gdmxFbmNEZWYuY291bnQuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHZhciBmbiA9IHRoaXMuX2VuY1tldF0uYWdncmVnYXRlIHx8IHRoaXMuX2VuY1tldF0udGltZVVuaXQgfHwgKHRoaXMuX2VuY1tldF0uYmluICYmICdiaW4nKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBmbi50b1VwcGVyQ2FzZSgpICsgJygnICsgdGhpcy5fZW5jW2V0XS5uYW1lICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5zY2FsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uc2NhbGUgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYXhpcyB8fCB7fTtcbiAgfTtcblxuICBwcm90by5iYW5kU2l6ZSA9IGZ1bmN0aW9uKGVuY1R5cGUsIHVzZVNtYWxsQmFuZCkge1xuICAgIHVzZVNtYWxsQmFuZCA9IHVzZVNtYWxsQmFuZCB8fFxuICAgICAgLy9pc0JhbmRJblNtYWxsTXVsdGlwbGVzXG4gICAgICAoZW5jVHlwZSA9PT0gWSAmJiB0aGlzLmhhcyhST1cpICYmIHRoaXMuaGFzKFkpKSB8fFxuICAgICAgKGVuY1R5cGUgPT09IFggJiYgdGhpcy5oYXMoQ09MKSAmJiB0aGlzLmhhcyhYKSk7XG5cbiAgICAvLyBpZiBiYW5kLnNpemUgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQsIGZvbGxvdyB0aGUgc3BlY2lmaWNhdGlvbiwgb3RoZXJ3aXNlIGRyYXcgdmFsdWUgZnJvbSBjb25maWcuXG4gICAgcmV0dXJuIHRoaXMuZW5jRGVmKGVuY1R5cGUpLmJhbmQuc2l6ZSB8fFxuICAgICAgdGhpcy5jb25maWcodXNlU21hbGxCYW5kID8gJ3NtYWxsQmFuZFNpemUnIDogJ2xhcmdlQmFuZFNpemUnKTtcbiAgfTtcblxuICAvLyByZXR1cm5zIGZhbHNlIGlmIGJpbm5pbmcgaXMgZGlzYWJsZWQsIG90aGVyd2lzZSBhbiBvYmplY3Qgd2l0aCBiaW5uaW5nIHByb3BlcnRpZXNcbiAgcHJvdG8uYmluID0gZnVuY3Rpb24oZXQpIHtcbiAgICB2YXIgYmluID0gdGhpcy5fZW5jW2V0XS5iaW47XG4gICAgaWYgKGJpbiA9PT0ge30pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGJpbiA9PT0gdHJ1ZSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heGJpbnM6IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFRcbiAgICAgIH07XG4gICAgcmV0dXJuIGJpbjtcbiAgfTtcblxuICBwcm90by52YWx1ZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0udmFsdWU7XG4gIH07XG5cbiAgcHJvdG8ubnVtYmVyRm9ybWF0ID0gZnVuY3Rpb24oZmllbGRTdGF0cykge1xuICAgIHZhciBmb3JtYXRDb25maWcgPSBmaWVsZFN0YXRzLm1heCA+IHRoaXMuY29uZmlnKCdtYXhTbWFsbE51bWJlcicpID9cbiAgICAgICdsYXJnZU51bWJlckZvcm1hdCc6ICdzbWFsbE51bWJlckZvcm1hdCc7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnKGZvcm1hdENvbmZpZyk7XG4gIH07XG5cbiAgcHJvdG8uc29ydCA9IGZ1bmN0aW9uKGV0LCBzdGF0cykge1xuICAgIHZhciBzb3J0ID0gdGhpcy5fZW5jW2V0XS5zb3J0LFxuICAgICAgZW5jID0gdGhpcy5fZW5jLFxuICAgICAgaXNUeXBlcyA9IHZsRW5jRGVmLmlzVHlwZXM7XG5cbiAgICBpZiAoKCFzb3J0IHx8IHNvcnQubGVuZ3RoPT09MCkgJiZcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0KHtlbmNvZGluZzp0aGlzLl9lbmN9LCBzdGF0cywgdHJ1ZSkgJiYgLy9IQUNLXG4gICAgICAgIHRoaXMuY29uZmlnKCd0b2dnbGVTb3J0JykgPT09IFFcbiAgICAgICkge1xuICAgICAgdmFyIHFGaWVsZCA9IGlzVHlwZXMoZW5jLngsIFtOLCBPXSkgPyBlbmMueSA6IGVuYy54O1xuXG4gICAgICBpZiAoaXNUeXBlcyhlbmNbZXRdLCBbTiwgT10pKSB7XG4gICAgICAgIHNvcnQgPSBbe1xuICAgICAgICAgIG5hbWU6IHFGaWVsZC5uYW1lLFxuICAgICAgICAgIGFnZ3JlZ2F0ZTogcUZpZWxkLmFnZ3JlZ2F0ZSxcbiAgICAgICAgICB0eXBlOiBxRmllbGQudHlwZSxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3J0O1xuICB9O1xuXG4gIHByb3RvLm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMubWFwKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8ucmVkdWNlID0gZnVuY3Rpb24oZiwgaW5pdCkge1xuICAgIHJldHVybiB2bGVuYy5yZWR1Y2UodGhpcy5fZW5jLCBmLCBpbml0KTtcbiAgfTtcblxuICBwcm90by5mb3JFYWNoID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB2bGVuYy5mb3JFYWNoKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8udHlwZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGV0KSA/IHRoaXMuX2VuY1tldF0udHlwZSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8uaXNUeXBlID0gZnVuY3Rpb24oZXQsIHR5cGUpIHtcbiAgICB2YXIgZW5jRGVmID0gdGhpcy5lbmNEZWYoZXQpO1xuICAgIHJldHVybiBlbmNEZWYgJiYgdmxFbmNEZWYuaXNUeXBlKGVuY0RlZiwgdHlwZSk7XG4gIH07XG5cblxuICBwcm90by5pc1R5cGVzID0gZnVuY3Rpb24oZXQsIHR5cGUpIHtcbiAgICB2YXIgZW5jRGVmID0gdGhpcy5lbmNEZWYoZXQpO1xuICAgIHJldHVybiBlbmNEZWYgJiYgdmxFbmNEZWYuaXNUeXBlcyhlbmNEZWYsIHR5cGUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxFbmNEZWYuaXNPcmRpbmFsU2NhbGUoZW5jb2RpbmcuZW5jRGVmKGVuY1R5cGUpKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc0RpbWVuc2lvbiA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsRW5jRGVmLmlzRGltZW5zaW9uKGVuY29kaW5nLmVuY0RlZihlbmNUeXBlKSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNNZWFzdXJlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxFbmNEZWYuaXNNZWFzdXJlKGVuY29kaW5nLmVuY0RlZihlbmNUeXBlKSk7XG4gIH07XG5cbiAgcHJvdG8uaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc0RpbWVuc2lvbih0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzTWVhc3VyZSh0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZSh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIHByb3RvLmRhdGFUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzQWdncmVnYXRlKCkgPyBBR0dSRUdBVEUgOiBSQVc7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jb2RpbmcpO1xuICB9O1xuXG4gIEVuY29kaW5nLmFsd2F5c05vT2NjbHVzaW9uID0gZnVuY3Rpb24oc3BlYykge1xuICAgIC8vIEZJWE1FIHJhdyBPeFEgd2l0aCAjIG9mIHJvd3MgPSAjIG9mIE9cbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNTdGFjayA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAvLyBGSVhNRSB1cGRhdGUgdGhpcyBvbmNlIHdlIGhhdmUgY29udHJvbCBmb3Igc3RhY2sgLi4uXG4gICAgcmV0dXJuIChzcGVjLm1hcmt0eXBlID09PSAnYmFyJyB8fCBzcGVjLm1hcmt0eXBlID09PSAnYXJlYScpICYmXG4gICAgICBzcGVjLmVuY29kaW5nLmNvbG9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGJlIHN0YWNrZWQgYW5kIHJldHVybiB0aGUgc3RhY2sgZGltZW5zdGlvbiBhbmQgdmFsdWUgZmllbGRzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzOlxuICAgKiAtIGRpbWVuc2lvbiAtIHRoZSBkaW1lbnNpb24gZmllbGRcbiAgICogLSB2YWx1ZSAtIHRoZSB2YWx1ZSBmaWVsZFxuICAgKi9cbiAgcHJvdG8uc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhY2sgPSAodGhpcy5oYXMoQ09MT1IpICYmIHRoaXMuZW5jRGVmKENPTE9SKS5zdGFjaykgPyBDT0xPUiA6XG4gICAgICAgICAgKHRoaXMuaGFzKERFVEFJTCkgJiYgdGhpcy5lbmNEZWYoREVUQUlMKS5zdGFjaykgPyBERVRBSUwgOlxuICAgICAgICAgIG51bGw7XG5cbiAgICB2YXIgcHJvcGVydGllcyA9IHN0YWNrICYmIHRoaXMuZW5jRGVmKHN0YWNrKS5zdGFjayAhPT0gdHJ1ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5jRGVmKHN0YWNrKS5zdGFjayA6XG4gICAgICAgICAgICAgICAgICAgICAgIHt9O1xuXG4gICAgaWYgKCh0aGlzLmlzKCdiYXInKSB8fCB0aGlzLmlzKCdhcmVhJykpICYmIHN0YWNrICYmIHRoaXMuaXNBZ2dyZWdhdGUoKSkge1xuXG4gICAgICB2YXIgaXNYTWVhc3VyZSA9IHRoaXMuaXNNZWFzdXJlKFgpO1xuICAgICAgdmFyIGlzWU1lYXN1cmUgPSB0aGlzLmlzTWVhc3VyZShZKTtcblxuICAgICAgaWYgKGlzWE1lYXN1cmUgJiYgIWlzWU1lYXN1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBncm91cGJ5OiBZLFxuICAgICAgICAgIHZhbHVlOiBYLFxuICAgICAgICAgIHN0YWNrOiBzdGFjayxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzWU1lYXN1cmUgJiYgIWlzWE1lYXN1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBncm91cGJ5OiBYLFxuICAgICAgICAgIHZhbHVlOiBZLFxuICAgICAgICAgIHN0YWNrOiBzdGFjayxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsOyAvLyBubyBzdGFjayBlbmNvZGluZ1xuICB9O1xuXG5cblxuICBwcm90by5kZXRhaWxzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVuY29kaW5nID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24ocmVmcywgZmllbGQsIGVuY1R5cGUpIHtcbiAgICAgIGlmICghZmllbGQuYWdncmVnYXRlICYmIChlbmNUeXBlICE9PSBYICYmIGVuY1R5cGUgIT09IFkpKSB7XG4gICAgICAgIHJlZnMucHVzaChlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmcztcbiAgICB9LCBbXSk7XG4gIH07XG5cbiAgcHJvdG8uZmFjZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVuY29kaW5nID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24ocmVmcywgZmllbGQsIGVuY1R5cGUpIHtcbiAgICAgIGlmICghZmllbGQuYWdncmVnYXRlICYmIChlbmNUeXBlID09IFJPVyB8fCBlbmNUeXBlID09IENPTCkpIHtcbiAgICAgICAgcmVmcy5wdXNoKGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWZzO1xuICAgIH0sIFtdKTtcbiAgfTtcblxuICBwcm90by5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGVuY1R5cGUsIHN0YXRzKSB7XG4gICAgcmV0dXJuIHZsRW5jRGVmLmNhcmRpbmFsaXR5KHRoaXMuZW5jRGVmKGVuY1R5cGUpLCBzdGF0cywgdGhpcy5jb25maWcoJ2ZpbHRlck51bGwnKSk7XG4gIH07XG5cbiAgcHJvdG8uaXNSYXcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNBZ2dyZWdhdGUoKTtcbiAgfTtcblxuICBwcm90by5kYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH07XG5cbiAgIC8vIHJldHVybnMgd2hldGhlciB0aGUgZW5jb2RpbmcgaGFzIHZhbHVlcyBlbWJlZGRlZFxuICBwcm90by5oYXNWYWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFscyA9IHRoaXMuZGF0YSgpLnZhbHVlcztcbiAgICByZXR1cm4gdmFscyAmJiB2YWxzLmxlbmd0aDtcbiAgfTtcblxuICBwcm90by5jb25maWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZ1tuYW1lXTtcbiAgfTtcblxuICBFbmNvZGluZy50cmFuc3Bvc2UgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgdmFyIG9sZGVuYyA9IHNwZWMuZW5jb2RpbmcsXG4gICAgICBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuY29kaW5nKTtcbiAgICBlbmMueCA9IG9sZGVuYy55O1xuICAgIGVuYy55ID0gb2xkZW5jLng7XG4gICAgZW5jLnJvdyA9IG9sZGVuYy5jb2w7XG4gICAgZW5jLmNvbCA9IG9sZGVuYy5yb3c7XG4gICAgc3BlYy5lbmNvZGluZyA9IGVuYztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICByZXR1cm4gRW5jb2Rpbmc7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBzZXR0ZXIgPSB1dGlsLnNldHRlcixcbiAgZ2V0dGVyID0gdXRpbC5nZXR0ZXIsXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIGF4aXMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5heGlzLmRlZiA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpIHtcbiAgdmFyIGlzQ29sID0gbmFtZSA9PSBDT0wsXG4gICAgaXNSb3cgPSBuYW1lID09IFJPVyxcbiAgICB0eXBlID0gaXNDb2wgPyAneCcgOiBpc1JvdyA/ICd5JyA6IG5hbWU7XG5cbiAgLy8gVE9ETzogcmVuYW1lIGRlZiB0byBheGlzRGVmIGFuZCBhdm9pZCBzaWRlIGVmZmVjdHMgd2hlcmUgcG9zc2libGUuXG5cbiAgdmFyIGRlZiA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNjYWxlOiBuYW1lLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGxheWVyOiBlbmNvZGluZy5lbmNEZWYobmFtZSkuYXhpcy5sYXllclxuICB9O1xuXG4gIHZhciBvcmllbnQgPSBheGlzLm9yaWVudChlbmNvZGluZywgbmFtZSwgc3RhdHMpO1xuICBpZiAob3JpZW50KSB7XG4gICAgZGVmLm9yaWVudCA9IG9yaWVudDtcbiAgfVxuXG4gIC8vIEFkZCBheGlzIGxhYmVsIGN1c3RvbSBzY2FsZSAoZm9yIGJpbiAvIHRpbWUpXG4gIGRlZiA9IGF4aXMubGFiZWxzLnNjYWxlKGRlZiwgZW5jb2RpbmcsIG5hbWUpO1xuICBkZWYgPSBheGlzLmxhYmVscy5mb3JtYXQoZGVmLCBlbmNvZGluZywgbmFtZSwgc3RhdHMpO1xuICBkZWYgPSBheGlzLmxhYmVscy5hbmdsZShkZWYsIGVuY29kaW5nLCBuYW1lKTtcblxuICAvLyBmb3IgeC1heGlzLCBzZXQgdGlja3MgZm9yIFEgb3Igcm90YXRlIHNjYWxlIGZvciBvcmRpbmFsIHNjYWxlXG4gIGlmIChuYW1lID09IFgpIHtcbiAgICBpZiAoKGVuY29kaW5nLmlzRGltZW5zaW9uKFgpIHx8IGVuY29kaW5nLmlzVHlwZShYLCBUKSkgJiZcbiAgICAgICAgISgnYW5nbGUnIGluIGdldHRlcihkZWYsIFsncHJvcGVydGllcycsICdsYWJlbHMnXSkpKSB7XG4gICAgICAvLyBUT0RPKGthbml0dyk6IEp1bCAxOSwgMjAxNSAtICM1MDYgYWRkIGNvbmRpdGlvbiBmb3Igcm90YXRpb25cbiAgICAgIGRlZiA9IGF4aXMubGFiZWxzLnJvdGF0ZShkZWYpO1xuICAgIH0gZWxzZSB7IC8vIFFcbiAgICAgIGRlZi50aWNrcyA9IGVuY29kaW5nLmVuY0RlZihuYW1lKS5heGlzLnRpY2tzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRpdGxlT2Zmc2V0IGRlcGVuZHMgb24gbGFiZWxzIHJvdGF0aW9uXG4gIGRlZi50aXRsZU9mZnNldCA9IGF4aXMudGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgbmFtZSk7XG5cbiAgLy9kZWYub2Zmc2V0IGlzIHVzZWQgaW4gYXhpcy5ncmlkXG4gIGlmKGlzUm93KSBkZWYub2Zmc2V0ID0gYXhpcy50aXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBZKSArIDIwO1xuICAvLyBGSVhNRShrYW5pdHcpOiBKdWwgMTksIDIwMTUgLSBvZmZzZXQgZm9yIGNvbHVtbiB3aGVuIHggaXMgcHV0IG9uIHRvcFxuXG4gIGRlZiA9IGF4aXMuZ3JpZChkZWYsIGVuY29kaW5nLCBuYW1lLCBsYXlvdXQpO1xuICBkZWYgPSBheGlzLnRpdGxlKGRlZiwgZW5jb2RpbmcsIG5hbWUsIGxheW91dCwgb3B0KTtcblxuICBpZiAoaXNSb3cgfHwgaXNDb2wpIHtcbiAgICBkZWYgPSBheGlzLmhpZGVUaWNrcyhkZWYpO1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMub3JpZW50ID0gZnVuY3Rpb24oZW5jb2RpbmcsIG5hbWUsIHN0YXRzKSB7XG4gIHZhciBvcmllbnQgPSBlbmNvZGluZy5lbmNEZWYobmFtZSkuYXhpcy5vcmllbnQ7XG4gIGlmIChvcmllbnQpIHtcbiAgICByZXR1cm4gb3JpZW50O1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IENPTCkge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmIChuYW1lID09PSBYICYmIGVuY29kaW5nLmhhcyhZKSAmJiBlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSAmJiBlbmNvZGluZy5jYXJkaW5hbGl0eShZLCBzdGF0cykgPiAzMCkge1xuICAgIC8vIHgtYXhpcyBmb3IgbG9uZyB5IC0gcHV0IG9uIHRvcFxuICAgIHJldHVybiAndG9wJztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuYXhpcy5ncmlkID0gZnVuY3Rpb24oZGVmLCBlbmNvZGluZywgbmFtZSwgbGF5b3V0KSB7XG4gIHZhciBjZWxsUGFkZGluZyA9IGxheW91dC5jZWxsUGFkZGluZyxcbiAgICBpc0NvbCA9IG5hbWUgPT0gQ09MLFxuICAgIGlzUm93ID0gbmFtZSA9PSBST1c7XG5cbiAgdmFyIF9ncmlkID0gZW5jb2RpbmcuYXhpcyhuYW1lKS5ncmlkO1xuXG4gIC8vIElmIGBncmlkYCBpcyB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgIGZvciBST1cgYW5kIENPTC4gRm9yIFhcbiAgLy8gYW5kIFksIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYCBmb3IgcXVhbnRpdGF0aXZlIGFuZCB0aW1lIGZpZWxkcyBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gIHZhciBncmlkID0gX2dyaWQgPT09IHVuZGVmaW5lZCA/XG4gICAgKG5hbWUgPT09IFJPVyB8fCBuYW1lID09PSBDT0wgfHwgZW5jb2RpbmcuaXNUeXBlcyhuYW1lLCBbUSwgVF0pKSA6XG4gICAgX2dyaWQ7XG5cbiAgaWYgKGdyaWQpIHtcbiAgICBkZWYuZ3JpZCA9IHRydWU7XG5cbiAgICBpZiAoaXNDb2wpIHtcbiAgICAgIC8vIHNldCBncmlkIHByb3BlcnR5IC0tIHB1dCB0aGUgbGluZXMgb24gdGhlIHJpZ2h0IHRoZSBjZWxsXG4gICAgICB2YXIgeU9mZnNldCA9IGVuY29kaW5nLmNvbmZpZygnY2VsbEdyaWRPZmZzZXQnKTtcblxuICAgICAgLy8gVE9ETygjNjc3KTogdGhpcyBzaG91bGQgZGVwZW5kIG9uIG9yaWVudFxuICAgICAgZGVmLnByb3BlcnRpZXMuZ3JpZCA9IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIG9mZnNldDogbGF5b3V0LmNlbGxXaWR0aCAqICgxKyBjZWxsUGFkZGluZy8yLjApLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAnY29sJyxcbiAgICAgICAgICBmaWVsZDogJ2RhdGEnXG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICB2YWx1ZTogLXlPZmZzZXQsXG4gICAgICAgIH0sXG4gICAgICAgIHkyOiB7XG4gICAgICAgICAgZmllbGQ6IHtncm91cDogJ21hcmsuZ3JvdXAuaGVpZ2h0J30sXG4gICAgICAgICAgb2Zmc2V0OiB5T2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZE9wYWNpdHknKSB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNSb3cpIHtcbiAgICAgIHZhciB4T2Zmc2V0ID0gZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZE9mZnNldCcpO1xuXG4gICAgICAvLyBUT0RPKCM2NzcpOiB0aGlzIHNob3VsZCBkZXBlbmQgb24gb3JpZW50XG4gICAgICAvLyBzZXQgZ3JpZCBwcm9wZXJ0eSAtLSBwdXQgdGhlIGxpbmVzIG9uIHRoZSB0b3BcbiAgICAgIGRlZi5wcm9wZXJ0aWVzLmdyaWQgPSB7XG4gICAgICAgIHk6IHtcbiAgICAgICAgICBvZmZzZXQ6IC1sYXlvdXQuY2VsbEhlaWdodCAqIChjZWxsUGFkZGluZy8yKSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBzY2FsZTogJ3JvdycsXG4gICAgICAgICAgZmllbGQ6ICdkYXRhJ1xuICAgICAgICB9LFxuICAgICAgICB4OiB7XG4gICAgICAgICAgdmFsdWU6IGRlZi5vZmZzZXQgLSB4T2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIHgyOiB7XG4gICAgICAgICAgZmllbGQ6IHtncm91cDogJ21hcmsuZ3JvdXAud2lkdGgnfSxcbiAgICAgICAgICBvZmZzZXQ6IGRlZi5vZmZzZXQgKyB4T2Zmc2V0LFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIG11bHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9LFxuICAgICAgICBzdHJva2VPcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkT3BhY2l0eScpIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZi5wcm9wZXJ0aWVzLmdyaWQgPSB7XG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdncmlkQ29sb3InKSB9LFxuICAgICAgICBzdHJva2VPcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2dyaWRPcGFjaXR5JykgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMuaGlkZVRpY2tzID0gZnVuY3Rpb24oZGVmKSB7XG4gIGRlZi5wcm9wZXJ0aWVzLnRpY2tzID0ge29wYWNpdHk6IHt2YWx1ZTogMH19O1xuICBkZWYucHJvcGVydGllcy5tYWpvclRpY2tzID0ge29wYWNpdHk6IHt2YWx1ZTogMH19O1xuICBkZWYucHJvcGVydGllcy5heGlzID0ge29wYWNpdHk6IHt2YWx1ZTogMH19O1xuICByZXR1cm4gZGVmO1xufTtcblxuYXhpcy50aXRsZSA9IGZ1bmN0aW9uIChkZWYsIGVuY29kaW5nLCBuYW1lLCBsYXlvdXQpIHtcbiAgdmFyIGF4ID0gZW5jb2RpbmcuZW5jRGVmKG5hbWUpLmF4aXM7XG5cbiAgaWYgKGF4LnRpdGxlKSB7XG4gICAgZGVmLnRpdGxlID0gYXgudGl0bGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgbm90IGRlZmluZWQsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGF4aXMgdGl0bGUgZnJvbSBmaWVsZCBkZWZcbiAgICB2YXIgZmllbGRUaXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSksXG4gICAgICBtYXhMZW5ndGg7XG5cbiAgICBpZiAoYXgudGl0bGVNYXhMZW5ndGgpIHtcbiAgICAgIG1heExlbmd0aCA9IGF4LnRpdGxlTWF4TGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAobmFtZT09PVgpIHtcbiAgICAgIG1heExlbmd0aCA9IGxheW91dC5jZWxsV2lkdGggLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBZKSB7XG4gICAgICBtYXhMZW5ndGggPSBsYXlvdXQuY2VsbEhlaWdodCAvIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKTtcbiAgICB9XG5cbiAgICBkZWYudGl0bGUgPSBtYXhMZW5ndGggPyB1dGlsLnRydW5jYXRlKGZpZWxkVGl0bGUsIG1heExlbmd0aCkgOiBmaWVsZFRpdGxlO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09IFJPVykge1xuICAgIGRlZi5wcm9wZXJ0aWVzLnRpdGxlID0ge1xuICAgICAgYW5nbGU6IHt2YWx1ZTogMH0sXG4gICAgICBhbGlnbjoge3ZhbHVlOiAncmlnaHQnfSxcbiAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfSxcbiAgICAgIGR5OiB7dmFsdWU6ICgtbGF5b3V0LmhlaWdodC8yKSAtMjB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmxhYmVscyA9IHt9O1xuXG4vKiogYWRkIGN1c3RvbSBsYWJlbCBmb3IgdGltZSB0eXBlIGFuZCBiaW4gKi9cbmF4aXMubGFiZWxzLnNjYWxlID0gZnVuY3Rpb24oZGVmLCBlbmNvZGluZywgbmFtZSkge1xuICAvLyB0aW1lXG4gIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmVuY0RlZihuYW1lKS50aW1lVW5pdDtcbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiB0aW1lVW5pdCAmJiAodGltZS5oYXNTY2FsZSh0aW1lVW5pdCkpKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywndGV4dCcsJ3NjYWxlJ10sICd0aW1lLScrIHRpbWVVbml0KTtcbiAgfVxuICAvLyBGSVhNRSBiaW5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIG51bWJlciBmb3JtYXQgb3IgdHJ1bmNhdGUgaWYgbWF4TGFiZWwgbGVuZ3RoIGlzIHByZXNlbnRlZC5cbiAqL1xuYXhpcy5sYWJlbHMuZm9ybWF0ID0gZnVuY3Rpb24gKGRlZiwgZW5jb2RpbmcsIG5hbWUsIHN0YXRzKSB7XG4gIHZhciBmaWVsZFN0YXRzID0gc3RhdHNbZW5jb2RpbmcuZW5jRGVmKG5hbWUpLm5hbWVdO1xuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdCkge1xuICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdDtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgUSkgfHwgZmllbGRTdGF0cy50eXBlID09PSAnbnVtYmVyJykge1xuICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5udW1iZXJGb3JtYXQoZmllbGRTdGF0cyk7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpKSB7XG4gICAgdmFyIHRpbWVVbml0ID0gZW5jb2RpbmcuZW5jRGVmKG5hbWUpLnRpbWVVbml0O1xuICAgIGlmICghdGltZVVuaXQpIHtcbiAgICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5jb25maWcoJ3RpbWVGb3JtYXQnKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVVbml0ID09PSAneWVhcicpIHtcbiAgICAgIGRlZi5mb3JtYXQgPSAnZCc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZXMobmFtZSwgW04sIE9dKSAmJiBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoKSB7XG4gICAgc2V0dGVyKGRlZixcbiAgICAgIFsncHJvcGVydGllcycsJ2xhYmVscycsJ3RleHQnLCd0ZW1wbGF0ZSddLFxuICAgICAgJ3t7IGRhdHVtLmRhdGEgfCB0cnVuY2F0ZTonICtcbiAgICAgIGVuY29kaW5nLmF4aXMobmFtZSkubWF4TGFiZWxMZW5ndGggKyAnfX0nXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmxhYmVscy5hbmdsZSA9IGZ1bmN0aW9uKGRlZiwgZW5jb2RpbmcsIG5hbWUpIHtcbiAgdmFyIGFuZ2xlID0gZW5jb2RpbmcuYXhpcyhuYW1lKS5sYWJlbEFuZ2xlO1xuICBpZiAodHlwZW9mIGFuZ2xlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGRlZjtcblxuICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnbGFiZWxzJywgJ2FuZ2xlJywgJ3ZhbHVlJ10sIGFuZ2xlKTtcbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMubGFiZWxzLnJvdGF0ZSA9IGZ1bmN0aW9uKGRlZikge1xuIHZhciBhbGlnbiA9IGRlZi5vcmllbnQgPT09J3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbmdsZScsICd2YWx1ZSddLCAyNzApO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbGlnbicsICd2YWx1ZSddLCBhbGlnbik7XG4gc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywgJ2Jhc2VsaW5lJywgJ3ZhbHVlJ10sICdtaWRkbGUnKTtcbiByZXR1cm4gZGVmO1xufTtcblxuYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uIChlbmNvZGluZywgbGF5b3V0LCBuYW1lKSB7XG4gIC8vIHJldHVybiBzcGVjaWZpZWQgdmFsdWUgaWYgc3BlY2lmaWVkXG4gIHZhciB2YWx1ZSA9IGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGVPZmZzZXQ7XG4gIGlmICh2YWx1ZSkgIHJldHVybiB2YWx1ZTtcblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvL0ZJWE1FIG1ha2UgdGhpcyBhZGp1c3RhYmxlXG4gICAgY2FzZSBST1c6IHJldHVybiAwO1xuICAgIGNhc2UgQ09MOiByZXR1cm4gMzU7XG4gIH1cbiAgcmV0dXJuIGdldHRlcihsYXlvdXQsIFtuYW1lLCAnYXhpc1RpdGxlT2Zmc2V0J10pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN1bW1hcnkgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3N0YXRzJykuc3VtbWFyeTtcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY29tcGlsaW5nIFZlZ2EtbGl0ZSBzcGVjIGludG8gVmVnYSBzcGVjLlxuICovXG52YXIgY29tcGlsZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgRW5jb2RpbmcgPSByZXF1aXJlKCcuLi9FbmNvZGluZycpLFxuICBheGlzID0gY29tcGlsZXIuYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBsZWdlbmQgPSBjb21waWxlci5sZWdlbmQgPSByZXF1aXJlKCcuL2xlZ2VuZCcpLFxuICBtYXJrcyA9IGNvbXBpbGVyLm1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpLFxuICBzY2FsZSA9IGNvbXBpbGVyLnNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG5jb21waWxlci5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG5jb21waWxlci5mYWNldCA9IHJlcXVpcmUoJy4vZmFjZXQnKTtcbmNvbXBpbGVyLmxheW91dCA9IHJlcXVpcmUoJy4vbGF5b3V0Jyk7XG5jb21waWxlci5zdGFjayA9IHJlcXVpcmUoJy4vc3RhY2snKTtcbmNvbXBpbGVyLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuY29tcGlsZXIuc3ViZmFjZXQgPSByZXF1aXJlKCcuL3N1YmZhY2V0Jyk7XG5jb21waWxlci50aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbmNvbXBpbGVyLmNvbXBpbGUgPSBmdW5jdGlvbiAoc3BlYywgc3RhdHMsIHRoZW1lKSB7XG4gIHJldHVybiBjb21waWxlci5jb21waWxlRW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNwZWMoc3BlYywgdGhlbWUpLCBzdGF0cyk7XG59O1xuXG5jb21waWxlci5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc2hvcnRoYW5kLCBzdGF0cywgY29uZmlnLCB0aGVtZSkge1xuICByZXR1cm4gY29tcGlsZXIuY29tcGlsZUVuY29kaW5nKEVuY29kaW5nLmZyb21TaG9ydGhhbmQoc2hvcnRoYW5kLCBjb25maWcsIHRoZW1lKSwgc3RhdHMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBWZWdhIHNwZWNpZmljYXRpb24gZnJvbSBhIFZlZ2EtbGl0ZSBFbmNvZGluZyBvYmplY3QuXG4gKi9cbmNvbXBpbGVyLmNvbXBpbGVFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhdHMpIHtcbiAgLy8gbm8gbmVlZCB0byBwYXNzIHN0YXRzIGlmIHlvdSBwYXNzIGluIHRoZSBkYXRhXG4gIGlmICghc3RhdHMpIHtcbiAgICBpZiAoZW5jb2RpbmcuaGFzVmFsdWVzKCkpIHtcbiAgICAgICAgc3RhdHMgPSBzdW1tYXJ5KGVuY29kaW5nLmRhdGEoKS52YWx1ZXMpLnJlZHVjZShmdW5jdGlvbihzLCBwKSB7XG4gICAgICAgIHNbcC5maWVsZF0gPSBwO1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignTm8gc3RhdHMgcHJvdmlkZWQgYW5kIGRhdGEgaXMgbm90IGVtYmVkZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXlvdXQgPSBjb21waWxlci5sYXlvdXQoZW5jb2RpbmcsIHN0YXRzKTtcblxuICB2YXIgc3BlYyA9IHtcbiAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGgsXG4gICAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHQsXG4gICAgICBwYWRkaW5nOiAnYXV0bycsXG4gICAgICBkYXRhOiBjb21waWxlci5kYXRhKGVuY29kaW5nKSxcbiAgICAgIC8vIGdsb2JhbCBzY2FsZXMgY29udGFpbnMgb25seSB0aW1lIHVuaXQgc2NhbGVzXG4gICAgICBzY2FsZXM6IGNvbXBpbGVyLnRpbWUuc2NhbGVzKGVuY29kaW5nKSxcbiAgICAgIG1hcmtzOiBbe1xuICAgICAgICBuYW1lOiAnY2VsbCcsXG4gICAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBlbnRlcjoge1xuICAgICAgICAgICAgd2lkdGg6IGxheW91dC5jZWxsV2lkdGggP1xuICAgICAgICAgICAgICAgICAgICAge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRofSA6XG4gICAgICAgICAgICAgICAgICAgICB7ZmllbGQ6IHtncm91cDogJ3dpZHRoJ319LFxuICAgICAgICAgICAgaGVpZ2h0OiBsYXlvdXQuY2VsbEhlaWdodCA/XG4gICAgICAgICAgICAgICAgICAgIHt2YWx1ZTogbGF5b3V0LmNlbGxIZWlnaHR9IDpcbiAgICAgICAgICAgICAgICAgICAge2ZpZWxkOiB7Z3JvdXA6ICdoZWlnaHQnfX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfTtcblxuICB2YXIgZ3JvdXAgPSBzcGVjLm1hcmtzWzBdO1xuXG4gIC8vIG1hcmtzXG4gIHZhciBzdHlsZSA9IGNvbXBpbGVyLnN0eWxlKGVuY29kaW5nLCBzdGF0cyksXG4gICAgbWRlZnMgPSBncm91cC5tYXJrcyA9IG1hcmtzLmRlZihlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpLFxuICAgIG1kZWYgPSBtZGVmc1ttZGVmcy5sZW5ndGggLSAxXTsgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRpcnR5IGhhY2sgYnkgcmVmYWN0b3JpbmcgdGhlIHdob2xlIGZsb3dcblxuICB2YXIgc3RhY2sgPSBlbmNvZGluZy5zdGFjaygpO1xuICBpZiAoc3RhY2spIHtcbiAgICAvLyBtb2RpZnkgbWRlZi57ZnJvbSxwcm9wZXJ0aWVzfVxuICAgIGNvbXBpbGVyLnN0YWNrKGVuY29kaW5nLCBtZGVmLCBzdGFjayk7XG4gIH1cblxuICB2YXIgbGluZVR5cGUgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5saW5lO1xuXG4gIC8vIGhhbmRsZSBzdWJmYWNldHNcbiAgdmFyIGRldGFpbHMgPSBlbmNvZGluZy5kZXRhaWxzKCk7XG5cbiAgaWYgKGRldGFpbHMubGVuZ3RoID4gMCAmJiBsaW5lVHlwZSkge1xuICAgIC8vc3ViZmFjZXQgdG8gZ3JvdXAgc3RhY2sgLyBsaW5lIHRvZ2V0aGVyIGluIG9uZSBncm91cFxuICAgIGNvbXBpbGVyLnN1YmZhY2V0KGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBhdXRvLXNvcnQgbGluZS9hcmVhIHZhbHVlc1xuICBpZiAobGluZVR5cGUgJiYgZW5jb2RpbmcuY29uZmlnKCdhdXRvU29ydExpbmUnKSkge1xuICAgIHZhciBmID0gKGVuY29kaW5nLmlzTWVhc3VyZShYKSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSkgPyBZIDogWDtcbiAgICBpZiAoIW1kZWYuZnJvbSkge1xuICAgICAgbWRlZi5mcm9tID0ge307XG4gICAgfVxuICAgIC8vIFRPRE86IHdoeSAtID9cbiAgICBtZGVmLmZyb20udHJhbnNmb3JtID0gW3t0eXBlOiAnc29ydCcsIGJ5OiAnLScgKyBlbmNvZGluZy5maWVsZFJlZihmKX1dO1xuICB9XG5cbiAgLy8gZ2V0IGEgZmxhdHRlbmVkIGxpc3Qgb2YgYWxsIHNjYWxlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHZsIHNwZWNcbiAgdmFyIHNpbmdsZVNjYWxlTmFtZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIG1kZWZzLm1hcChmdW5jdGlvbihtYXJrUHJvcHMpIHtcbiAgICByZXR1cm4gc2NhbGUubmFtZXMobWFya1Byb3BzLnByb3BlcnRpZXMudXBkYXRlKTtcbiAgfSkpO1xuXG4gIC8vIFNtYWxsIE11bHRpcGxlc1xuICBpZiAoZW5jb2RpbmcuaGFzKFJPVykgfHwgZW5jb2RpbmcuaGFzKENPTCkpIHtcbiAgICBzcGVjID0gY29tcGlsZXIuZmFjZXQoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHNwZWMsIHNpbmdsZVNjYWxlTmFtZXMsIHN0YXRzKTtcbiAgICBzcGVjLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZywgc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwLnNjYWxlcyA9IHNjYWxlLmRlZnMoc2luZ2xlU2NhbGVOYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpO1xuICAgIGdyb3VwLmF4ZXMgPSBbXTtcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFgpKSB7XG4gICAgICBncm91cC5heGVzLnB1c2goYXhpcy5kZWYoWCwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nLmhhcyhZKSkge1xuICAgICAgZ3JvdXAuYXhlcy5wdXNoKGF4aXMuZGVmKFksIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gICAgfVxuXG4gICAgZ3JvdXAubGVnZW5kcyA9IGxlZ2VuZC5kZWZzKGVuY29kaW5nLCBzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3BlYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkYXRhO1xuXG52YXIgdmxFbmNEZWYgPSByZXF1aXJlKCcuLi9lbmNkZWYnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG4vKipcbiAqIENyZWF0ZSBWZWdhJ3MgZGF0YSBhcnJheSBmcm9tIGEgZ2l2ZW4gZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtICB7RW5jb2Rpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgVmVnYSBkYXRhLlxuICogICAgICAgICAgICAgICAgIFRoaXMgYWx3YXlzIGluY2x1ZGVzIGEgXCJyYXdcIiBkYXRhIHRhYmxlLlxuICogICAgICAgICAgICAgICAgIElmIHRoZSBlbmNvZGluZyBjb250YWlucyBhZ2dyZWdhdGUgdmFsdWUsIHRoaXMgd2lsbCBhbHNvIGNyZWF0ZVxuICogICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZSB0YWJsZSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBkYXRhKGVuY29kaW5nKSB7XG4gIHZhciBkZWYgPSBbZGF0YS5yYXcoZW5jb2RpbmcpXTtcblxuICB2YXIgYWdncmVnYXRlID0gZGF0YS5hZ2dyZWdhdGUoZW5jb2RpbmcpO1xuICBpZiAoYWdncmVnYXRlKSB7XG4gICAgZGVmLnB1c2goZGF0YS5hZ2dyZWdhdGUoZW5jb2RpbmcpKTtcbiAgfVxuXG4gIC8vIFRPRE8gYWRkIFwiaGF2aW5nXCIgZmlsdGVyIGhlcmVcblxuICAvLyBhcHBlbmQgbm9uLXBvc2l0aXZlIGZpbHRlciBhdCB0aGUgZW5kIGZvciB0aGUgZGF0YSB0YWJsZVxuICBkYXRhLmZpbHRlck5vblBvc2l0aXZlKGRlZltkZWYubGVuZ3RoIC0gMV0sIGVuY29kaW5nKTtcblxuICAvLyBTdGFja1xuICB2YXIgc3RhY2sgPSBlbmNvZGluZy5zdGFjaygpO1xuICBpZiAoc3RhY2spIHtcbiAgICBkZWYucHVzaChkYXRhLnN0YWNrKGVuY29kaW5nLCBzdGFjaykpO1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn1cblxuZGF0YS5yYXcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgcmF3ID0ge25hbWU6IFJBV307XG5cbiAgLy8gRGF0YSBzb3VyY2UgKHVybCBvciBpbmxpbmUpXG4gIGlmIChlbmNvZGluZy5oYXNWYWx1ZXMoKSkge1xuICAgIHJhdy52YWx1ZXMgPSBlbmNvZGluZy5kYXRhKCkudmFsdWVzO1xuICAgIHJhdy5mb3JtYXQgPSB7dHlwZTogJ2pzb24nfTtcbiAgfSBlbHNlIHtcbiAgICByYXcudXJsID0gZW5jb2RpbmcuZGF0YSgpLnVybDtcbiAgICByYXcuZm9ybWF0ID0ge3R5cGU6IGVuY29kaW5nLmRhdGEoKS5mb3JtYXRUeXBlfTtcbiAgfVxuXG4gIC8vIFNldCBkYXRhJ3MgZm9ybWF0LnBhcnNlIGlmIG5lZWRlZFxuICB2YXIgcGFyc2UgPSBkYXRhLnJhdy5mb3JtYXRQYXJzZShlbmNvZGluZyk7XG4gIGlmIChwYXJzZSkge1xuICAgIHJhdy5mb3JtYXQucGFyc2UgPSBwYXJzZTtcbiAgfVxuXG4gIHJhdy50cmFuc2Zvcm0gPSBkYXRhLnJhdy50cmFuc2Zvcm0oZW5jb2RpbmcpO1xuICByZXR1cm4gcmF3O1xufTtcblxuZGF0YS5yYXcuZm9ybWF0UGFyc2UgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgcGFyc2U7XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihlbmNEZWYpIHtcbiAgICBpZiAoZW5jRGVmLnR5cGUgPT0gVCkge1xuICAgICAgcGFyc2UgPSBwYXJzZSB8fCB7fTtcbiAgICAgIHBhcnNlW2VuY0RlZi5uYW1lXSA9ICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKGVuY0RlZi50eXBlID09IFEpIHtcbiAgICAgIGlmICh2bEVuY0RlZi5pc0NvdW50KGVuY0RlZikpIHJldHVybjtcbiAgICAgIHBhcnNlID0gcGFyc2UgfHwge307XG4gICAgICBwYXJzZVtlbmNEZWYubmFtZV0gPSAnbnVtYmVyJztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgVmVnYSB0cmFuc2Zvcm1zIGZvciB0aGUgcmF3IGRhdGEgdGFibGUuICBUaGlzIGNhbiBpbmNsdWRlXG4gKiB0cmFuc2Zvcm1zIGZvciB0aW1lIHVuaXQsIGJpbm5pbmcgYW5kIGZpbHRlcmluZy5cbiAqL1xuZGF0YS5yYXcudHJhbnNmb3JtID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgLy8gbnVsbCBmaWx0ZXIgY29tZXMgZmlyc3Qgc28gdHJhbnNmb3JtcyBhcmUgbm90IHBlcmZvcm1lZCBvbiBudWxsIHZhbHVlc1xuICAvLyB0aW1lIGFuZCBiaW4gc2hvdWxkIGNvbWUgYmVmb3JlIGZpbHRlciBzbyB3ZSBjYW4gZmlsdGVyIGJ5IHRpbWUgYW5kIGJpblxuICByZXR1cm4gZGF0YS5yYXcudHJhbnNmb3JtLm51bGxGaWx0ZXIoZW5jb2RpbmcpLmNvbmNhdChcbiAgICBkYXRhLnJhdy50cmFuc2Zvcm0uZm9ybXVsYShlbmNvZGluZyksXG4gICAgZGF0YS5yYXcudHJhbnNmb3JtLnRpbWUoZW5jb2RpbmcpLFxuICAgIGRhdGEucmF3LnRyYW5zZm9ybS5iaW4oZW5jb2RpbmcpLFxuICAgIGRhdGEucmF3LnRyYW5zZm9ybS5maWx0ZXIoZW5jb2RpbmcpXG4gICk7XG59O1xuXG5kYXRhLnJhdy50cmFuc2Zvcm0udGltZSA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHJldHVybiBlbmNvZGluZy5yZWR1Y2UoZnVuY3Rpb24odHJhbnNmb3JtLCBlbmNEZWYsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jRGVmLnR5cGUgPT09IFQgJiYgZW5jRGVmLnRpbWVVbml0KSB7XG4gICAgICB2YXIgZmllbGRSZWYgPSBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlLCB7bm9mbjogdHJ1ZSwgZGF0dW06IHRydWV9KTtcblxuICAgICAgdHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKSxcbiAgICAgICAgZXhwcjogdGltZS5mb3JtdWxhKGVuY0RlZi50aW1lVW5pdCwgZmllbGRSZWYpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgfSwgW10pO1xufTtcblxuZGF0YS5yYXcudHJhbnNmb3JtLmJpbiA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHJldHVybiBlbmNvZGluZy5yZWR1Y2UoZnVuY3Rpb24odHJhbnNmb3JtLCBlbmNEZWYsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2RpbmcuYmluKGVuY1R5cGUpKSB7XG4gICAgICB0cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdiaW4nLFxuICAgICAgICBmaWVsZDogZW5jRGVmLm5hbWUsXG4gICAgICAgIG91dHB1dDoge3N0YXJ0OiBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKX0sXG4gICAgICAgIG1heGJpbnM6IGVuY29kaW5nLmJpbihlbmNUeXBlKS5tYXhiaW5zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgfSwgW10pO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgdGhhdCBtaWdodCBjb250YWluIGEgZmlsdGVyIHRyYW5zZm9ybSBmb3IgZmlsdGVyaW5nIG51bGwgdmFsdWUgYmFzZWQgb24gZmlsdGVyTnVsIGNvbmZpZ1xuICovXG5kYXRhLnJhdy50cmFuc2Zvcm0ubnVsbEZpbHRlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBmaWx0ZXJlZEZpZWxkcyA9IHV0aWwucmVkdWNlKGVuY29kaW5nLmZpZWxkcygpLFxuICAgIGZ1bmN0aW9uKGZpbHRlcmVkRmllbGRzLCBmaWVsZExpc3QsIGZpZWxkTmFtZSkge1xuICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJyonKSByZXR1cm4gZmlsdGVyZWRGaWVsZHM7IC8vY291bnRcblxuICAgICAgLy8gVE9ETygjNTk3KSByZXZpc2UgaG93IGZpbHRlck51bGwgaXMgc3RydWN0dXJlZC5cbiAgICAgIGlmICgoZW5jb2RpbmcuY29uZmlnKCdmaWx0ZXJOdWxsJykuUSAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1FdKSB8fFxuICAgICAgICAgIChlbmNvZGluZy5jb25maWcoJ2ZpbHRlck51bGwnKS5UICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbVF0pIHx8XG4gICAgICAgICAgKGVuY29kaW5nLmNvbmZpZygnZmlsdGVyTnVsbCcpLk8gJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtPXSkgfHxcbiAgICAgICAgICAoZW5jb2RpbmcuY29uZmlnKCdmaWx0ZXJOdWxsJykuTiAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW05dKSkge1xuICAgICAgICBmaWx0ZXJlZEZpZWxkcy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsdGVyZWRGaWVsZHM7XG4gICAgfSwgW10pO1xuXG4gIHJldHVybiBmaWx0ZXJlZEZpZWxkcy5sZW5ndGggPiAwID9cbiAgICBbe1xuICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICB0ZXN0OiBmaWx0ZXJlZEZpZWxkcy5tYXAoZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gICAgICAgIHJldHVybiAnZGF0dW0uJyArIGZpZWxkTmFtZSArICchPT1udWxsJztcbiAgICAgIH0pLmpvaW4oJyAmJiAnKVxuICAgIH1dIDogW107XG59O1xuXG5kYXRhLnJhdy50cmFuc2Zvcm0uZmlsdGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIGZpbHRlciA9IGVuY29kaW5nLmRhdGEoKS5maWx0ZXI7XG4gIHJldHVybiBmaWx0ZXIgPyBbe1xuICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICB0ZXN0OiBmaWx0ZXJcbiAgfV0gOiBbXTtcbn07XG5cbmRhdGEucmF3LnRyYW5zZm9ybS5mb3JtdWxhID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIGZvcm11bGFzID0gZW5jb2RpbmcuZGF0YSgpLmZvcm11bGFzO1xuICBpZiAoZm9ybXVsYXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBmb3JtdWxhcy5yZWR1Y2UoZnVuY3Rpb24odHJhbnNmb3JtLCBmb3JtdWxhKSB7XG4gICAgZm9ybXVsYS50eXBlID0gJ2Zvcm11bGEnO1xuICAgIHRyYW5zZm9ybS5wdXNoKGZvcm11bGEpO1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH0sIFtdKTtcbn07XG5cbmRhdGEuYWdncmVnYXRlID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgLyogZGljdCBzZXQgZm9yIGRpbWVuc2lvbnMgKi9cbiAgdmFyIGRpbXMgPSB7fTtcblxuICAvKiBkaWN0aW9uYXJ5IG1hcHBpbmcgZmllbGQgbmFtZSA9PiBkaWN0IHNldCBvZiBhZ2dyZWdhdGlvbiBmdW5jdGlvbnMgKi9cbiAgdmFyIG1lYXMgPSB7fTtcblxuICB2YXIgaGFzQWdncmVnYXRlID0gZmFsc2U7XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihlbmNEZWYsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jRGVmLmFnZ3JlZ2F0ZSkge1xuICAgICAgaGFzQWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgIGlmIChlbmNEZWYuYWdncmVnYXRlID09PSAnY291bnQnKSB7XG4gICAgICAgIG1lYXNbJyonXSA9IG1lYXNbJyonXSB8fCB7fTtcbiAgICAgICAgbWVhc1snKiddLmNvdW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lYXNbZW5jRGVmLm5hbWVdID0gbWVhc1tlbmNEZWYubmFtZV0gfHwge307XG4gICAgICAgIG1lYXNbZW5jRGVmLm5hbWVdW2VuY0RlZi5hZ2dyZWdhdGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGltc1tlbmNEZWYubmFtZV0gPSBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBncm91cGJ5ID0gdXRpbC52YWxzKGRpbXMpO1xuXG4gIC8vIHNob3J0LWZvcm1hdCBzdW1tYXJpemUgb2JqZWN0IGZvciBWZWdhJ3MgYWdncmVnYXRlIHRyYW5zZm9ybVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhL3dpa2kvRGF0YS1UcmFuc2Zvcm1zIy1hZ2dyZWdhdGVcbiAgdmFyIHN1bW1hcml6ZSA9IHV0aWwucmVkdWNlKG1lYXMsIGZ1bmN0aW9uKHN1bW1hcml6ZSwgZm5EaWN0U2V0LCBmaWVsZCkge1xuICAgIHN1bW1hcml6ZVtmaWVsZF0gPSB1dGlsLmtleXMoZm5EaWN0U2V0KTtcbiAgICByZXR1cm4gc3VtbWFyaXplO1xuICB9LCB7fSk7XG5cbiAgaWYgKGhhc0FnZ3JlZ2F0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBBR0dSRUdBVEUsXG4gICAgICBzb3VyY2U6IFJBVyxcbiAgICAgIHRyYW5zZm9ybTogW3tcbiAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICAgIGdyb3VwYnk6IGdyb3VwYnksXG4gICAgICAgIHN1bW1hcml6ZTogc3VtbWFyaXplXG4gICAgICB9XVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQWRkIHN0YWNrZWQgZGF0YSBzb3VyY2UsIGZvciBmZWVkaW5nIHRoZSBzaGFyZWQgc2NhbGUuXG4gKi9cbmRhdGEuc3RhY2sgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhY2spIHtcbiAgdmFyIGRpbSA9IHN0YWNrLmdyb3VwYnk7XG4gIHZhciB2YWwgPSBzdGFjay52YWx1ZTtcbiAgdmFyIGZhY2V0cyA9IGVuY29kaW5nLmZhY2V0cygpO1xuXG4gIHZhciBzdGFja2VkID0ge1xuICAgIG5hbWU6IFNUQUNLRUQsXG4gICAgc291cmNlOiBlbmNvZGluZy5kYXRhVGFibGUoKSxcbiAgICB0cmFuc2Zvcm06IFt7XG4gICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgIGdyb3VwYnk6IFtlbmNvZGluZy5maWVsZFJlZihkaW0pXS5jb25jYXQoZmFjZXRzKSwgLy8gZGltIGFuZCBvdGhlciBmYWNldHNcbiAgICAgIHN1bW1hcml6ZTogW3tvcHM6IFsnc3VtJ10sIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZih2YWwpfV1cbiAgICB9XVxuICB9O1xuXG4gIGlmIChmYWNldHMgJiYgZmFjZXRzLmxlbmd0aCA+IDApIHtcbiAgICBzdGFja2VkLnRyYW5zZm9ybS5wdXNoKHsgLy9jYWxjdWxhdGUgbWF4IGZvciBlYWNoIGZhY2V0XG4gICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgIGdyb3VwYnk6IGZhY2V0cyxcbiAgICAgIHN1bW1hcml6ZTogW3tcbiAgICAgICAgb3BzOiBbJ21heCddLFxuICAgICAgICAvLyB3ZSB3YW50IG1heCBvZiBzdW0gZnJvbSBhYm92ZSB0cmFuc2Zvcm1cbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKHZhbCwge3ByZWZuOiAnc3VtXyd9KVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3RhY2tlZDtcbn07XG5cbmRhdGEuZmlsdGVyTm9uUG9zaXRpdmUgPSBmdW5jdGlvbihkYXRhVGFibGUsIGVuY29kaW5nKSB7XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZW5jRGVmLCBlbmNUeXBlKSB7XG4gICAgaWYgKGVuY29kaW5nLnNjYWxlKGVuY1R5cGUpLnR5cGUgPT09ICdsb2cnKSB7XG4gICAgICBkYXRhVGFibGUudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnZmlsdGVyJyxcbiAgICAgICAgdGVzdDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSwge2RhdHVtOiAxfSkgKyAnID4gMCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBzY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWNldGluZztcblxuZnVuY3Rpb24gZ3JvdXBkZWYobmFtZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGdyb3VwID0ge1xuICAgIG5hbWU6IG5hbWUgfHwgdW5kZWZpbmVkLFxuICAgIHR5cGU6ICdncm91cCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgd2lkdGg6IG9wdC53aWR0aCB8fCB7ZmllbGQ6IHtncm91cDogJ3dpZHRoJ319LFxuICAgICAgICBoZWlnaHQ6IG9wdC5oZWlnaHQgfHwge2ZpZWxkOiB7Z3JvdXA6ICdoZWlnaHQnfX1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKG9wdC5mcm9tKSB7XG4gICAgZ3JvdXAuZnJvbSA9IG9wdC5mcm9tO1xuICB9XG4gIGlmIChvcHQueCkge1xuICAgIGdyb3VwLnByb3BlcnRpZXMuZW50ZXIueCA9IG9wdC54O1xuICB9XG4gIGlmIChvcHQueSkge1xuICAgIGdyb3VwLnByb3BlcnRpZXMuZW50ZXIueSA9IG9wdC55O1xuICB9XG4gIGlmIChvcHQuYXhlcykge1xuICAgIGdyb3VwLmF4ZXMgPSBvcHQuYXhlcztcbiAgfVxuXG4gIHJldHVybiBncm91cDtcbn1cblxuZnVuY3Rpb24gZmFjZXRpbmcoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHNwZWMsIHNpbmdsZVNjYWxlTmFtZXMsIHN0YXRzKSB7XG4gIHZhciBlbnRlciA9IGdyb3VwLnByb3BlcnRpZXMuZW50ZXI7XG4gIHZhciBmYWNldEtleXMgPSBbXSwgY2VsbEF4ZXMgPSBbXSwgZnJvbSwgYXhlc0dycDtcblxuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpO1xuXG4gIGVudGVyLmZpbGwgPSB7dmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEJhY2tncm91bmRDb2xvcicpfTtcblxuICAvL21vdmUgXCJmcm9tXCIgdG8gY2VsbCBsZXZlbCBhbmQgYWRkIGZhY2V0IHRyYW5zZm9ybVxuICBncm91cC5mcm9tID0ge2RhdGE6IGdyb3VwLm1hcmtzWzBdLmZyb20uZGF0YX07XG5cbiAgLy8gSGFjaywgdGhpcyBuZWVkcyB0byBiZSByZWZhY3RvcmVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWFyayA9IGdyb3VwLm1hcmtzW2ldO1xuICAgIGlmIChtYXJrLmZyb20udHJhbnNmb3JtKSB7XG4gICAgICBkZWxldGUgbWFyay5mcm9tLmRhdGE7IC8vbmVlZCB0byBrZWVwIHRyYW5zZm9ybSBmb3Igc3ViZmFjZXR0aW5nIGNhc2VcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hcmsuZnJvbTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzUm93KSB7XG4gICAgaWYgKCFlbmNvZGluZy5pc0RpbWVuc2lvbihST1cpKSB7XG4gICAgICB1dGlsLmVycm9yKCdSb3cgZW5jb2Rpbmcgc2hvdWxkIGJlIG9yZGluYWwuJyk7XG4gICAgfVxuICAgIGVudGVyLnkgPSB7c2NhbGU6IFJPVywgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKFJPVyl9O1xuICAgIGVudGVyLmhlaWdodCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkUmVmKFJPVykpO1xuXG4gICAgaWYgKGhhc0NvbCkge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGdyb3VwYnk6IFtlbmNvZGluZy5maWVsZFJlZihDT0wpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneC1heGVzJywge1xuICAgICAgICBheGVzOiBlbmNvZGluZy5oYXMoWCkgPyBbYXhpcy5kZWYoWCwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgeDogaGFzQ29sID8ge3NjYWxlOiBDT0wsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihDT0wpfSA6IHt2YWx1ZTogMH0sXG4gICAgICAgIHdpZHRoOiBoYXNDb2wgJiYgeyd2YWx1ZSc6IGxheW91dC5jZWxsV2lkdGh9LCAvL0hBQ0s/XG4gICAgICAgIGZyb206IGZyb21cbiAgICAgIH0pO1xuXG4gICAgc3BlYy5tYXJrcy51bnNoaWZ0KGF4ZXNHcnApOyAvLyBuZWVkIHRvIHByZXBlbmQgc28gaXQgYXBwZWFycyB1bmRlciB0aGUgcGxvdHNcbiAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICBzcGVjLmF4ZXMucHVzaChheGlzLmRlZihST1csIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSByb3dcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFgpKSB7XG4gICAgICAvL2tlZXAgeCBheGlzIGluIHRoZSBjZWxsXG4gICAgICBjZWxsQXhlcy5wdXNoKGF4aXMuZGVmKFgsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc0NvbCkge1xuICAgIGlmICghZW5jb2RpbmcuaXNEaW1lbnNpb24oQ09MKSkge1xuICAgICAgdXRpbC5lcnJvcignQ29sIGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLicpO1xuICAgIH1cbiAgICBlbnRlci54ID0ge3NjYWxlOiBDT0wsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihDT0wpfTtcbiAgICBlbnRlci53aWR0aCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofTsgLy8gSEFDS1xuXG4gICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGRSZWYoQ09MKSk7XG5cbiAgICBpZiAoaGFzUm93KSB7XG4gICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogJ2ZhY2V0JywgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkUmVmKFJPVyldfSk7XG4gICAgfVxuXG4gICAgYXhlc0dycCA9IGdyb3VwZGVmKCd5LWF4ZXMnLCB7XG4gICAgICBheGVzOiBlbmNvZGluZy5oYXMoWSkgPyBbYXhpcy5kZWYoWSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpXSA6IHVuZGVmaW5lZCxcbiAgICAgIHk6IGhhc1JvdyAmJiB7c2NhbGU6IFJPVywgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKFJPVyl9LFxuICAgICAgeDogaGFzUm93ICYmIHt2YWx1ZTogMH0sXG4gICAgICBoZWlnaHQ6IGhhc1JvdyAmJiB7J3ZhbHVlJzogbGF5b3V0LmNlbGxIZWlnaHR9LCAvL0hBQ0s/XG4gICAgICBmcm9tOiBmcm9tXG4gICAgfSk7XG5cbiAgICBzcGVjLm1hcmtzLnVuc2hpZnQoYXhlc0dycCk7IC8vIG5lZWQgdG8gcHJlcGVuZCBzbyBpdCBhcHBlYXJzIHVuZGVyIHRoZSBwbG90c1xuICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pO1xuICAgIHNwZWMuYXhlcy5wdXNoKGF4aXMuZGVmKENPTCwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgfSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIGNvbFxuICAgIGlmIChlbmNvZGluZy5oYXMoWSkpIHtcbiAgICAgIGNlbGxBeGVzLnB1c2goYXhpcy5kZWYoWSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3N1bWluZyBlcXVhbCBjZWxsV2lkdGggaGVyZVxuICAvLyBUT0RPOiBzdXBwb3J0IGhldGVyb2dlbm91cyBjZWxsV2lkdGggKG1heWJlIGJ5IHVzaW5nIG11bHRpcGxlIHNjYWxlcz8pXG4gIHNwZWMuc2NhbGVzID0gKHNwZWMuc2NhbGVzIHx8IFtdKS5jb25jYXQoc2NhbGUuZGVmcyhcbiAgICBzY2FsZS5uYW1lcyhlbnRlcikuY29uY2F0KHNpbmdsZVNjYWxlTmFtZXMpLFxuICAgIGVuY29kaW5nLFxuICAgIGxheW91dCxcbiAgICBzdGF0cyxcbiAgICB0cnVlXG4gICkpOyAvLyByb3cvY29sIHNjYWxlcyArIGNlbGwgc2NhbGVzXG5cbiAgaWYgKGNlbGxBeGVzLmxlbmd0aCA+IDApIHtcbiAgICBncm91cC5heGVzID0gY2VsbEF4ZXM7XG4gIH1cblxuICAvLyBhZGQgZmFjZXQgdHJhbnNmb3JtXG4gIHZhciB0cmFucyA9IChncm91cC5mcm9tLnRyYW5zZm9ybSB8fCAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gPSBbXSkpO1xuICB0cmFucy51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBncm91cGJ5OiBmYWNldEtleXN9KTtcblxuICByZXR1cm4gc3BlYztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgZDNfZm9ybWF0ID0gcmVxdWlyZSgnZDMtZm9ybWF0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdmxsYXlvdXQ7XG5cbmZ1bmN0aW9uIHZsbGF5b3V0KGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgbGF5b3V0ID0gYm94KGVuY29kaW5nLCBzdGF0cyk7XG4gIGxheW91dCA9IG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qXG4gIEhBQ0sgdG8gc2V0IGNoYXJ0IHNpemVcbiAgTk9URTogdGhpcyBmYWlscyBmb3IgcGxvdHMgZHJpdmVuIGJ5IGRlcml2ZWQgdmFsdWVzIChlLmcuLCBhZ2dyZWdhdGVzKVxuICBPbmUgc29sdXRpb24gaXMgdG8gdXBkYXRlIFZlZ2EgdG8gc3VwcG9ydCBhdXRvLXNpemluZ1xuICBJbiB0aGUgbWVhbnRpbWUsIGF1dG8tcGFkZGluZyAobW9zdGx5KSBkb2VzIHRoZSB0cmlja1xuICovXG5mdW5jdGlvbiBib3goZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSxcbiAgICAgIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpLFxuICAgICAgaGFzWCA9IGVuY29kaW5nLmhhcyhYKSxcbiAgICAgIGhhc1kgPSBlbmNvZGluZy5oYXMoWSksXG4gICAgICBtYXJrdHlwZSA9IGVuY29kaW5nLm1hcmt0eXBlKCk7XG5cbiAgLy8gRklYTUUvSEFDSyB3ZSBuZWVkIHRvIHRha2UgZmlsdGVyIGludG8gYWNjb3VudFxuICB2YXIgeENhcmRpbmFsaXR5ID0gaGFzWCAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihYKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFgsIHN0YXRzKSA6IDEsXG4gICAgeUNhcmRpbmFsaXR5ID0gaGFzWSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFksIHN0YXRzKSA6IDE7XG5cbiAgdmFyIHVzZVNtYWxsQmFuZCA9IHhDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKSB8fFxuICAgIHlDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKTtcblxuICB2YXIgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBjZWxsUGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcblxuICAvLyBzZXQgY2VsbFdpZHRoXG4gIGlmIChoYXNYKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFgpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbFdpZHRoID0gKHhDYXJkaW5hbGl0eSArIGVuY29kaW5nLmVuY0RlZihYKS5iYW5kLnBhZGRpbmcpICogZW5jb2RpbmcuYmFuZFNpemUoWCwgdXNlU21hbGxCYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbFdpZHRoID0gaGFzQ29sIHx8IGhhc1JvdyA/IGVuY29kaW5nLmVuY0RlZihDT0wpLndpZHRoIDogIGVuY29kaW5nLmNvbmZpZygnc2luZ2xlV2lkdGgnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1hcmt0eXBlID09PSBURVhUKSB7XG4gICAgICBjZWxsV2lkdGggPSBlbmNvZGluZy5jb25maWcoJ3RleHRDZWxsV2lkdGgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWCk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGNlbGxIZWlnaHRcbiAgaWYgKGhhc1kpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWSkpIHtcbiAgICAgIC8vIGZvciBvcmRpbmFsLCBoYXNDb2wgb3Igbm90IGRvZXNuJ3QgbWF0dGVyIC0tIHdlIHNjYWxlIGJhc2VkIG9uIGNhcmRpbmFsaXR5XG4gICAgICBjZWxsSGVpZ2h0ID0gKHlDYXJkaW5hbGl0eSArIGVuY29kaW5nLmVuY0RlZihZKS5iYW5kLnBhZGRpbmcpICogZW5jb2RpbmcuYmFuZFNpemUoWSwgdXNlU21hbGxCYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbEhlaWdodCA9IGhhc0NvbCB8fCBoYXNSb3cgPyBlbmNvZGluZy5lbmNEZWYoUk9XKS5oZWlnaHQgOiAgZW5jb2RpbmcuY29uZmlnKCdzaW5nbGVIZWlnaHQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2VsbEhlaWdodCA9IGVuY29kaW5nLmJhbmRTaXplKFkpO1xuICB9XG5cbiAgLy8gQ2VsbCBiYW5kcyB1c2UgcmFuZ2VCYW5kcygpLiBUaGVyZSBhcmUgbi0xIHBhZGRpbmcuICBPdXRlcnBhZGRpbmcgPSAwIGZvciBjZWxsc1xuXG4gIHZhciB3aWR0aCA9IGNlbGxXaWR0aCwgaGVpZ2h0ID0gY2VsbEhlaWdodDtcbiAgaWYgKGhhc0NvbCkge1xuICAgIHZhciBjb2xDYXJkaW5hbGl0eSA9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIHdpZHRoID0gY2VsbFdpZHRoICogKCgxICsgY2VsbFBhZGRpbmcpICogKGNvbENhcmRpbmFsaXR5IC0gMSkgKyAxKTtcbiAgfVxuICBpZiAoaGFzUm93KSB7XG4gICAgdmFyIHJvd0NhcmRpbmFsaXR5ID0gIGVuY29kaW5nLmNhcmRpbmFsaXR5KFJPVywgc3RhdHMpO1xuICAgIGhlaWdodCA9IGNlbGxIZWlnaHQgKiAoKDEgKyBjZWxsUGFkZGluZykgKiAocm93Q2FyZGluYWxpdHkgLSAxKSArIDEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB3aG9sZSBjZWxsXG4gICAgY2VsbFdpZHRoOiBjZWxsV2lkdGgsXG4gICAgY2VsbEhlaWdodDogY2VsbEhlaWdodCxcbiAgICBjZWxsUGFkZGluZzogY2VsbFBhZGRpbmcsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2hhcnRcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgeCBhbmQgeSwgc3VjaCBhcyBiYW5kIHNpemVcbiAgICB4OiB7dXNlU21hbGxCYW5kOiB1c2VTbWFsbEJhbmR9LFxuICAgIHk6IHt1c2VTbWFsbEJhbmQ6IHVzZVNtYWxsQmFuZH1cbiAgfTtcbn1cblxuXG4vLyBGSVhNRSBmaWVsZFN0YXRzLm1heCBpc24ndCBhbHdheXMgdGhlIGxvbmdlc3RcbmZ1bmN0aW9uIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpIHtcbiAgdmFyIGZvcm1hdCA9IGVuY29kaW5nLm51bWJlckZvcm1hdChldCwgZmllbGRTdGF0cyk7XG5cbiAgcmV0dXJuIGQzX2Zvcm1hdC5mb3JtYXQoZm9ybWF0KShmaWVsZFN0YXRzLm1heCkubGVuZ3RoO1xufVxuXG4vLyBUT0RPKCM2MDApIHJldmlzZSB0aGlzXG5mdW5jdGlvbiBnZXRNYXhMZW5ndGgoZW5jb2RpbmcsIHN0YXRzLCBldCkge1xuICB2YXIgZW5jRGVmID0gZW5jb2RpbmcuZW5jRGVmKGV0KSxcbiAgICBmaWVsZFN0YXRzID0gc3RhdHNbZW5jRGVmLm5hbWVdO1xuXG4gIGlmIChlbmNEZWYuYmluKSB7XG4gICAgLy8gVE9ETyBvbmNlIGJpbiBzdXBwb3J0IHJhbmdlLCBuZWVkIHRvIHVwZGF0ZSB0aGlzXG4gICAgcmV0dXJuIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpO1xuICB9IGlmIChlbmNvZGluZy5pc1R5cGUoZXQsIFEpKSB7XG4gICAgcmV0dXJuIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShldCwgVCkpIHtcbiAgICByZXR1cm4gdGltZS5tYXhMZW5ndGgoZW5jb2RpbmcuZW5jRGVmKGV0KS50aW1lVW5pdCwgZW5jb2RpbmcpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZXMoZXQsIFtOLCBPXSkpIHtcbiAgICBpZihmaWVsZFN0YXRzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gZ2V0TWF4TnVtYmVyTGVuZ3RoKGVuY29kaW5nLCBldCwgZmllbGRTdGF0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihmaWVsZFN0YXRzLm1heCwgZW5jb2RpbmcuYXhpcyhldCkubWF4TGFiZWxMZW5ndGggfHwgSW5maW5pdHkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZzZXQoZW5jb2RpbmcsIHN0YXRzLCBsYXlvdXQpIHtcbiAgW1gsIFldLmZvckVhY2goZnVuY3Rpb24gKGV0KSB7XG4gICAgLy8gVE9ETyhrYW5pdHcpOiBKdWwgMTksIDIwMTUgLSBjcmVhdGUgYSBzZXQgb2YgdmlzdWFsIHRlc3QgZm9yIGV4dHJhT2Zmc2V0XG4gICAgdmFyIGV4dHJhT2Zmc2V0ID0gZXQgPT09IFggPyAyMCA6IDIyLFxuICAgICAgbWF4TGVuZ3RoO1xuICAgIGlmIChlbmNvZGluZy5pc0RpbWVuc2lvbihldCkgfHwgZW5jb2RpbmcuaXNUeXBlKGV0LCBUKSkge1xuICAgICAgbWF4TGVuZ3RoID0gZ2V0TWF4TGVuZ3RoKGVuY29kaW5nLCBzdGF0cywgZXQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBUT0RPIG9uY2Ugd2UgaGF2ZSAjNTEyIChhbGxvdyB1c2luZyBpbmZlcnJlZCB0eXBlKVxuICAgICAgLy8gTmVlZCB0byBhZGp1c3QgY29uZGl0aW9uIGhlcmUuXG4gICAgICBlbmNvZGluZy5pc1R5cGUoZXQsIFEpIHx8XG4gICAgICBlbmNvZGluZy5lbmNEZWYoZXQpLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50J1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBldD09PVlcbiAgICAgICAgLy8gfHwgKGV0PT09WCAmJiBmYWxzZSlcbiAgICAgICAgLy8gRklYTUUgZGV0ZXJtaW5lIHdoZW4gWCB3b3VsZCByb3RhdGUsIGJ1dCBzaG91bGQgbW92ZSB0aGlzIHRvIGF4aXMuanMgZmlyc3QgIzUwNlxuICAgICAgKSB7XG4gICAgICAgIG1heExlbmd0aCA9IGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90aGluZ1xuICAgIH1cblxuICAgIGlmIChtYXhMZW5ndGgpIHtcbiAgICAgIHNldHRlcihsYXlvdXQsW2V0LCAnYXhpc1RpdGxlT2Zmc2V0J10sIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKSAqICBtYXhMZW5ndGggKyBleHRyYU9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vIG1heCBsZW5ndGggKG5vIHJvdGF0aW9uIGNhc2UpLCB1c2UgbWF4TGVuZ3RoID0gM1xuICAgICAgc2V0dGVyKGxheW91dCxbZXQsICdheGlzVGl0bGVPZmZzZXQnXSwgZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpICogMyArIGV4dHJhT2Zmc2V0KTtcbiAgICB9XG5cbiAgfSk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIGdldHRlciA9IHV0aWwuZ2V0dGVyO1xuXG52YXIgbGVnZW5kID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubGVnZW5kLmRlZnMgPSBmdW5jdGlvbihlbmNvZGluZywgc3R5bGUpIHtcbiAgdmFyIGRlZnMgPSBbXTtcblxuICBpZiAoZW5jb2RpbmcuaGFzKENPTE9SKSAmJiBlbmNvZGluZy5lbmNEZWYoQ09MT1IpLmxlZ2VuZCkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKENPTE9SLCBlbmNvZGluZywge1xuICAgICAgZmlsbDogQ09MT1JcbiAgICB9LCBzdHlsZSkpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmhhcyhTSVpFKSAmJiBlbmNvZGluZy5lbmNEZWYoU0laRSkubGVnZW5kKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoU0laRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNpemU6IFNJWkVcbiAgICB9LCBzdHlsZSkpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmhhcyhTSEFQRSkgJiYgZW5jb2RpbmcuZW5jRGVmKFNIQVBFKS5sZWdlbmQpIHtcbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihTSEFQRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNoYXBlOiBTSEFQRVxuICAgIH0sIHN0eWxlKSk7XG4gIH1cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5sZWdlbmQuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIGRlZiwgc3R5bGUpIHtcbiAgdmFyIHRpbWVVbml0ID0gZW5jb2RpbmcuZW5jRGVmKG5hbWUpLnRpbWVVbml0O1xuXG4gIGRlZi50aXRsZSA9IGxlZ2VuZC50aXRsZShuYW1lLCBlbmNvZGluZyk7XG4gIGRlZi5vcmllbnQgPSBlbmNvZGluZy5lbmNEZWYobmFtZSkubGVnZW5kLm9yaWVudDtcblxuICBkZWYgPSBsZWdlbmQuc3R5bGUobmFtZSwgZW5jb2RpbmcsIGRlZiwgc3R5bGUpO1xuXG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiZcbiAgICB0aW1lVW5pdCAmJlxuICAgIHRpbWUuaGFzU2NhbGUodGltZVVuaXQpXG4gICkge1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdsYWJlbHMnLCAndGV4dCcsICdzY2FsZSddLCAndGltZS0nKyB0aW1lVW5pdCk7XG4gIH1cblxuICByZXR1cm4gZGVmO1xufTtcblxubGVnZW5kLnN0eWxlID0gZnVuY3Rpb24obmFtZSwgZSwgZGVmLCBzdHlsZSkge1xuICB2YXIgc3ltYm9scyA9IGdldHRlcihkZWYsIFsncHJvcGVydGllcycsICdzeW1ib2xzJ10pLFxuICAgIG1hcmt0eXBlID0gZS5tYXJrdHlwZSgpO1xuXG4gIHN3aXRjaCAobWFya3R5cGUpIHtcbiAgICBjYXNlICdiYXInOlxuICAgIGNhc2UgJ3RpY2snOlxuICAgIGNhc2UgJ3RleHQnOlxuICAgICAgc3ltYm9scy5zdHJva2UgPSB7dmFsdWU6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgc3ltYm9scy5zaGFwZSA9IHt2YWx1ZTogJ3NxdWFyZSd9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjaXJjbGUnOlxuICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICBzeW1ib2xzLnNoYXBlID0ge3ZhbHVlOiBtYXJrdHlwZX07XG4gICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICBjYXNlICdwb2ludCc6XG4gICAgICAvLyBmaWxsIG9yIHN0cm9rZVxuICAgICAgaWYgKGUuZW5jRGVmKFNIQVBFKS5maWxsZWQpIHtcbiAgICAgICAgaWYgKGUuaGFzKENPTE9SKSAmJiBuYW1lID09PSBDT0xPUikge1xuICAgICAgICAgIHN5bWJvbHMuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiAnZGF0YSd9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5bWJvbHMuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbHMuc3Ryb2tlID0ge3ZhbHVlOiAndHJhbnNwYXJlbnQnfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlLmhhcyhDT0xPUikgJiYgbmFtZSA9PT0gQ09MT1IpIHtcbiAgICAgICAgICBzeW1ib2xzLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiAnZGF0YSd9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5bWJvbHMuc3Ryb2tlID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gICAgICAgIH1cbiAgICAgICAgc3ltYm9scy5maWxsID0ge3ZhbHVlOiAndHJhbnNwYXJlbnQnfTtcbiAgICAgICAgc3ltYm9scy5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlICdsaW5lJzpcbiAgICBjYXNlICdhcmVhJzpcbiAgICAgIC8vIFRPRE8gdXNlIHNoYXBlIGhlcmUgYWZ0ZXIgaW1wbGVtZW50aW5nICM1MDhcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmVuY0RlZihDT0xPUikub3BhY2l0eSB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkge1xuICAgIHN5bWJvbHMub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG4gIH1cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmxlZ2VuZC50aXRsZSA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nKSB7XG4gIHZhciBsZWcgPSBlbmNvZGluZy5lbmNEZWYobmFtZSkubGVnZW5kO1xuXG4gIGlmIChsZWcudGl0bGUpIHJldHVybiBsZWcudGl0bGU7XG5cbiAgcmV0dXJuIGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBtYXJrcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbm1hcmtzLmRlZiA9IGZ1bmN0aW9uKGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzdGF0cykge1xuXG4gIHZhciBkZWZzID0gW10sXG4gICAgbWFyayA9IG1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLFxuICAgIGZyb20gPSBlbmNvZGluZy5kYXRhVGFibGUoKTtcblxuICAvLyB0byBhZGQgYSBiYWNrZ3JvdW5kIHRvIHRleHQsIHdlIG5lZWQgdG8gYWRkIGl0IGJlZm9yZSB0aGUgdGV4dFxuICBpZiAoZW5jb2RpbmcubWFya3R5cGUoKSA9PT0gVEVYVCAmJiBlbmNvZGluZy5oYXMoQ09MT1IpKSB7XG4gICAgdmFyIGJnID0ge1xuICAgICAgeDoge3ZhbHVlOiAwfSxcbiAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICB4Mjoge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRofSxcbiAgICAgIHkyOiB7dmFsdWU6IGxheW91dC5jZWxsSGVpZ2h0fSxcbiAgICAgIGZpbGw6IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihDT0xPUil9XG4gICAgfTtcbiAgICBkZWZzLnB1c2goe1xuICAgICAgdHlwZTogJ3JlY3QnLFxuICAgICAgZnJvbToge2RhdGE6IGZyb219LFxuICAgICAgcHJvcGVydGllczoge2VudGVyOiBiZywgdXBkYXRlOiBiZ31cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGFkZCB0aGUgbWFyayBkZWYgZm9yIHRoZSBtYWluIHRoaW5nXG4gIHZhciBwID0gbWFyay5wcm9wKGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzdGF0cyk7XG4gIGRlZnMucHVzaCh7XG4gICAgdHlwZTogbWFyay50eXBlLFxuICAgIGZyb206IHtkYXRhOiBmcm9tfSxcbiAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IHAsIHVwZGF0ZTogcH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5tYXJrcy5iYXIgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgcHJvcDogYmFyX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMX1cbn07XG5cbm1hcmtzLmxpbmUgPSB7XG4gIHR5cGU6ICdsaW5lJyxcbiAgbGluZTogdHJ1ZSxcbiAgcHJvcDogbGluZV9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGRldGFpbDoxfVxufTtcblxubWFya3MuYXJlYSA9IHtcbiAgdHlwZTogJ2FyZWEnLFxuICBsaW5lOiB0cnVlLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBwcm9wOiBhcmVhX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMX1cbn07XG5cbm1hcmtzLnRpY2sgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgcHJvcDogdGlja19wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLmNpcmNsZSA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcygnY2lyY2xlJyksXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy5zcXVhcmUgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBmaWxsZWRfcG9pbnRfcHJvcHMoJ3NxdWFyZScpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzogbWFya3MuY2lyY2xlLnN1cHBvcnRlZEVuY29kaW5nXG59O1xuXG5tYXJrcy5wb2ludCA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IHBvaW50X3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgc2hhcGU6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLnRleHQgPSB7XG4gIHR5cGU6ICd0ZXh0JyxcbiAgcHJvcDogdGV4dF9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd0ZXh0J10sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCB0ZXh0OiAxfVxufTtcblxuZnVuY3Rpb24gYmFyX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuXG4gIHZhciBwID0ge307XG5cbiAgLy8geCdzIGFuZCB3aWR0aFxuICBpZiAoZS5pc01lYXN1cmUoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICAgIHAueDIgPSB7dmFsdWU6IDB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5oYXMoWCkpIHsgLy8gaXMgb3JkaW5hbFxuICAgICAgIHAueGMgPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgIHAueCA9IHt2YWx1ZTogMCwgb2Zmc2V0OiBlLmNvbmZpZygnc2luZ2xlQmFyT2Zmc2V0Jyl9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHdpZHRoXG4gIGlmICghcC54Mikge1xuICAgIGlmICghZS5oYXMoWCkgfHwgZS5pc09yZGluYWxTY2FsZShYKSkgeyAvLyBubyBYIG9yIFggaXMgb3JkaW5hbFxuICAgICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICAgIHAud2lkdGggPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAud2lkdGggPSB7XG4gICAgICAgICAgdmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSxcbiAgICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gWCBpcyBRdWFudCBvciBUaW1lIFNjYWxlXG4gICAgICBwLndpZHRoID0ge3ZhbHVlOiAyfTtcbiAgICB9XG4gIH1cblxuICAvLyB5J3MgJiBoZWlnaHRcbiAgaWYgKGUuaXNNZWFzdXJlKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgcC55MiA9IHtmaWVsZDoge2dyb3VwOiAnaGVpZ2h0J319O1xuICB9IGVsc2Uge1xuICAgIGlmIChlLmhhcyhZKSkgeyAvLyBpcyBvcmRpbmFsXG4gICAgICBwLnljID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAueTIgPSB7XG4gICAgICAgIGZpZWxkOiB7Z3JvdXA6ICdoZWlnaHQnfSxcbiAgICAgICAgb2Zmc2V0OiAtZS5jb25maWcoJ3NpbmdsZUJhck9mZnNldCcpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgcC5oZWlnaHQgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5oZWlnaHQgPSB7XG4gICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCksXG4gICAgICAgIG9mZnNldDogLTFcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIG9wYWNpdHlcbiAgdmFyIG9wYWNpdHkgPSBlLmVuY0RlZihDT0xPUikub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBvaW50X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGRSZWYoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gIH1cblxuICAvLyBzaGFwZVxuICBpZiAoZS5oYXMoU0hBUEUpKSB7XG4gICAgcC5zaGFwZSA9IHtzY2FsZTogU0hBUEUsIGZpZWxkOiBlLmZpZWxkUmVmKFNIQVBFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7dmFsdWU6IGUudmFsdWUoU0hBUEUpfTtcbiAgfVxuXG4gIC8vIGZpbGwgb3Igc3Ryb2tlXG4gIGlmIChlLmVuY0RlZihTSEFQRSkuZmlsbGVkKSB7XG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgIH1cbiAgICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZygnc3Ryb2tlV2lkdGgnKX07XG4gIH1cblxuICAvLyBvcGFjaXR5XG4gIHZhciBvcGFjaXR5ID0gZS5lbmNEZWYoQ09MT1IpLm9wYWNpdHkgfHwgc3R5bGUub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGxpbmVfcHJvcHMoZSxsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHtmaWVsZDoge2dyb3VwOiAnaGVpZ2h0J319O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICB2YXIgb3BhY2l0eSA9IGUuZW5jRGVmKENPTE9SKS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZygnc3Ryb2tlV2lkdGgnKX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGFyZWFfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5pc01lYXN1cmUoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC54MiA9IHtzY2FsZTogWCwgdmFsdWU6IDB9O1xuICAgICAgcC5vcmllbnQgPSB7dmFsdWU6ICdob3Jpem9udGFsJ307XG4gICAgfVxuICB9IGVsc2UgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gIH0gZWxzZSB7XG4gICAgcC54ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaXNNZWFzdXJlKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgcC55MiA9IHtzY2FsZTogWSwgdmFsdWU6IDB9O1xuICB9IGVsc2UgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gIH0gZWxzZSB7XG4gICAgcC55ID0ge2ZpZWxkOiB7Z3JvdXA6ICdoZWlnaHQnfX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gZS5lbmNEZWYoQ09MT1IpLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0aWNrX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgICBwLngub2Zmc2V0ID0gLWUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDM7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLnkub2Zmc2V0ID0gLWUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDM7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB3aWR0aFxuICBpZiAoIWUuaGFzKFgpIHx8IGUuaXNEaW1lbnNpb24oWCkpIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAxLjV9O1xuICB9IGVsc2Uge1xuICAgIHAud2lkdGggPSB7dmFsdWU6IDF9O1xuICB9XG5cbiAgLy8gaGVpZ2h0XG4gIGlmICghZS5oYXMoWSkgfHwgZS5pc0RpbWVuc2lvbihZKSkge1xuICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAxLjV9O1xuICB9IGVsc2Uge1xuICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICB2YXIgb3BhY2l0eSA9IGUuZW5jRGVmKENPTE9SKS5vcGFjaXR5ICB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRfcG9pbnRfcHJvcHMoc2hhcGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgLy8geFxuICAgIGlmIChlLmhhcyhYKSkge1xuICAgICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuXG4gICAgLy8geVxuICAgIGlmIChlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuXG4gICAgLy8gc2l6ZVxuICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgcC5zaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gICAgfVxuXG4gICAgLy8gc2hhcGVcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBzaGFwZX07XG5cbiAgICAvLyBmaWxsXG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gZS5lbmNEZWYoQ09MT1IpLm9wYWNpdHkgIHx8IHN0eWxlLm9wYWNpdHk7XG4gICAgaWYob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICAgIHJldHVybiBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0X3Byb3BzKGUsIGxheW91dCwgc3R5bGUsIHN0YXRzKSB7XG4gIHZhciBwID0ge30sXG4gICAgZW5jRGVmID0gZS5lbmNEZWYoVEVYVCk7XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBpZiAoZS5oYXMoVEVYVCkgJiYgZS5pc1R5cGUoVEVYVCwgUSkpIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aC01fTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC54ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuZm9udFNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3ZhbHVlOiBlbmNEZWYuZm9udC5zaXplfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgLy8gY29sb3Igc2hvdWxkIGJlIHNldCB0byBiYWNrZ3JvdW5kXG4gIHAuZmlsbCA9IHt2YWx1ZTogZW5jRGVmLmNvbG9yfTtcblxuICB2YXIgb3BhY2l0eSA9IGUuZW5jRGVmKENPTE9SKS5vcGFjaXR5ICB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIC8vIHRleHRcbiAgaWYgKGUuaGFzKFRFWFQpKSB7XG4gICAgaWYgKGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICB2YXIgZmllbGRTdGF0cyA9IHN0YXRzW2UuZW5jRGVmKFRFWFQpLm5hbWVdLFxuICAgICAgICBudW1iZXJGb3JtYXQgPSBlbmNEZWYuZm9ybWF0IHx8IGUubnVtYmVyRm9ybWF0KGZpZWxkU3RhdHMpO1xuXG4gICAgICBwLnRleHQgPSB7dGVtcGxhdGU6ICd7eycgKyBlLmZpZWxkUmVmKFRFWFQsIHtkYXR1bTogdHJ1ZX0pICsgJyB8IG51bWJlcjpcXCcnICtcbiAgICAgICAgbnVtYmVyRm9ybWF0ICsnXFwnfX0nfTtcbiAgICAgIHAuYWxpZ24gPSB7dmFsdWU6IGVuY0RlZi5hbGlnbn07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAudGV4dCA9IHtmaWVsZDogZS5maWVsZFJlZihURVhUKX07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAudGV4dCA9IHt2YWx1ZTogZW5jRGVmLnBsYWNlaG9sZGVyfTtcbiAgfVxuXG4gIHAuZm9udCA9IHt2YWx1ZTogZW5jRGVmLmZvbnQuZmFtaWx5fTtcbiAgcC5mb250V2VpZ2h0ID0ge3ZhbHVlOiBlbmNEZWYuZm9udC53ZWlnaHR9O1xuICBwLmZvbnRTdHlsZSA9IHt2YWx1ZTogZW5jRGVmLmZvbnQuc3R5bGV9O1xuICBwLmJhc2VsaW5lID0ge3ZhbHVlOiBlbmNEZWYuYmFzZWxpbmV9O1xuXG4gIHJldHVybiBwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgY29sb3JicmV3ZXIgPSByZXF1aXJlKCdjb2xvcmJyZXdlcicpLFxuICBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJ2QzLWNvbG9yJykuaW50ZXJwb2xhdGVIc2wsXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9zY2hlbWEnKTtcblxudmFyIHNjYWxlID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuc2NhbGUubmFtZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICBpZiAocHJvcHNbeF0gJiYgcHJvcHNbeF0uc2NhbGUpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbnNjYWxlLmRlZnMgPSBmdW5jdGlvbihuYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIGZhY2V0KSB7XG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIHZhciBzY2FsZURlZiA9IHt9O1xuXG4gICAgc2NhbGVEZWYubmFtZSA9IG5hbWU7XG4gICAgc2NhbGVEZWYudHlwZSA9IHNjYWxlLnR5cGUobmFtZSwgZW5jb2RpbmcpO1xuICAgIHNjYWxlRGVmLmRvbWFpbiA9IHNjYWxlLmRvbWFpbihlbmNvZGluZywgbmFtZSwgc2NhbGVEZWYudHlwZSwgc3RhdHMsIGZhY2V0KTtcblxuICAgIC8vIGFkZCBgcmV2ZXJzZWAgaWYgYXBwbGljYWJsZVxuICAgIHZhciByZXZlcnNlID0gc2NhbGUucmV2ZXJzZShlbmNvZGluZywgbmFtZSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHNjYWxlRGVmLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIH1cblxuICAgIHNjYWxlRGVmID0gc2NhbGUucmFuZ2Uoc2NhbGVEZWYsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKTtcblxuICAgIHJldHVybiAoYS5wdXNoKHNjYWxlRGVmKSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbnNjYWxlLnR5cGUgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nLnR5cGUobmFtZSkpIHtcbiAgICBjYXNlIE46IC8vZmFsbCB0aHJvdWdoXG4gICAgY2FzZSBPOiByZXR1cm4gJ29yZGluYWwnO1xuICAgIGNhc2UgVDpcbiAgICAgIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmVuY0RlZihuYW1lKS50aW1lVW5pdDtcbiAgICAgIHJldHVybiB0aW1lVW5pdCA/IHRpbWUuc2NhbGUudHlwZSh0aW1lVW5pdCwgbmFtZSkgOiAndGltZSc7XG4gICAgY2FzZSBROlxuICAgICAgaWYgKGVuY29kaW5nLmJpbihuYW1lKSkge1xuICAgICAgICAvLyBUT0RPOiByZXZpc2UgdGhpc1xuICAgICAgICByZXR1cm4gbmFtZSA9PT0gQ09MT1IgPyAnbGluZWFyJyA6ICdvcmRpbmFsJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGluZy5zY2FsZShuYW1lKS50eXBlO1xuICB9XG59O1xuXG5zY2FsZS5kb21haW4gPSBmdW5jdGlvbiAoZW5jb2RpbmcsIG5hbWUsIHR5cGUsIHN0YXRzLCBmYWNldCkge1xuICB2YXIgZW5jRGVmID0gZW5jb2RpbmcuZW5jRGVmKG5hbWUpO1xuXG4gIC8vIHNwZWNpYWwgY2FzZSBmb3IgdGVtcG9yYWwgc2NhbGVcbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSkge1xuICAgIHZhciByYW5nZSA9IHRpbWUuc2NhbGUuZG9tYWluKGVuY0RlZi50aW1lVW5pdCwgbmFtZSk7XG4gICAgaWYgKHJhbmdlKSByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICAvLyBGb3IgYmlubmVkLCBwcm9kdWNlIGZpeGVkIHN0ZXBwZWQgZG9tYWluLlxuICAvLyBUT0RPKCM2MTQpOiB0aGlzIG11c3QgYmUgY2hhbmdlZCBpbiB2ZzJcbiAgaWYgKGVuY0RlZi5iaW4pIHtcblxuICAgIHZhciBmaWVsZFN0YXQgPSBzdGF0c1tlbmNEZWYubmFtZV0sXG4gICAgICBiaW5zID0gdXRpbC5nZXRiaW5zKGZpZWxkU3RhdCwgZW5jRGVmLmJpbi5tYXhiaW5zIHx8IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQpLFxuICAgICAgbnVtYmlucyA9IChiaW5zLnN0b3AgLSBiaW5zLnN0YXJ0KSAvIGJpbnMuc3RlcDtcbiAgICByZXR1cm4gdXRpbC5yYW5nZShudW1iaW5zKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIGJpbnMuc3RhcnQgKyBiaW5zLnN0ZXAgKiBpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRm9yIHN0YWNrLCB1c2UgU1RBQ0tFRCBkYXRhLlxuICB2YXIgc3RhY2sgPSBlbmNvZGluZy5zdGFjaygpO1xuICBpZiAoc3RhY2sgJiYgbmFtZSA9PT0gc3RhY2sudmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogU1RBQ0tFRCxcbiAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihuYW1lLCB7XG4gICAgICAgIC8vIElmIGZhY2V0ZWQsIHNjYWxlIGlzIGRldGVybWluZWQgYnkgdGhlIG1heCBvZiBzdW0gaW4gZWFjaCBmYWNldC5cbiAgICAgICAgcHJlZm46IChmYWNldCA/ICdtYXhfJyA6ICcnKSArICdzdW1fJ1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHVzZVJhd0RvbWFpbiA9IHNjYWxlLl91c2VSYXdEb21haW4oZW5jb2RpbmcsIG5hbWUpO1xuICB2YXIgc29ydCA9IHNjYWxlLnNvcnQoZW5jb2RpbmcsIG5hbWUsIHR5cGUpO1xuXG4gIGlmICh1c2VSYXdEb21haW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogUkFXLFxuICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKG5hbWUsIHtub0FnZ3JlZ2F0ZTp0cnVlfSlcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNvcnQpIHsgLy8gaGF2ZSBzb3J0XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIElmIHNvcnQgYnkgYWdncmVnYXRpb24gb2YgYSBzcGVjaWZpZWQgc29ydCBmaWVsZCwgd2UgbmVlZCB0byB1c2UgUkFXIHRhYmxlLFxuICAgICAgLy8gc28gd2UgY2FuIGFnZ3JlZ2F0ZSB2YWx1ZXMgZm9yIHRoZSBzY2FsZSBpbmRlcGVuZGVudGx5IGZyb20gdGhlIG1haW4gYWdncmVnYXRpb24uXG4gICAgICBkYXRhOiBzb3J0Lm9wID8gUkFXIDogZW5jb2RpbmcuZGF0YVRhYmxlKCksXG4gICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYobmFtZSksXG4gICAgICBzb3J0OiBzb3J0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogZW5jb2RpbmcuZGF0YVRhYmxlKCksXG4gICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYobmFtZSlcbiAgICB9O1xuICB9XG59O1xuXG5zY2FsZS5zb3J0ID0gZnVuY3Rpb24oZW5jb2RpbmcsIG5hbWUsIHR5cGUpIHtcbiAgdmFyIHNvcnQgPSBlbmNvZGluZy5lbmNEZWYobmFtZSkuc29ydDtcbiAgaWYgKHNvcnQgPT09ICdhc2NlbmRpbmcnIHx8IHNvcnQgPT09ICdkZXNjZW5kaW5nJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU29ydGVkIGJhc2VkIG9uIGFuIGFnZ3JlZ2F0ZSBjYWxjdWxhdGlvbiBvdmVyIGEgc3BlY2lmaWVkIHNvcnQgZmllbGQgKG9ubHkgZm9yIG9yZGluYWwgc2NhbGUpXG4gIGlmICh0eXBlID09PSAnb3JkaW5hbCcgJiYgdXRpbC5pc09iamVjdChzb3J0KSkge1xuICAgIHJldHVybiB7XG4gICAgICBvcDogc29ydC5vcCxcbiAgICAgIGZpZWxkOiBzb3J0LmZpZWxkXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuc2NhbGUucmV2ZXJzZSA9IGZ1bmN0aW9uKGVuY29kaW5nLCBuYW1lKSB7XG4gIHZhciBzb3J0ID0gZW5jb2RpbmcuZW5jRGVmKG5hbWUpLnNvcnQ7XG4gIHJldHVybiBzb3J0ICYmIChzb3J0ID09PSAnZGVzY2VuZGluZycgfHwgKHNvcnQub3JkZXIgPT09ICdkZXNjZW5kaW5nJykpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdXNlUmF3RG9tYWluIHNob3VsZCBiZSBhY3RpdmF0ZWQgZm9yIHRoaXMgc2NhbGUuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0b25zIGFwcGxpZXM6XG4gKiAxLiBgdXNlUmF3RG9tYWluYCBpcyBlbmFibGVkIGVpdGhlciB0aHJvdWdoIHNjYWxlIG9yIGNvbmZpZ1xuICogMi4gQWdncmVnYXRpb24gZnVuY3Rpb24gaXMgbm90IGBjb3VudGAgb3IgYHN1bWBcbiAqIDMuIFRoZSBzY2FsZSBpcyBxdWFudGl0YXRpdmUgb3IgdGltZSBzY2FsZS5cbiAqL1xuc2NhbGUuX3VzZVJhd0RvbWFpbiA9IGZ1bmN0aW9uIChlbmNvZGluZywgbmFtZSkge1xuICB2YXIgZW5jRGVmID0gZW5jb2RpbmcuZW5jRGVmKG5hbWUpO1xuXG4gIC8vIHNjYWxlIHZhbHVlXG4gIHZhciBzY2FsZVVzZVJhd0RvbWFpbiA9IGVuY29kaW5nLnNjYWxlKG5hbWUpLnVzZVJhd0RvbWFpbjtcblxuICAvLyBEZXRlcm1pbmUgaWYgdXNlUmF3RG9tYWluIGlzIGVuYWJsZWQuIElmIHNjYWxlIHZhbHVlIGlzIHNwZWNpZmllZCwgdXNlIHNjYWxlIHZhbHVlLlxuICAvLyBPdGhlcndpc2UsIHVzZSBjb25maWcgdmFsdWUuXG4gIHZhciB1c2VSYXdEb21haW5FbmFibGVkID0gc2NhbGVVc2VSYXdEb21haW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICBzY2FsZVVzZVJhd0RvbWFpbiA6IGVuY29kaW5nLmNvbmZpZygndXNlUmF3RG9tYWluJyk7XG5cbiAgdmFyIG5vdENvdW50T3JTdW0gPSAhZW5jRGVmLmFnZ3JlZ2F0ZSB8fFxuICAgIChlbmNEZWYuYWdncmVnYXRlICE9PSdjb3VudCcgJiYgZW5jRGVmLmFnZ3JlZ2F0ZSAhPT0gJ3N1bScpO1xuXG4gIHJldHVybiAgdXNlUmF3RG9tYWluRW5hYmxlZCAmJlxuICAgIG5vdENvdW50T3JTdW0gJiYgKFxuICAgICAgLy8gUSBhbHdheXMgdXNlcyBxdWFudGl0YXRpdmUgc2NhbGUgZXhjZXB0IHdoZW4gaXQncyBiaW5uZWQgYW5kIHRodXMgdXNlcyBvcmRpbmFsIHNjYWxlLlxuICAgICAgKFxuICAgICAgICBlbmNvZGluZy5pc1R5cGUobmFtZSwgUSkgJiZcbiAgICAgICAgIWVuY0RlZi5iaW4gLy8gVE9ETygjNjE0KTogdGhpcyBtdXN0IGJlIGNoYW5nZWQgb25jZSBiaW4gaXMgcmVpbXBsZW1lbnRlZFxuICAgICAgKSB8fFxuICAgICAgLy8gVE9ETzogcmV2aXNlIHRoaXNcbiAgICAgIC8vIFQgdXNlcyBub24tb3JkaW5hbCBzY2FsZSB3aGVuIHRoZXJlJ3Mgbm8gdW5pdCBvciB3aGVuIHRoZSB1bml0IGlzIG5vdCBvcmRpbmFsLlxuICAgICAgKFxuICAgICAgICBlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiZcbiAgICAgICAgKCFlbmNEZWYudGltZVVuaXQgfHwgIXRpbWUuaXNPcmRpbmFsRm4oZW5jRGVmLnRpbWVVbml0KSlcbiAgICAgIClcbiAgICApO1xufTtcblxuXG5zY2FsZS5yYW5nZSA9IGZ1bmN0aW9uIChzY2FsZURlZiwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpIHtcbiAgdmFyIHNwZWMgPSBlbmNvZGluZy5zY2FsZShzY2FsZURlZi5uYW1lKSxcbiAgICBlbmNEZWYgPSBlbmNvZGluZy5lbmNEZWYoc2NhbGVEZWYubmFtZSksXG4gICAgdGltZVVuaXQgPSBlbmNEZWYudGltZVVuaXQ7XG5cbiAgc3dpdGNoIChzY2FsZURlZi5uYW1lKSB7XG4gICAgY2FzZSBYOlxuICAgICAgc2NhbGVEZWYucmFuZ2UgPSBsYXlvdXQuY2VsbFdpZHRoID8gWzAsIGxheW91dC5jZWxsV2lkdGhdIDogJ3dpZHRoJztcbiAgICAgIGlmIChzY2FsZURlZi50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgc2NhbGVEZWYuYmFuZFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbmNvZGluZy5pc1R5cGUoc2NhbGVEZWYubmFtZSxUKSAmJiB0aW1lVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgc2NhbGVEZWYuemVybyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlRGVmLnplcm8gPSBzcGVjLnplcm8gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzcGVjLnplcm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNjYWxlRGVmLnJvdW5kID0gdHJ1ZTtcbiAgICAgIGlmIChzY2FsZURlZi50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgc2NhbGVEZWYubmljZSA9IHRpbWVVbml0IHx8IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTmljZScpO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzY2FsZURlZi5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzY2FsZURlZi50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgc2NhbGVEZWYucmFuZ2UgPSBsYXlvdXQuY2VsbEhlaWdodCA/XG4gICAgICAgICAgKGVuY0RlZi5iaW4gPyBbbGF5b3V0LmNlbGxIZWlnaHQsIDBdIDogWzAsIGxheW91dC5jZWxsSGVpZ2h0XSkgOlxuICAgICAgICAgICdoZWlnaHQnO1xuICAgICAgICBzY2FsZURlZi5iYW5kV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVEZWYucmFuZ2UgPSBsYXlvdXQuY2VsbEhlaWdodCA/IFtsYXlvdXQuY2VsbEhlaWdodCwgMF0gOiAnaGVpZ2h0JztcbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzY2FsZURlZi5uYW1lLFQpICYmIHRpbWVVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgICBzY2FsZURlZi56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGVEZWYuemVybyA9IHNwZWMuemVybyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNwZWMuemVybztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzY2FsZURlZi5yb3VuZCA9IHRydWU7XG5cbiAgICAgIGlmIChzY2FsZURlZi50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgc2NhbGVEZWYubmljZSA9IHRpbWVVbml0IHx8IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTmljZScpO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzY2FsZURlZi5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUk9XOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgc2NhbGVEZWYuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxIZWlnaHQ7XG4gICAgICBzY2FsZURlZi5yb3VuZCA9IHRydWU7XG4gICAgICBzY2FsZURlZi5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ09MOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgc2NhbGVEZWYuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxXaWR0aDtcbiAgICAgIHNjYWxlRGVmLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHNjYWxlRGVmLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVpFOlxuICAgICAgaWYgKGVuY29kaW5nLmlzKCdiYXInKSkge1xuICAgICAgICAvLyBGSVhNRSB0aGlzIGlzIGRlZmluaXRlbHkgaW5jb3JyZWN0XG4gICAgICAgIC8vIGJ1dCBsZXQncyBmaXggaXQgbGF0ZXIgc2luY2UgYmFyIHNpemUgaXMgYSBiYWQgZW5jb2RpbmcgYW55d2F5XG4gICAgICAgIHNjYWxlRGVmLnJhbmdlID0gWzMsIE1hdGgubWF4KGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSldO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZy5pcyhURVhUKSkge1xuICAgICAgICBzY2FsZURlZi5yYW5nZSA9IFs4LCA0MF07XG4gICAgICB9IGVsc2UgeyAvL3BvaW50XG4gICAgICAgIHZhciBiYW5kU2l6ZSA9IE1hdGgubWluKGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSkgLSAxO1xuICAgICAgICBzY2FsZURlZi5yYW5nZSA9IFsxMCwgMC44ICogYmFuZFNpemUqYmFuZFNpemVdO1xuICAgICAgfVxuICAgICAgc2NhbGVEZWYucm91bmQgPSB0cnVlO1xuICAgICAgc2NhbGVEZWYuemVybyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSEFQRTpcbiAgICAgIHNjYWxlRGVmLnJhbmdlID0gJ3NoYXBlcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTE9SOlxuICAgICAgc2NhbGVEZWYucmFuZ2UgPSBzY2FsZS5jb2xvcihzY2FsZURlZiwgZW5jb2RpbmcsIHN0YXRzKTtcbiAgICAgIGlmIChzY2FsZURlZi50eXBlICE9PSAnb3JkaW5hbCcpIHNjYWxlRGVmLnplcm8gPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgbmFtZTogJysgc2NhbGVEZWYubmFtZSk7XG4gIH1cblxuICAvLyBGSVhNRShrYW5pdHcpOiBKdWwgMjksIDIwMTUgLSBjb25zb2xpZGF0ZSB0aGlzIHdpdGggYWJvdmVcbiAgc3dpdGNoIChzY2FsZURlZi5uYW1lKSB7XG4gICAgY2FzZSBST1c6XG4gICAgY2FzZSBDT0w6XG4gICAgICBzY2FsZURlZi5wYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKCdjZWxsUGFkZGluZycpO1xuICAgICAgc2NhbGVEZWYub3V0ZXJQYWRkaW5nID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWDpcbiAgICBjYXNlIFk6XG4gICAgICBpZiAoc2NhbGVEZWYudHlwZSA9PT0gJ29yZGluYWwnKSB7IC8vJiYgIXMuYmFuZFdpZHRoXG4gICAgICAgIHNjYWxlRGVmLnBvaW50cyA9IHRydWU7XG4gICAgICAgIHNjYWxlRGVmLnBhZGRpbmcgPSBlbmNvZGluZy5lbmNEZWYoc2NhbGVEZWYubmFtZSkuYmFuZC5wYWRkaW5nO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHNjYWxlRGVmO1xufTtcblxuc2NhbGUuY29sb3IgPSBmdW5jdGlvbihzLCBlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGNvbG9yU2NhbGUgPSBlbmNvZGluZy5zY2FsZShDT0xPUiksXG4gICAgcmFuZ2UgPSBjb2xvclNjYWxlLnJhbmdlLFxuICAgIGNhcmRpbmFsaXR5ID0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MT1IsIHN0YXRzKSxcbiAgICB0eXBlID0gZW5jb2RpbmcudHlwZShDT0xPUik7XG5cbiAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgb3JkaW5hbFBhbGV0dGUgPSBjb2xvclNjYWxlLm9yZGluYWxQYWxldHRlLFxuICAgICAgcXVhbnRpdGF0aXZlUmFuZ2UgPSBjb2xvclNjYWxlLnF1YW50aXRhdGl2ZVJhbmdlO1xuXG4gICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gTikge1xuICAgICAgICAvLyB1c2UgY2F0ZWdvcmljYWwgY29sb3Igc2NhbGVcbiAgICAgICAgaWYgKGNhcmRpbmFsaXR5IDw9IDEwKSB7XG4gICAgICAgICAgcmFuZ2UgPSBjb2xvclNjYWxlLmMxMHBhbGV0dGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UgPSBjb2xvclNjYWxlLmMyMHBhbGV0dGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlLmNvbG9yLnBhbGV0dGUocmFuZ2UsIGNhcmRpbmFsaXR5LCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcmRpbmFsUGFsZXR0ZSkge1xuICAgICAgICAgIHJldHVybiBzY2FsZS5jb2xvci5wYWxldHRlKG9yZGluYWxQYWxldHRlLCBjYXJkaW5hbGl0eSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlLmNvbG9yLmludGVycG9sYXRlKHF1YW50aXRhdGl2ZVJhbmdlWzBdLCBxdWFudGl0YXRpdmVSYW5nZVsxXSwgY2FyZGluYWxpdHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vdGltZSBvciBxdWFudGl0YXRpdmVcbiAgICAgIHJldHVybiBbcXVhbnRpdGF0aXZlUmFuZ2VbMF0sIHF1YW50aXRhdGl2ZVJhbmdlWzFdXTtcbiAgICB9XG4gIH1cbn07XG5cbnNjYWxlLmNvbG9yLnBhbGV0dGUgPSBmdW5jdGlvbihyYW5nZSwgY2FyZGluYWxpdHksIHR5cGUpIHtcbiAgLy8gRklYTUUoa2FuaXR3KTogSnVsIDI5LCAyMDE1IC0gY2hlY2sgcmFuZ2UgaXMgc3RyaW5nXG4gIHN3aXRjaCAocmFuZ2UpIHtcbiAgICBjYXNlICdjYXRlZ29yeTEwayc6XG4gICAgICAvLyB0YWJsZWF1J3MgY2F0ZWdvcnkgMTAsIG9yZGVyZWQgYnkgcGVyY2VwdHVhbCBrZXJuZWwgc3R1ZHkgcmVzdWx0c1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3V3ZGF0YS9wZXJjZXB0dWFsLWtlcm5lbHNcbiAgICAgIHJldHVybiBbJyMyY2EwMmMnLCAnI2UzNzdjMicsICcjN2Y3ZjdmJywgJyMxN2JlY2YnLCAnIzhjNTY0YicsICcjZDYyNzI4JywgJyNiY2JkMjInLCAnIzk0NjdiZCcsICcjZmY3ZjBlJywgJyMxZjc3YjQnXTtcblxuICAgIC8vIGQzL3RhYmxlYXUgY2F0ZWdvcnkxMC8yMC8yMGIvMjBjXG4gICAgY2FzZSAnY2F0ZWdvcnkxMCc6XG4gICAgICByZXR1cm4gWycjMWY3N2I0JywgJyNmZjdmMGUnLCAnIzJjYTAyYycsICcjZDYyNzI4JywgJyM5NDY3YmQnLCAnIzhjNTY0YicsICcjZTM3N2MyJywgJyM3ZjdmN2YnLCAnI2JjYmQyMicsICcjMTdiZWNmJ107XG5cbiAgICBjYXNlICdjYXRlZ29yeTIwJzpcbiAgICAgIHJldHVybiBbJyMxZjc3YjQnLCAnI2FlYzdlOCcsICcjZmY3ZjBlJywgJyNmZmJiNzgnLCAnIzJjYTAyYycsICcjOThkZjhhJywgJyNkNjI3MjgnLCAnI2ZmOTg5NicsICcjOTQ2N2JkJywgJyNjNWIwZDUnLCAnIzhjNTY0YicsICcjYzQ5Yzk0JywgJyNlMzc3YzInLCAnI2Y3YjZkMicsICcjN2Y3ZjdmJywgJyNjN2M3YzcnLCAnI2JjYmQyMicsICcjZGJkYjhkJywgJyMxN2JlY2YnLCAnIzllZGFlNSddO1xuXG4gICAgY2FzZSAnY2F0ZWdvcnkyMGInOlxuICAgICAgcmV0dXJuIFsnIzM5M2I3OScsICcjNTI1NGEzJywgJyM2YjZlY2YnLCAnIzljOWVkZScsICcjNjM3OTM5JywgJyM4Y2EyNTInLCAnI2I1Y2Y2YicsICcjY2VkYjljJywgJyM4YzZkMzEnLCAnI2JkOWUzOScsICcjZTdiYTUyJywgJyNlN2NiOTQnLCAnIzg0M2MzOScsICcjYWQ0OTRhJywgJyNkNjYxNmInLCAnI2U3OTY5YycsICcjN2I0MTczJywgJyNhNTUxOTQnLCAnI2NlNmRiZCcsICcjZGU5ZWQ2J107XG5cbiAgICBjYXNlICdjYXRlZ29yeTIwYyc6XG4gICAgICByZXR1cm4gWycjMzE4MmJkJywgJyM2YmFlZDYnLCAnIzllY2FlMScsICcjYzZkYmVmJywgJyNlNjU1MGQnLCAnI2ZkOGQzYycsICcjZmRhZTZiJywgJyNmZGQwYTInLCAnIzMxYTM1NCcsICcjNzRjNDc2JywgJyNhMWQ5OWInLCAnI2M3ZTljMCcsICcjNzU2YmIxJywgJyM5ZTlhYzgnLCAnI2JjYmRkYycsICcjZGFkYWViJywgJyM2MzYzNjMnLCAnIzk2OTY5NicsICcjYmRiZGJkJywgJyNkOWQ5ZDknXTtcbiAgfVxuXG4gIC8vIFRPRE8gYWRkIG91ciBvd24gc2V0IG9mIGN1c3RvbSBvcmRpbmFsIGNvbG9yIHBhbGV0dGVcblxuICBpZiAocmFuZ2UgaW4gY29sb3JicmV3ZXIpIHtcbiAgICB2YXIgcGFsZXR0ZSA9IGNvbG9yYnJld2VyW3JhbmdlXTtcblxuICAgIC8vIGlmIGNhcmRpbmFsaXR5IHByZS1kZWZpbmVkLCB1c2UgaXQuXG4gICAgaWYgKGNhcmRpbmFsaXR5IGluIHBhbGV0dGUpIHJldHVybiBwYWxldHRlW2NhcmRpbmFsaXR5XTtcblxuICAgIC8vIGlmIG5vdCwgdXNlIHRoZSBoaWdoZXN0IGNhcmRpbmFsaXR5IG9uZSBmb3Igbm9taW5hbFxuICAgIGlmICh0eXBlID09PSBOKSB7XG4gICAgICByZXR1cm4gcGFsZXR0ZVtNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLmtleXMocGFsZXR0ZSkpXTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIGludGVycG9sYXRlXG4gICAgdmFyIHBzID0gY2FyZGluYWxpdHkgPCAzID8gMyA6IE1hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwua2V5cyhwYWxldHRlKSksXG4gICAgICBmcm9tID0gMCAsIHRvID0gcHMgLSAxO1xuICAgIC8vIEZJWE1FIGFkZCBjb25maWcgZm9yIGZyb20gLyB0b1xuXG4gICAgcmV0dXJuIHNjYWxlLmNvbG9yLmludGVycG9sYXRlKHBhbGV0dGVbcHNdW2Zyb21dLCBwYWxldHRlW3BzXVt0b10sIGNhcmRpbmFsaXR5KTtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn07XG5cbnNjYWxlLmNvbG9yLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNhcmRpbmFsaXR5KSB7XG5cbiAgdmFyIGludGVycG9sYXRvciA9IGludGVycG9sYXRlKHN0YXJ0LCBlbmQpO1xuICByZXR1cm4gdXRpbC5yYW5nZShjYXJkaW5hbGl0eSkubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGludGVycG9sYXRvcihpKjEuMC8oY2FyZGluYWxpdHktMSkpOyB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja2luZztcblxuZnVuY3Rpb24gc3RhY2tpbmcoZW5jb2RpbmcsIG1kZWYsIHN0YWNrKSB7XG4gIHZhciBncm91cGJ5ID0gc3RhY2suZ3JvdXBieTtcbiAgdmFyIGZpZWxkID0gc3RhY2sudmFsdWU7XG5cbiAgdmFyIHZhbE5hbWUgPSBlbmNvZGluZy5maWVsZFJlZihmaWVsZCk7XG4gIHZhciBzdGFydEZpZWxkID0gdmFsTmFtZSArICdfc3RhcnQnO1xuICB2YXIgZW5kRmllbGQgPSB2YWxOYW1lICsgJ19lbmQnO1xuXG4gIC8vIGFkZCBzdGFjayB0cmFuc2Zvcm0gdG8gbWFya1xuICB2YXIgdHJhbnNmb3JtID0ge1xuICAgIHR5cGU6ICdzdGFjaycsXG4gICAgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkUmVmKGdyb3VwYnkpXSxcbiAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYoZmllbGQpLFxuICAgIHNvcnRieTogWyhzdGFjay5wcm9wZXJ0aWVzLnJldmVyc2UgPyAnLScgOiAnJykgKyBlbmNvZGluZy5maWVsZFJlZihzdGFjay5zdGFjayldLFxuICAgIG91dHB1dDoge3N0YXJ0OiBzdGFydEZpZWxkLCBlbmQ6IGVuZEZpZWxkfVxuICB9O1xuXG4gIGlmIChzdGFjay5wcm9wZXJ0aWVzLm9mZnNldCkge1xuICAgIHRyYW5zZm9ybS5vZmZzZXQgPSBzdGFjay5wcm9wZXJ0aWVzLm9mZnNldDtcbiAgfVxuXG4gIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbdHJhbnNmb3JtXTtcblxuICAvLyBUT0RPKCMyNzYpOiBUaGlzIGlzIHN1cGVyIGhhY2staXNoIC0tIGNvbnNvbGlkYXRlIGludG8gbW9kdWxhciBtYXJrIHByb3BlcnRpZXM/XG4gIG1kZWYucHJvcGVydGllcy51cGRhdGVbZmllbGRdID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW2ZpZWxkXSA9IHtcbiAgICBzY2FsZTogZmllbGQsXG4gICAgZmllbGQ6IHN0YXJ0RmllbGRcbiAgfTtcbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVtmaWVsZCArICcyJ10gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbZmllbGQgKyAnMiddID0ge1xuICAgIHNjYWxlOiBmaWVsZCxcbiAgICBmaWVsZDogZW5kRmllbGRcbiAgfTtcblxuICByZXR1cm4gZmllbGQ7IC8vcmV0dXJuIHN0YWNrIGVuY29kaW5nXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHZsRW5jRGVmID0gcmVxdWlyZSgnLi4vZW5jZGVmJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHJldHVybiB7XG4gICAgb3BhY2l0eTogZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLCBzdGF0cyksXG4gIH07XG59O1xuXG5mdW5jdGlvbiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2Rpbmcsc3RhdHMpIHtcbiAgaWYgKCFzdGF0cykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIG51bVBvaW50cyA9IDA7XG5cbiAgaWYgKGVuY29kaW5nLmlzQWdncmVnYXRlKCkpIHsgLy8gYWdncmVnYXRlIHBsb3RcbiAgICBudW1Qb2ludHMgPSAxO1xuXG4gICAgLy8gIGdldCBudW1iZXIgb2YgcG9pbnRzIGluIGVhY2ggXCJjZWxsXCJcbiAgICAvLyAgYnkgY2FsY3VsYXRpbmcgcHJvZHVjdCBvZiBjYXJkaW5hbGl0eVxuICAgIC8vICBmb3IgZWFjaCBub24gZmFjZXRpbmcgYW5kIG5vbi1vcmRpbmFsIFggLyBZIGZpZWxkc1xuICAgIC8vICBub3RlIHRoYXQgb3JkaW5hbCB4LHkgYXJlIG5vdCBpbmNsdWRlIHNpbmNlIHdlIGNhblxuICAgIC8vICBjb25zaWRlciB0aGF0IG9yZGluYWwgeCBhcmUgc3ViZGl2aWRpbmcgdGhlIGNlbGwgaW50byBzdWJjZWxscyBhbnl3YXlcbiAgICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGVuY0RlZiwgZW5jVHlwZSkge1xuXG4gICAgICBpZiAoZW5jVHlwZSAhPT0gUk9XICYmIGVuY1R5cGUgIT09IENPTCAmJlxuICAgICAgICAgICEoKGVuY1R5cGUgPT09IFggfHwgZW5jVHlwZSA9PT0gWSkgJiZcbiAgICAgICAgICB2bEVuY0RlZi5pc09yZGluYWxTY2FsZShlbmNEZWYpKVxuICAgICAgICApIHtcbiAgICAgICAgbnVtUG9pbnRzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KGVuY1R5cGUsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9IGVsc2UgeyAvLyByYXcgcGxvdFxuXG4gICAgLy8gVE9ETzogZXJyb3IgaGFuZGxpbmdcbiAgICBpZiAoIXN0YXRzWycqJ10pXG4gICAgICByZXR1cm4gMTtcblxuICAgIG51bVBvaW50cyA9IHN0YXRzWycqJ10ubWF4OyAgLy8gY291bnRcblxuICAgIC8vIHNtYWxsIG11bHRpcGxlcyBkaXZpZGUgbnVtYmVyIG9mIHBvaW50c1xuICAgIHZhciBudW1NdWx0aXBsZXMgPSAxO1xuICAgIGlmIChlbmNvZGluZy5oYXMoUk9XKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KFJPVywgc3RhdHMpO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcuaGFzKENPTCkpIHtcbiAgICAgIG51bU11bHRpcGxlcyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB9XG4gICAgbnVtUG9pbnRzIC89IG51bU11bHRpcGxlcztcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gMDtcbiAgaWYgKG51bVBvaW50cyA8PSAyNSkge1xuICAgIG9wYWNpdHkgPSAxO1xuICB9IGVsc2UgaWYgKG51bVBvaW50cyA8IDIwMCkge1xuICAgIG9wYWNpdHkgPSAwLjg7XG4gIH0gZWxzZSBpZiAobnVtUG9pbnRzIDwgMTAwMCB8fCBlbmNvZGluZy5pcygndGljaycpKSB7XG4gICAgb3BhY2l0eSA9IDAuNztcbiAgfSBlbHNlIHtcbiAgICBvcGFjaXR5ID0gMC4zO1xuICB9XG5cbiAgcmV0dXJuIG9wYWNpdHk7XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YmZhY2V0aW5nO1xuXG5mdW5jdGlvbiBzdWJmYWNldGluZyhncm91cCwgbWRlZiwgZGV0YWlscywgZW5jb2RpbmcpIHtcbiAgdmFyIG0gPSBncm91cC5tYXJrcztcbiAgdmFyIGcgPSB7XG4gICAgbmFtZTogJ3N1YmZhY2V0JyxcbiAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIGZyb206IG1kZWYuZnJvbSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB3aWR0aDoge2ZpZWxkOiB7Z3JvdXA6ICd3aWR0aCd9fSxcbiAgICAgICAgaGVpZ2h0OiB7ZmllbGQ6IHtncm91cDogJ2hlaWdodCd9fVxuICAgICAgfVxuICAgIH0sXG4gICAgbWFya3M6IG1cbiAgfTtcblxuICBncm91cC5tYXJrcyA9IFtnXTtcbiAgZGVsZXRlIG1kZWYuZnJvbTsgLy8gKG1vdmUgdG8gdGhlIG5ldyBnKVxuXG4gIC8vVE9ETyB0ZXN0IExPRCAtLSB3ZSBzaG91bGQgc3VwcG9ydCBzdGFjayAvIGxpbmUgd2l0aG91dCBjb2xvciAoTE9EKSBmaWVsZFxuICB2YXIgdHJhbnMgPSAoZy5mcm9tLnRyYW5zZm9ybSB8fCAoZy5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnB1c2goe3R5cGU6ICdmYWNldCcsIGdyb3VwYnk6IGRldGFpbHN9KTtcblxuICAvLyBUT0RPOiB1bmRlcnN0YW5kIHdoeSB3ZSBuZWVkIHRoaXMgc29ydCB0cmFuc2Zvcm0gYW5kIHdyaXRlIGNvbW1lbnRcbiAgdmFyIHN0YWNrID0gZW5jb2Rpbmcuc3RhY2soKTtcbiAgaWYgKHN0YWNrICYmIGVuY29kaW5nLmhhcyhDT0xPUikpIHtcbiAgICB0cmFucy51bnNoaWZ0KHt0eXBlOiAnc29ydCcsIGJ5OiBlbmNvZGluZy5maWVsZFJlZihDT0xPUil9KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgZDNfdGltZV9mb3JtYXQgPSByZXF1aXJlKCdkMy10aW1lLWZvcm1hdCcpO1xuXG52YXIgdGltZSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vICdXZWRuZXNkYXkgU2VwdGVtYmVyIDE3IDA0OjAwOjAwIDIwMTQnXG4vLyBXZWRuZXNkYXkgaXMgdGhlIGxvbmdlc3QgZGF0ZVxuLy8gU2VwdGVtYmVyIGlzIHRoZSBsb25nZXN0IG1vbnRoICg4IGluIGphdmFzY3JpcHQgYXMgaXQgaXMgemVyby1pbmRleGVkKS5cbnZhciBMT05HX0RBVEUgPSBuZXcgRGF0ZShEYXRlLlVUQygyMDE0LCA4LCAxNykpO1xuXG50aW1lLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZW5jRGVmLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSkge1xuICB2YXIgdGltZVVuaXQgPSBlbmNEZWYudGltZVVuaXQ7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJ21pbnV0ZXMnOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnaG91cnMnOiByZXR1cm4gMjQ7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIDc7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiAzMTtcbiAgICBjYXNlICdtb250aCc6IHJldHVybiAxMjtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHZhciBzdGF0ID0gc3RhdHNbZW5jRGVmLm5hbWVdLFxuICAgICAgICB5ZWFyc3RhdCA9IHN0YXRzWyd5ZWFyXycgKyBlbmNEZWYubmFtZV07XG5cbiAgICAgIGlmICgheWVhcnN0YXQpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgcmV0dXJuIHllYXJzdGF0LmRpc3RpbmN0IC1cbiAgICAgICAgKHN0YXQubWlzc2luZyA+IDAgJiYgZmlsdGVyTnVsbFt0eXBlXSA/IDEgOiAwKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudGltZS5mb3JtdWxhID0gZnVuY3Rpb24odGltZVVuaXQsIGZpZWxkUmVmKSB7XG4gIC8vIFRPRE8oa2FuaXR3KTogYWRkIGZvcm11bGEgdG8gb3RoZXIgdGltZSBmb3JtYXRcbiAgdmFyIGZuID0gJ3V0YycgKyB0aW1lVW5pdDtcbiAgcmV0dXJuIGZuICsgJygnICsgZmllbGRSZWYgKyAnKSc7XG59O1xuXG50aW1lLm1heExlbmd0aCA9IGZ1bmN0aW9uKHRpbWVVbml0LCBlbmNvZGluZykge1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgICB2YXIgcmFuZ2UgPSB0aW1lLnJhbmdlKHRpbWVVbml0LCBlbmNvZGluZyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBsb25nZXN0IG5hbWUgaW4gdGhlIHJhbmdlXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCByYW5nZS5tYXAoZnVuY3Rpb24ocikge3JldHVybiByLmxlbmd0aDt9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHJldHVybiA0OyAvLycxOTk4J1xuICB9XG4gIC8vIFRPRE8oIzYwMCkgcmV2aXNlIHRoaXNcbiAgLy8gbm8gdGltZSB1bml0XG4gIHZhciB0aW1lRm9ybWF0ID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lRm9ybWF0Jyk7XG4gIHJldHVybiBkM190aW1lX2Zvcm1hdC51dGNGb3JtYXQodGltZUZvcm1hdCkoTE9OR19EQVRFKS5sZW5ndGg7XG59O1xuXG50aW1lLnJhbmdlID0gZnVuY3Rpb24odGltZVVuaXQsIGVuY29kaW5nKSB7XG4gIHZhciBsYWJlbExlbmd0aCA9IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTGFiZWxMZW5ndGgnKSxcbiAgICBzY2FsZUxhYmVsO1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHNjYWxlTGFiZWwgPSBlbmNvZGluZy5jb25maWcoJ2RheVNjYWxlTGFiZWwnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHNjYWxlTGFiZWwgPSBlbmNvZGluZy5jb25maWcoJ21vbnRoU2NhbGVMYWJlbCcpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKHNjYWxlTGFiZWwpIHtcbiAgICByZXR1cm4gbGFiZWxMZW5ndGggPyBzY2FsZUxhYmVsLm1hcChcbiAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5zdWJzdHIoMCwgbGFiZWxMZW5ndGgpO31cbiAgICAgICkgOiBzY2FsZUxhYmVsO1xuICB9XG4gIHJldHVybjtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVuY29kaW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gIHNjYWxlcyBmb3IgdGltZSB1bml0IG5hbWVzXG4gKi9cbnRpbWUuc2NhbGVzID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIHNjYWxlcyA9IGVuY29kaW5nLnJlZHVjZShmdW5jdGlvbihzY2FsZXMsIGVuY0RlZikge1xuICAgIHZhciB0aW1lVW5pdCA9IGVuY0RlZi50aW1lVW5pdDtcbiAgICBpZiAoZW5jRGVmLnR5cGUgPT09IFQgJiYgdGltZVVuaXQgJiYgIXNjYWxlc1t0aW1lVW5pdF0pIHtcbiAgICAgIHZhciBzY2FsZSA9IHRpbWUuc2NhbGUuZGVmKGVuY0RlZi50aW1lVW5pdCwgZW5jb2RpbmcpO1xuICAgICAgaWYgKHNjYWxlKSBzY2FsZXNbdGltZVVuaXRdID0gc2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZXM7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gdXRpbC52YWxzKHNjYWxlcyk7XG59O1xuXG5cbnRpbWUuc2NhbGUgPSB7fTtcblxuLyoqIGFwcGVuZCBjdXN0b20gdGltZSBzY2FsZXMgZm9yIGF4aXMgbGFiZWwgKi9cbnRpbWUuc2NhbGUuZGVmID0gZnVuY3Rpb24odGltZVVuaXQsIGVuY29kaW5nKSB7XG4gIHZhciByYW5nZSA9IHRpbWUucmFuZ2UodGltZVVuaXQsIGVuY29kaW5nKTtcblxuICBpZiAocmFuZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ3RpbWUtJyt0aW1lVW5pdCxcbiAgICAgIHR5cGU6ICdvcmRpbmFsJyxcbiAgICAgIGRvbWFpbjogdGltZS5zY2FsZS5kb21haW4odGltZVVuaXQpLFxuICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnRpbWUuaXNPcmRpbmFsRm4gPSBmdW5jdGlvbih0aW1lVW5pdCkge1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudGltZS5zY2FsZS50eXBlID0gZnVuY3Rpb24odGltZVVuaXQsIG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09IENPTE9SKSB7XG4gICAgcmV0dXJuICdsaW5lYXInOyAvLyB0aW1lIGhhcyBvcmRlciwgc28gdXNlIGludGVycG9sYXRlZCBvcmRpbmFsIGNvbG9yIHNjYWxlLlxuICB9XG5cbiAgcmV0dXJuIHRpbWUuaXNPcmRpbmFsRm4odGltZVVuaXQpIHx8IG5hbWUgPT09IENPTCB8fCBuYW1lID09PSBST1cgPyAnb3JkaW5hbCcgOiAnbGluZWFyJztcbn07XG5cbnRpbWUuc2NhbGUuZG9tYWluID0gZnVuY3Rpb24odGltZVVuaXQsIG5hbWUpIHtcbiAgdmFyIGlzQ29sb3IgPSBuYW1lID09PSBDT0xPUjtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOiByZXR1cm4gaXNDb2xvciA/IFswLDU5XSA6IHV0aWwucmFuZ2UoMCwgNjApO1xuICAgIGNhc2UgJ2hvdXJzJzogcmV0dXJuIGlzQ29sb3IgPyBbMCwyM10gOiB1dGlsLnJhbmdlKDAsIDI0KTtcbiAgICBjYXNlICdkYXknOiByZXR1cm4gaXNDb2xvciA/IFswLDZdIDogdXRpbC5yYW5nZSgwLCA3KTtcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIGlzQ29sb3IgPyBbMSwzMV0gOiB1dGlsLnJhbmdlKDEsIDMyKTtcbiAgICBjYXNlICdtb250aCc6IHJldHVybiBpc0NvbG9yID8gWzAsMTFdIDogdXRpbC5yYW5nZSgwLCAxMik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKiogd2hldGhlciBhIHBhcnRpY3VsYXIgdGltZSBmdW5jdGlvbiBoYXMgY3VzdG9tIHNjYWxlIGZvciBsYWJlbHMgaW1wbGVtZW50ZWQgaW4gdGltZS5zY2FsZSAqL1xudGltZS5oYXNTY2FsZSA9IGZ1bmN0aW9uKHRpbWVVbml0KSB7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuY29uc3RzLmVuY29kaW5nVHlwZXMgPSBbWCwgWSwgUk9XLCBDT0wsIFNJWkUsIFNIQVBFLCBDT0xPUiwgVEVYVCwgREVUQUlMXTtcblxuY29uc3RzLnNob3J0aGFuZCA9IHtcbiAgZGVsaW06ICAnfCcsXG4gIGFzc2lnbjogJz0nLFxuICB0eXBlOiAgICcsJyxcbiAgZnVuYzogICAnXydcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgc3RhdHMgPSByZXF1aXJlKCdkYXRhbGliL3NyYy9zdGF0cycpO1xuXG52YXIgdmxkYXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqIE1hcHBpbmcgZnJvbSBkYXRhbGliJ3MgaW5mZXJyZWQgdHlwZSB0byBWZWdhLWxpdGUncyB0eXBlICovXG52bGRhdGEudHlwZXMgPSB7XG4gICdib29sZWFuJzogTixcbiAgJ251bWJlcic6IFEsXG4gICdpbnRlZ2VyJzogUSxcbiAgJ2RhdGUnOiBULFxuICAnc3RyaW5nJzogTlxufTtcblxudmxkYXRhLnN0YXRzID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgc3VtbWFyeSA9IHN0YXRzLnN1bW1hcnkoZGF0YSk7XG5cbiAgcmV0dXJuIHN1bW1hcnkucmVkdWNlKGZ1bmN0aW9uKHMsIHByb2ZpbGUpIHtcbiAgICBzW3Byb2ZpbGUuZmllbGRdID0gcHJvZmlsZTtcbiAgICByZXR1cm4gcztcbiAgfSwge1xuICAgICcqJzoge1xuICAgICAgbWF4OiBkYXRhLmxlbmd0aCxcbiAgICAgIG1pbjogMFxuICAgIH1cbiAgfSk7XG59OyIsIi8vIHV0aWxpdHkgZm9yIGVuY1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgdmxFbmNEZWYgPSByZXF1aXJlKCcuL2VuY2RlZicpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpLFxuICBlbmNUeXBlcyA9IHNjaGVtYS5lbmNUeXBlcztcblxudmFyIHZsZW5jID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmxlbmMuY291bnRSZXRpbmFsID0gZnVuY3Rpb24oZW5jKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmIChlbmMuY29sb3IpIGNvdW50Kys7XG4gIGlmIChlbmMuc2l6ZSkgY291bnQrKztcbiAgaWYgKGVuYy5zaGFwZSkgY291bnQrKztcbiAgcmV0dXJuIGNvdW50O1xufTtcblxudmxlbmMuaGFzID0gZnVuY3Rpb24oZW5jLCBlbmNUeXBlKSB7XG4gIHZhciBmaWVsZERlZiA9IGVuYyAmJiBlbmNbZW5jVHlwZV07XG4gIHJldHVybiBmaWVsZERlZiAmJiBmaWVsZERlZi5uYW1lO1xufTtcblxudmxlbmMuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihlbmMpIHtcbiAgZm9yICh2YXIgayBpbiBlbmMpIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykgJiYgZW5jW2tdLmFnZ3JlZ2F0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZsZW5jLmZvckVhY2ggPSBmdW5jdGlvbihlbmMsIGYpIHtcbiAgdmFyIGkgPSAwO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIGYoZW5jW2tdLCBrLCBpKyspO1xuICAgIH1cbiAgfSk7XG59O1xuXG52bGVuYy5tYXAgPSBmdW5jdGlvbihlbmMsIGYpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIGFyci5wdXNoKGYoZW5jW2tdLCBrLCBlbmMpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyO1xufTtcblxudmxlbmMucmVkdWNlID0gZnVuY3Rpb24oZW5jLCBmLCBpbml0KSB7XG4gIHZhciByID0gaW5pdDtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICByID0gZihyLCBlbmNba10sIGssICBlbmMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByO1xufTtcblxuLypcbiAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gKi9cbnZsZW5jLmZpZWxkcyA9IGZ1bmN0aW9uKGVuYykge1xuICByZXR1cm4gdmxlbmMucmVkdWNlKGVuYywgZnVuY3Rpb24gKG0sIGZpZWxkKSB7XG4gICAgdmFyIGZpZWxkTGlzdCA9IG1bZmllbGQubmFtZV0gPSBtW2ZpZWxkLm5hbWVdIHx8IFtdLFxuICAgICAgY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSA9IGZpZWxkTGlzdC5jb250YWluc1R5cGUgfHwge307XG5cbiAgICBpZiAoZmllbGRMaXN0LmluZGV4T2YoZmllbGQpID09PSAtMSkge1xuICAgICAgZmllbGRMaXN0LnB1c2goZmllbGQpO1xuICAgICAgLy8gYXVnbWVudCB0aGUgYXJyYXkgd2l0aCBjb250YWluc1R5cGUuUSAvIE8gLyBOIC8gVFxuICAgICAgY29udGFpbnNUeXBlW2ZpZWxkLnR5cGVdID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07XG5cbnZsZW5jLnNob3J0aGFuZCA9IGZ1bmN0aW9uKGVuYykge1xuICByZXR1cm4gdmxlbmMubWFwKGVuYywgZnVuY3Rpb24oZmllbGQsIGV0KSB7XG4gICAgcmV0dXJuIGV0ICsgYy5hc3NpZ24gKyB2bEVuY0RlZi5zaG9ydGhhbmQoZmllbGQpO1xuICB9KS5qb2luKGMuZGVsaW0pO1xufTtcblxudmxlbmMuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCkge1xuICB2YXIgZW5jID0gdXRpbC5pc0FycmF5KHNob3J0aGFuZCkgPyBzaG9ydGhhbmQgOiBzaG9ydGhhbmQuc3BsaXQoYy5kZWxpbSk7XG4gIHJldHVybiBlbmMucmVkdWNlKGZ1bmN0aW9uKG0sIGUpIHtcbiAgICB2YXIgc3BsaXQgPSBlLnNwbGl0KGMuYXNzaWduKSxcbiAgICAgICAgZW5jdHlwZSA9IHNwbGl0WzBdLnRyaW0oKSxcbiAgICAgICAgZmllbGQgPSBzcGxpdFsxXTtcblxuICAgIG1bZW5jdHlwZV0gPSB2bEVuY0RlZi5mcm9tU2hvcnRoYW5kKGZpZWxkKTtcbiAgICByZXR1cm4gbTtcbiAgfSwge30pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gdXRpbGl0eSBmb3IgZmllbGRcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgdGltZSA9IHJlcXVpcmUoJy4vY29tcGlsZXIvdGltZScpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG52YXIgdmxmaWVsZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogQHBhcmFtIGZpZWxkXG4gKiBAcGFyYW0gb3B0XG4gKiAgIG9wdC5ub2ZuIC0tIGV4Y2x1ZGUgYmluLCBhZ2dyZWdhdGUsIHRpbWVVbml0XG4gKiAgIG9wdC5ub0FnZ3JlZ2F0ZSAtLSBleGNsdWRlIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uXG4gKiAgIG9wdC5kYXR1bSAtIGluY2x1ZGUgJ2RhdHVtLidcbiAqICAgb3B0LmZuIC0gcmVwbGFjZSBmbiB3aXRoIGN1c3RvbSBmdW5jdGlvbiBwcmVmaXhcbiAqICAgb3B0LnByZWZuIC0gcHJlcGVuZCBmbiB3aXRoIGN1c3RvbSBmdW5jdGlvbiBwcmVmaXhcblxuICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbnZsZmllbGQuZmllbGRSZWYgPSBmdW5jdGlvbihmaWVsZCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICB2YXIgZiA9IChvcHQuZGF0dW0gPyAnZGF0dW0uJyA6ICcnKSArIChvcHQucHJlZm4gfHwgJycpLFxuICAgIG5hbWUgPSBmaWVsZC5uYW1lO1xuXG4gIGlmICh2bGZpZWxkLmlzQ291bnQoZmllbGQpKSB7XG4gICAgcmV0dXJuIGYgKyAnY291bnQnO1xuICB9IGVsc2UgaWYgKG9wdC5mbikge1xuICAgIHJldHVybiBmICsgb3B0LmZuICsgJ18nICsgbmFtZTtcbiAgfSBlbHNlIGlmICghb3B0Lm5vZm4gJiYgZmllbGQuYmluKSB7XG4gICAgcmV0dXJuIGYgKyAnYmluXycgKyBuYW1lO1xuICB9IGVsc2UgaWYgKCFvcHQubm9mbiAmJiAhb3B0Lm5vQWdncmVnYXRlICYmIGZpZWxkLmFnZ3JlZ2F0ZSkge1xuICAgIHJldHVybiBmICsgZmllbGQuYWdncmVnYXRlICsgJ18nICsgbmFtZTtcbiAgfSBlbHNlIGlmICghb3B0Lm5vZm4gJiYgZmllbGQudGltZVVuaXQpIHtcbiAgICByZXR1cm4gZiArIGZpZWxkLnRpbWVVbml0ICsgJ18nICsgbmFtZTtcbiAgfSAgZWxzZSB7XG4gICAgcmV0dXJuIGYgKyBuYW1lO1xuICB9XG59O1xuXG52bGZpZWxkLnNob3J0aGFuZCA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICByZXR1cm4gKGYuYWdncmVnYXRlID8gZi5hZ2dyZWdhdGUgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLnRpbWVVbml0ID8gZi50aW1lVW5pdCArIGMuZnVuYyA6ICcnKSArXG4gICAgKGYuYmluID8gJ2JpbicgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLm5hbWUgfHwgJycpICsgYy50eXBlICsgZi50eXBlO1xufTtcblxudmxmaWVsZC5zaG9ydGhhbmRzID0gZnVuY3Rpb24oZmllbGRzLCBkZWxpbSkge1xuICBkZWxpbSA9IGRlbGltIHx8IGMuZGVsaW07XG4gIHJldHVybiBmaWVsZHMubWFwKHZsZmllbGQuc2hvcnRoYW5kKS5qb2luKGRlbGltKTtcbn07XG5cbnZsZmllbGQuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCkge1xuICB2YXIgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy50eXBlKSwgaTtcbiAgdmFyIG8gPSB7XG4gICAgbmFtZTogc3BsaXRbMF0udHJpbSgpLFxuICAgIHR5cGU6IHNwbGl0WzFdLnRyaW0oKVxuICB9O1xuXG4gIC8vIGNoZWNrIGFnZ3JlZ2F0ZSB0eXBlXG4gIGZvciAoaSBpbiBzY2hlbWEuYWdncmVnYXRlLmVudW0pIHtcbiAgICB2YXIgYSA9IHNjaGVtYS5hZ2dyZWdhdGUuZW51bVtpXTtcbiAgICBpZiAoby5uYW1lLmluZGV4T2YoYSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoYS5sZW5ndGggKyAxKTtcbiAgICAgIGlmIChhID09ICdjb3VudCcgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gJyonO1xuICAgICAgby5hZ2dyZWdhdGUgPSBhO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgdGltZSB0aW1lVW5pdFxuICBmb3IgKGkgaW4gc2NoZW1hLnRpbWVmbnMpIHtcbiAgICB2YXIgdHUgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKHR1ICsgJ18nKSA9PT0gMCkge1xuICAgICAgby5uYW1lID0gby5uYW1lLnN1YnN0cihvLmxlbmd0aCArIDEpO1xuICAgICAgby50aW1lVW5pdCA9IHR1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgYmluXG4gIGlmIChvLm5hbWUgJiYgby5uYW1lLmluZGV4T2YoJ2Jpbl8nKSA9PT0gMCkge1xuICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoNCk7XG4gICAgby5iaW4gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG87XG59O1xuXG52YXIgaXNUeXBlID0gdmxmaWVsZC5pc1R5cGUgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGUpIHtcbiAgcmV0dXJuIGZpZWxkRGVmLnR5cGUgPT09IHR5cGU7XG59O1xuXG52YXIgaXNUeXBlcyA9IHZsZmllbGQuaXNUeXBlcyA9IGZ1bmN0aW9uIChmaWVsZERlZiwgdHlwZXMpIHtcbiAgZm9yICh2YXIgdD0wOyB0PHR5cGVzLmxlbmd0aDsgdCsrKSB7XG4gICAgaWYoZmllbGREZWYudHlwZSA9PT0gdHlwZXNbdF0pIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qXG4gKiBNb3N0IGZpZWxkcyB0aGF0IHVzZSBvcmRpbmFsIHNjYWxlIGFyZSBkaW1lbnNpb25zLlxuICogSG93ZXZlciwgWUVBUihUKSwgWUVBUk1PTlRIKFQpIHVzZSB0aW1lIHNjYWxlLCBub3Qgb3JkaW5hbCBidXQgYXJlIGRpbWVuc2lvbnMgdG9vLlxuICovXG52bGZpZWxkLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuICBpc1R5cGVzKGZpZWxkLCBbTiwgT10pIHx8IGZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiBmaWVsZC50aW1lVW5pdCAmJiB0aW1lLmlzT3JkaW5hbEZuKGZpZWxkLnRpbWVVbml0KSApO1xufTtcblxuZnVuY3Rpb24gaXNEaW1lbnNpb24oZmllbGQpIHtcbiAgcmV0dXJuICBpc1R5cGVzKGZpZWxkLCBbTiwgT10pIHx8ICEhZmllbGQuYmluIHx8XG4gICAgKCBpc1R5cGUoZmllbGQsIFQpICYmICEhZmllbGQudGltZVVuaXQgKTtcbn1cblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5pc0RpbWVuc2lvbigpIHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAqIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5pc0RpbWVuc2lvbiA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZCAmJiBpc0RpbWVuc2lvbihmaWVsZCk7XG59O1xuXG52bGZpZWxkLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZCAmJiAhaXNEaW1lbnNpb24oZmllbGQpO1xufTtcblxudmxmaWVsZC5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge25hbWU6JyonLCBhZ2dyZWdhdGU6ICdjb3VudCcsIHR5cGU6IFEsIGRpc3BsYXlOYW1lOiB2bGZpZWxkLmNvdW50LmRpc3BsYXlOYW1lfTtcbn07XG5cbnZsZmllbGQuY291bnQuZGlzcGxheU5hbWUgPSAnTnVtYmVyIG9mIFJlY29yZHMnO1xuXG52bGZpZWxkLmlzQ291bnQgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQuYWdncmVnYXRlID09PSAnY291bnQnO1xufTtcblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5jYXJkaW5hbGl0eSgpIHRvIGF2b2lkIGNvbmZ1c2lvbi4gIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCkge1xuICAvLyBGSVhNRSBuZWVkIHRvIHRha2UgZmlsdGVyIGludG8gYWNjb3VudFxuXG4gIHZhciBzdGF0ID0gc3RhdHNbZmllbGQubmFtZV07XG4gIHZhciB0eXBlID0gZmllbGQudHlwZTtcblxuICBmaWx0ZXJOdWxsID0gZmlsdGVyTnVsbCB8fCB7fTtcblxuICBpZiAoZmllbGQuYmluKSB7XG4gICAgdmFyIGJpbnMgPSB1dGlsLmdldGJpbnMoc3RhdCwgZmllbGQuYmluLm1heGJpbnMgfHwgc2NoZW1hLk1BWEJJTlNfREVGQVVMVCk7XG4gICAgcmV0dXJuIChiaW5zLnN0b3AgLSBiaW5zLnN0YXJ0KSAvIGJpbnMuc3RlcDtcbiAgfVxuICBpZiAoaXNUeXBlKGZpZWxkLCBUKSkge1xuICAgIHZhciBjYXJkaW5hbGl0eSA9IHRpbWUuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsLCB0eXBlKTtcbiAgICBpZihjYXJkaW5hbGl0eSAhPT0gbnVsbCkgcmV0dXJuIGNhcmRpbmFsaXR5O1xuICAgIC8vb3RoZXJ3aXNlIHVzZSBjYWxjdWxhdGlvbiBiZWxvd1xuICB9XG4gIGlmIChmaWVsZC5hZ2dyZWdhdGUpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBudWxsXG4gIHJldHVybiBzdGF0LmRpc3RpbmN0IC1cbiAgICAoc3RhdC5taXNzaW5nID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZGVjbGFyZSBnbG9iYWwgY29uc3RhbnRcbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuZy5BR0dSRUdBVEUgPSAnYWdncmVnYXRlJztcbmcuUkFXID0gJ3Jhdyc7XG5nLlNUQUNLRUQgPSAnc3RhY2tlZCc7XG5nLklOREVYID0gJ2luZGV4JztcblxuZy5YID0gJ3gnO1xuZy5ZID0gJ3knO1xuZy5ST1cgPSAncm93JztcbmcuQ09MID0gJ2NvbCc7XG5nLlNJWkUgPSAnc2l6ZSc7XG5nLlNIQVBFID0gJ3NoYXBlJztcbmcuQ09MT1IgPSAnY29sb3InO1xuZy5URVhUID0gJ3RleHQnO1xuZy5ERVRBSUwgPSAnZGV0YWlsJztcblxuZy5OID0gJ04nO1xuZy5PID0gJ08nO1xuZy5RID0gJ1EnO1xuZy5UID0gJ1QnO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUT0RPKGthbml0dyk6IGNoYXQgd2l0aCBWZWdhIHRlYW0gYW5kIHBvc3NpYmx5IG1vdmUgdGhpcyB0byB2ZWdhLWxvZ2dpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gIC8vIEJvcnJvd2VkIHNvbWUgaWRlYXMgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTY1MzI2MC84NjY5ODlcbiAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXRpay9jb25zb2xlLmxvZy13cmFwcGVyL2Jsb2IvbWFzdGVyL2NvbnNvbGVsb2cuanNcbiAgdmFyIE1FVEhPRFMgPSBbJ2Vycm9yJywgJ2luZm8nLCAnZGVidWcnLCAnd2FybicsICdsb2cnXTtcblxuICByZXR1cm4gTUVUSE9EUy5yZWR1Y2UoZnVuY3Rpb24obG9nZ2VyLCBmbikge1xuICAgIHZhciBjZm4gPSBjb25zb2xlW2ZuXSA/IGZuIDogJ2xvZyc7XG4gICAgaWYgKGNvbnNvbGVbY2ZuXS5iaW5kID09PSAndW5kZWZpbmVkJykgeyAvLyBJRSA8IDEwXG4gICAgICAgIGxvZ2dlcltmbl0gPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGVbY2ZuXSwgY29uc29sZSwgcHJlZml4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlcltmbl0gPSBjb25zb2xlW2Nmbl0uYmluZChjb25zb2xlLCBwcmVmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyO1xuICB9LCB7fSk7XG59OyIsIi8vIFBhY2thZ2Ugb2YgZGVmaW5pbmcgVmVnYS1saXRlIFNwZWNpZmljYXRpb24ncyBqc29uIHNjaGVtYVxuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBzY2hlbWEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB0b01hcCA9IHV0aWwudG9NYXAsXG4gIGNvbG9yYnJld2VyID0gcmVxdWlyZSgnY29sb3JicmV3ZXInKTtcblxudmFyIFZBTElEX0FHR19PUFMgPSByZXF1aXJlKCd2ZWdhL3NyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZScpLlZBTElEX09QUztcblxuLy8gVE9ETygjNjIwKSByZWZlciB0byB2ZWdhIHNjaGVtYVxuLy8gdmFyIHZnU3RhY2tTY2hlbWEgPSByZXF1aXJlKCd2ZWdhL3NyYy90cmFuc2Zvcm1zL1N0YWNrJykuc2NoZW1hO1xuXG5cbnNjaGVtYS51dGlsID0gcmVxdWlyZSgnLi9zY2hlbWF1dGlsJyk7XG5cbnNjaGVtYS5tYXJrdHlwZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsncG9pbnQnLCAndGljaycsICdiYXInLCAnbGluZScsICdhcmVhJywgJ2NpcmNsZScsICdzcXVhcmUnLCAndGV4dCddXG59O1xuXG5zY2hlbWEuYWdncmVnYXRlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogVkFMSURfQUdHX09QUyxcbiAgc3VwcG9ydGVkRW51bXM6IHtcbiAgICBROiBWQUxJRF9BR0dfT1BTLFxuICAgIE86IFsnbWVkaWFuJywnbWluJywnbWF4J10sXG4gICAgTjogW10sXG4gICAgVDogWydtZWFuJywgJ21lZGlhbicsICdtaW4nLCAnbWF4J10sXG4gICAgJyc6IFsnY291bnQnXVxuICB9LFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1EsIE4sIE8sIFQsICcnXSlcbn07XG5cbnNjaGVtYS5nZXRTdXBwb3J0ZWRSb2xlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICByZXR1cm4gc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmVuY29kaW5nLnByb3BlcnRpZXNbZW5jVHlwZV0uc3VwcG9ydGVkUm9sZTtcbn07XG5cbnNjaGVtYS50aW1lVW5pdHMgPSBbJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ2RhdGUnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ107XG5cbnNjaGVtYS5kZWZhdWx0VGltZUZuID0gJ21vbnRoJztcblxuc2NoZW1hLnRpbWVVbml0ID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogc2NoZW1hLnRpbWVVbml0cyxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtUXSlcbn07XG5cbnNjaGVtYS5zY2FsZV90eXBlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgLy8gVE9ETyhrYW5pdHcpIHJlYWQgdmVnYSdzIHNjaGVtYSBoZXJlLCBhZGQgZGVzY3JpcHRpb25cbiAgZW51bTogWydsaW5lYXInLCAnbG9nJywgJ3BvdycsICdzcXJ0JywgJ3F1YW50aWxlJ10sXG4gIGRlZmF1bHQ6ICdsaW5lYXInLFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1FdKVxufTtcblxuc2NoZW1hLmZpZWxkID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxuICB9XG59O1xuXG52YXIgY2xvbmUgPSB1dGlsLmR1cGxpY2F0ZTtcbnZhciBtZXJnZSA9IHNjaGVtYS51dGlsLm1lcmdlO1xuXG5zY2hlbWEuTUFYQklOU19ERUZBVUxUID0gMTU7XG5cbnZhciBiaW4gPSB7XG4gIHR5cGU6IFsnYm9vbGVhbicsICdvYmplY3QnXSxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYXhiaW5zOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiBzY2hlbWEuTUFYQklOU19ERUZBVUxULFxuICAgICAgbWluaW11bTogMixcbiAgICAgIGRlc2NyaXB0aW9uOiAnTWF4aW11bSBudW1iZXIgb2YgYmlucy4nXG4gICAgfVxuICB9LFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1FdKSAvLyBUT0RPOiBhZGQgTyBhZnRlciBmaW5pc2hpbmcgIzgxXG59O1xuXG52YXIgdHlwaWNhbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogW04sIE8sIFEsIFRdXG4gICAgfSxcbiAgICBhZ2dyZWdhdGU6IHNjaGVtYS5hZ2dyZWdhdGUsXG4gICAgdGltZVVuaXQ6IHNjaGVtYS50aW1lVW5pdCxcbiAgICBiaW46IGJpbixcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qIENvbW1vbiBTY2FsZSBQcm9wZXJ0aWVzICovXG4gICAgICAgIHR5cGU6IHNjaGVtYS5zY2FsZV90eXBlLFxuXG4gICAgICAgIC8qIFF1YW50aXRhdGl2ZSBTY2FsZSBQcm9wZXJ0aWVzICovXG4gICAgICAgIG5pY2U6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJ10sXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtUXSlcbiAgICAgICAgfSxcbiAgICAgICAgemVybzoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0luY2x1ZGUgemVybycsXG4gICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1EsIFRdKVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIFZlZ2EtbGl0ZSBvbmx5IFByb3BlcnRpZXMgKi9cbiAgICAgICAgdXNlUmF3RG9tYWluOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1VzZSB0aGUgcmF3IGRhdGEgcmFuZ2UgYXMgc2NhbGUgZG9tYWluIGluc3RlYWQgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdhZ2dyZWdhdGVkIGRhdGEgZm9yIGFnZ3JlZ2F0ZSBheGlzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ1RoaXMgb3B0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBzdW0gb3IgY291bnQgYWdncmVnYXRlJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdhcyB0aGV5IG1pZ2h0IGhhdmUgYSBzdWJzdGFudGlhbGx5IGxhcmdlciBzY2FsZSByYW5nZS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ0J5IGRlZmF1bHQsIHVzZSB2YWx1ZSBmcm9tIGNvbmZpZy51c2VSYXdEb21haW4uJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIG9ubHlPcmRpbmFsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlXG4gIH0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFtOLCBPLCBRLCBUXSAvLyBvcmRpbmFsLW9ubHkgZmllbGQgc3VwcG9ydHMgUSB3aGVuIGJpbiBpcyBhcHBsaWVkIGFuZCBUIHdoZW4gdGltZSB1bml0IGlzIGFwcGxpZWQuXG4gICAgfSxcbiAgICB0aW1lVW5pdDogc2NoZW1hLnRpbWVVbml0LFxuICAgIGJpbjogYmluLFxuICAgIGFnZ3JlZ2F0ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NvdW50J10sXG4gICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW04sIE9dKSAvLyBGSVhNRSB0aGlzIGxvb2tzIHdlaXJkIHRvIG1lXG4gICAgfVxuICB9XG59KTtcblxudmFyIGF4aXNNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIGF4aXM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKiBWZWdhIEF4aXMgUHJvcGVydGllcyAqL1xuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZm9ybWF0dGluZyBwYXR0ZXJuIGZvciBheGlzIGxhYmVscy4gJytcbiAgICAgICAgICAgICAgICAgICAgICAgJ0lmIG5vdCB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnc21hbGwvbGFyZ2VOdW1iZXJGb3JtYXQgYW5kIHRoZSBtYXggdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdvZiB0aGUgZmllbGQuJ1xuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgZmxhZyBpbmRpY2F0ZSBpZiBncmlkbGluZXMgc2hvdWxkIGJlIGNyZWF0ZWQgaW4gYWRkaXRpb24gdG8gdGlja3MuIElmIGBncmlkYCBpcyB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgIGZvciBST1cgYW5kIENPTC4gRm9yIFggYW5kIFksIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYCBmb3IgcXVhbnRpdGF0aXZlIGFuZCB0aW1lIGZpZWxkcyBhbmQgYGZhbHNlYCBvdGhlcndpc2UuJ1xuICAgICAgICB9LFxuICAgICAgICBsYXllcjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdiYWNrJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Egc3RyaW5nIGluZGljYXRpbmcgaWYgdGhlIGF4aXMgKGFuZCBhbnkgZ3JpZGxpbmVzKSBzaG91bGQgYmUgcGxhY2VkIGFib3ZlIG9yIGJlbG93IHRoZSBkYXRhIG1hcmtzLiBPbmUgb2YgXCJmcm9udFwiIChkZWZhdWx0KSBvciBcImJhY2tcIi4nXG4gICAgICAgIH0sXG4gICAgICAgIG9yaWVudDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBlbnVtOiBbJ3RvcCcsICdyaWdodCcsICdsZWZ0JywgJ2JvdHRvbSddLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIG9yaWVudGF0aW9uIG9mIHRoZSBheGlzLiBPbmUgb2YgdG9wLCBib3R0b20sIGxlZnQgb3IgcmlnaHQuIFRoZSBvcmllbnRhdGlvbiBjYW4gYmUgdXNlZCB0byBmdXJ0aGVyIHNwZWNpYWxpemUgdGhlIGF4aXMgdHlwZSAoZS5nLiwgYSB5IGF4aXMgb3JpZW50ZWQgZm9yIHRoZSByaWdodCBlZGdlIG9mIHRoZSBjaGFydCkuJ1xuICAgICAgICB9LFxuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiA1LFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIGRlc2lyZWQgbnVtYmVyIG9mIHRpY2tzLCBmb3IgYXhlcyB2aXN1YWxpemluZyBxdWFudGl0YXRpdmUgc2NhbGVzLiBUaGUgcmVzdWx0aW5nIG51bWJlciBtYXkgYmUgZGlmZmVyZW50IHNvIHRoYXQgdmFsdWVzIGFyZSBcIm5pY2VcIiAobXVsdGlwbGVzIG9mIDIsIDUsIDEwKSBhbmQgbGllIHdpdGhpbiB0aGUgdW5kZXJseWluZyBzY2FsZVxcJ3MgcmFuZ2UuJ1xuICAgICAgICB9LFxuICAgICAgICAvKiBWZWdhIEF4aXMgUHJvcGVydGllcyB0aGF0IGFyZSBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBieSBWZWdhLWxpdGUgKi9cbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIGZvciB0aGUgYXhpcy4gKFNob3dzIGZpZWxkIG5hbWUgYW5kIGl0cyBmdW5jdGlvbiBieSBkZWZhdWx0LiknXG4gICAgICAgIH0sXG4gICAgICAgIC8qIFZlZ2EtbGl0ZSBvbmx5ICovXG4gICAgICAgIG1heExhYmVsTGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDI1LFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUcnVuY2F0ZSBsYWJlbHMgdGhhdCBhcmUgdG9vIGxvbmcuJ1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbEFuZ2xlOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgLy8gYXV0b1xuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgbWF4aW11bTogMzYwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIGxhYmVscy4gU2V0IHRvIDAgdG8gZm9yY2UgaG9yaXpvbnRhbC4nXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlTWF4TGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWF4IGxlbmd0aCBmb3IgYXhpcyB0aXRsZSBpZiB0aGUgdGl0bGUgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSB0aGUgZmllbGRcXCdzIGRlc2NyaXB0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZU9mZnNldDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIG9mZnNldCB2YWx1ZSBmb3IgdGhlIGF4aXMuJ1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNvcnRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBzb3J0OiB7XG4gICAgICBkZWZhdWx0OiAnYXNjZW5kaW5nJyxcbiAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbTiwgT10pLFxuICAgICAgb25lT2Y6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnYXNjZW5kaW5nJywgJ2Rlc2NlbmRpbmcnLCAndW5zb3J0ZWQnXVxuICAgICAgICB9LFxuICAgICAgICB7IC8vIHNvcnQgYnkgYWdncmVnYXRpb24gb2YgYW5vdGhlciBmaWVsZFxuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHJlcXVpcmVkOiBbJ2ZpZWxkJywgJ29wJ10sXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGZpZWxkIG5hbWUgdG8gYWdncmVnYXRlIG92ZXIuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBlbnVtOiBWQUxJRF9BR0dfT1BTLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBmaWVsZCBuYW1lIHRvIGFnZ3JlZ2F0ZSBvdmVyLidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmRlcjoge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZW51bTogWydhc2NlbmRpbmcnLCAnZGVzY2VuZGluZyddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG5cbiAgICB9XG4gIH1cbn07XG5cbnZhciBiYW5kTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYmFuZDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlZmF1bHQ6IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGxlZ2VuZE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Byb3BlcnRpZXMgb2YgYSBsZWdlbmQuJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIGZvciB0aGUgbGVnZW5kLiAoU2hvd3MgZmllbGQgbmFtZSBhbmQgaXRzIGZ1bmN0aW9uIGJ5IGRlZmF1bHQuKSdcbiAgICAgICAgfSxcbiAgICAgICAgb3JpZW50OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ3JpZ2h0JyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBvcmllbnRhdGlvbiBvZiB0aGUgbGVnZW5kLiBPbmUgb2YgXCJsZWZ0XCIgb3IgXCJyaWdodFwiLiBUaGlzIGRldGVybWluZXMgaG93IHRoZSBsZWdlbmQgaXMgcG9zaXRpb25lZCB3aXRoaW4gdGhlIHNjZW5lLiBUaGUgZGVmYXVsdCBpcyBcInJpZ2h0XCIuJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7J3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdyaWdodCdcbiAgICB9LFxuICAgIGJhc2VsaW5lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdtaWRkbGUnXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJyMwMDAwMDAnXG4gICAgfSxcbiAgICBtYXJnaW46IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDQsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnQWJjJ1xuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHdlaWdodDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2JvbGQnXSxcbiAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwLFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfSxcbiAgICAgICAgZmFtaWx5OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ0hlbHZldGljYSBOZXVlJ1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2l0YWxpYyddXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZvcm1hdDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICBkZXNjcmlwdGlvbjogJ1RoZSBmb3JtYXR0aW5nIHBhdHRlcm4gZm9yIHRleHQgdmFsdWUuICcrXG4gICAgICAgICAgICAgICAgICAgJ0lmIG5vdCB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICdzbWFsbC9sYXJnZU51bWJlckZvcm1hdCBhbmQgdGhlIG1heCB2YWx1ZSAnICtcbiAgICAgICAgICAgICAgICAgICAnb2YgdGhlIGZpZWxkLidcbiAgICB9LFxuICB9XG59O1xuXG52YXIgc2l6ZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGJhcjogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDMwLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnU2l6ZSBvZiBtYXJrcy4nXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29sb3JNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCAndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICcjNDY4MmI0JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29sb3IgdG8gYmUgdXNlZCBmb3IgbWFya3MuJ1xuICAgIH0sXG4gICAgb3BhY2l0eToge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMVxuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByYW5nZToge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2FycmF5J10sXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgJ0NvbG9yIHBhbGV0dGUsIGlmIHVuZGVmaW5lZCB2ZWdhLWxpdGUgd2lsbCB1c2UgZGF0YSBwcm9wZXJ0eScgK1xuICAgICAgICAgICAgJ3RvIHBpY2sgb25lIGZyb20gYzEwcGFsZXR0ZSwgYzIwcGFsZXR0ZSwgb3Igb3JkaW5hbFBhbGV0dGUuJ1xuICAgICAgICAgICAgLy9GSVhNRVxuICAgICAgICB9LFxuICAgICAgICBjMTBwYWxldHRlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2NhdGVnb3J5MTAnLFxuICAgICAgICAgIGVudW06IFtcbiAgICAgICAgICAgIC8vIFRhYmxlYXVcbiAgICAgICAgICAgICdjYXRlZ29yeTEwJywgJ2NhdGVnb3J5MTBrJyxcbiAgICAgICAgICAgIC8vIENvbG9yIEJyZXdlclxuICAgICAgICAgICAgJ1Bhc3RlbDEnLCAnUGFzdGVsMicsICdTZXQxJywgJ1NldDInLCAnU2V0MydcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGMyMHBhbGV0dGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnY2F0ZWdvcnkyMCcsXG4gICAgICAgICAgZW51bTogWydjYXRlZ29yeTIwJywgJ2NhdGVnb3J5MjBiJywgJ2NhdGVnb3J5MjBjJ11cbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbFBhbGV0dGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdDb2xvciBwYWxldHRlIHRvIGVuY29kZSBvcmRpbmFsIHZhcmlhYmxlcy4nLFxuICAgICAgICAgIGVudW06IHV0aWwua2V5cyhjb2xvcmJyZXdlcilcbiAgICAgICAgfSxcbiAgICAgICAgcXVhbnRpdGF0aXZlUmFuZ2U6IHtcbiAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgIGRlZmF1bHQ6IFsnI0FGQzZBMycsICcjMDk2MjJBJ10sIC8vIHRhYmxlYXUgZ3JlZW5zXG4gICAgICAgICAgLy8gZGVmYXVsdDogWycjY2NlY2U2JywgJyMwMDQ0MWInXSwgLy8gQnVHbi45IFsyLThdXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdDb2xvciByYW5nZSB0byBlbmNvZGUgcXVhbnRpdGF0aXZlIHZhcmlhYmxlcy4nLFxuICAgICAgICAgIG1pbkl0ZW1zOiAyLFxuICAgICAgICAgIG1heEl0ZW1zOiAyLFxuICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIHJvbGU6ICdjb2xvcidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzdGFja01peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIHN0YWNrOiB7XG4gICAgICB0eXBlOiBbJ2Jvb2xlYW4nLCAnb2JqZWN0J10sXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdFbmFibGUgc3RhY2tpbmcgKGZvciBiYXIgYW5kIGFyZWEgbWFya3Mgb25seSkuJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdG8gcmV2ZXJzZSB0aGUgc3RhY2tcXCdzIHNvcnRieS4nXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBlbnVtOiBbJ3plcm8nLCAnY2VudGVyJywgJ25vcm1hbGl6ZSddXG4gICAgICAgICAgLy8gVE9ETygjNjIwKSByZWZlciB0byBWZWdhIHNwZWMgb25jZSBpdCBkb2Vzbid0IHRocm93IGVycm9yXG4gICAgICAgICAgLy8gZW51bTogdmdTdGFja1NjaGVtYS5wcm9wZXJ0aWVzLm9mZnNldC5vbmVPZlswXS5lbnVtXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaGFwZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnY2lyY2xlJywgJ3NxdWFyZScsICdjcm9zcycsICdkaWFtb25kJywgJ3RyaWFuZ2xlLXVwJywgJ3RyaWFuZ2xlLWRvd24nXSxcbiAgICAgIGRlZmF1bHQ6ICdjaXJjbGUnLFxuICAgICAgZGVzY3JpcHRpb246ICdNYXJrIHRvIGJlIHVzZWQuJ1xuICAgIH0sXG4gICAgZmlsbGVkOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciB0aGUgc2hhcGVcXCdzIGNvbG9yIHNob3VsZCBiZSB1c2VkIGFzIGZpbGwgY29sb3IgaW5zdGVhZCBvZiBzdHJva2UgY29sb3IuJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldGFpbE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGxpbmU6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfVxufTtcblxudmFyIHJvd01peGluID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb2xNaXhpbiA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMTIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWNldE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJlcXVpcmVkTmFtZVR5cGUgPSB7XG4gIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddXG59O1xuXG52YXIgbXVsdGlSb2xlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9XG59KTtcblxudmFyIHF1YW50aXRhdGl2ZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBkaW1lbnNpb246ICdvcmRpbmFsLW9ubHknIC8vIHVzaW5nIHNpemUgdG8gZW5jb2RpbmcgY2F0ZWdvcnkgbGVhZCB0byBvcmRlciBpbnRlcnByZXRhdGlvblxuICB9XG59KTtcblxudmFyIG9ubHlRdWFudGl0YXRpdmVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWVcbiAgfVxufSk7XG5cbnZhciB4ID0gbWVyZ2UoY2xvbmUobXVsdGlSb2xlRmllbGQpLCBheGlzTWl4aW4sIGJhbmRNaXhpbiwgcmVxdWlyZWROYW1lVHlwZSwgc29ydE1peGluKTtcbnZhciB5ID0gY2xvbmUoeCk7XG5cbnZhciBmYWNldCA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCByZXF1aXJlZE5hbWVUeXBlLCBmYWNldE1peGluLCBzb3J0TWl4aW4pO1xudmFyIHJvdyA9IG1lcmdlKGNsb25lKGZhY2V0KSwgYXhpc01peGluLCByb3dNaXhpbik7XG52YXIgY29sID0gbWVyZ2UoY2xvbmUoZmFjZXQpLCBheGlzTWl4aW4sIGNvbE1peGluKTtcblxudmFyIHNpemUgPSBtZXJnZShjbG9uZShxdWFudGl0YXRpdmVGaWVsZCksIGxlZ2VuZE1peGluLCBzaXplTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgY29sb3IgPSBtZXJnZShjbG9uZShtdWx0aVJvbGVGaWVsZCksIGxlZ2VuZE1peGluLCBjb2xvck1peGluLCBzdGFja01peGluLCBzb3J0TWl4aW4pO1xuXG52YXIgc2hhcGUgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgbGVnZW5kTWl4aW4sIHNoYXBlTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgZGV0YWlsID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIGRldGFpbE1peGluLCBzdGFja01peGluLCBzb3J0TWl4aW4pO1xuXG4vLyB3ZSBvbmx5IHB1dCBhZ2dyZWdhdGVkIG1lYXN1cmUgaW4gcGl2b3QgdGFibGVcbnZhciB0ZXh0ID0gbWVyZ2UoY2xvbmUob25seVF1YW50aXRhdGl2ZUZpZWxkKSwgdGV4dE1peGluLCBzb3J0TWl4aW4pO1xuXG4vLyBUT0RPIGFkZCBsYWJlbFxuXG52YXIgZGF0YSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyBkYXRhIHNvdXJjZVxuICAgIGZvcm1hdFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydqc29uJywgJ2NzdiddLFxuICAgICAgZGVmYXVsdDogJ2pzb24nXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Bhc3MgYXJyYXkgb2Ygb2JqZWN0cyBpbnN0ZWFkIG9mIGEgdXJsIHRvIGEgZmlsZS4nLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyB3ZSBnZW5lcmF0ZSBhIHZlZ2EgZmlsdGVyIHRyYW5zZm9ybVxuICAgIGZpbHRlcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICBkZXNjcmlwdGlvbjogJ0Egc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZpbHRlciBWZWdhIGV4cHJlc3Npb24uIFVzZSBgZGF0dW1gIHRvIHJlZmVyIHRvIHRoZSBjdXJyZW50IGRhdGEgb2JqZWN0LidcbiAgICB9LFxuICAgIC8vIHdlIGdlbmVyYXRlIGEgdmVnYSBmb3JtdWxhIHRyYW5zZm9ybVxuICAgIGZvcm11bGFzOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgZGVzY3JpcHRpb246ICdBcnJheSBvZiBmb3JtdWxhIHRyYW5zZm9ybXMuIEZvcm11bGFzIGFyZSBhcHBsaWVkIGJlZm9yZSBmaWx0ZXIuJyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgcHJvcGVydHkgbmFtZSBpbiB3aGljaCB0byBzdG9yZSB0aGUgY29tcHV0ZWQgZm9ybXVsYSB2YWx1ZS4nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHByOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBzdHJpbmcgY29udGFpbmluZyBhbiBleHByZXNzaW9uIGZvciB0aGUgZm9ybXVsYS4gVXNlIHRoZSB2YXJpYWJsZSBgZGF0dW1gIHRvIHRvIHJlZmVyIHRvIHRoZSBjdXJyZW50IGRhdGEgb2JqZWN0LidcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb25maWcgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gdGVtcGxhdGVcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnaW50ZWdlcidcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJyMwMDAwMDAnXG4gICAgfSxcbiAgICBncmlkT3BhY2l0eToge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRlZmF1bHQ6IDAuMDhcbiAgICB9LFxuXG4gICAgLy8gZmlsdGVyIG51bGxcbiAgICAvLyBUT0RPKCM1OTcpIHJldmlzZSB0aGlzIGNvbmZpZ1xuICAgIGZpbHRlck51bGw6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBOOiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICAgICAgTzoge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZX0sXG4gICAgICAgIFE6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX0sXG4gICAgICAgIFQ6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX1cbiAgICAgIH1cbiAgICB9LFxuICAgIGF1dG9Tb3J0TGluZToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG5cbiAgICAvLyBzaW5nbGUgcGxvdFxuICAgIHNpbmdsZUhlaWdodDoge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBiYW5kV2lkdGggKiAoY2FyZGluYWxpdHkgKyBwYWRkaW5nKVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgc2luZ2xlV2lkdGg6IHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoICogKGNhcmRpbmFsaXR5ICsgcGFkZGluZylcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwMCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIC8vIGJhbmQgc2l6ZVxuICAgIGxhcmdlQmFuZFNpemU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIxLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgc21hbGxCYW5kU2l6ZToge1xuICAgICAgLy9zbWFsbCBtdWx0aXBsZXMgb3Igc2luZ2xlIHBsb3Qgd2l0aCBoaWdoIGNhcmRpbmFsaXR5XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAxMixcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIGxhcmdlQmFuZE1heENhcmRpbmFsaXR5OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAxMFxuICAgIH0sXG4gICAgLy8gc21hbGwgbXVsdGlwbGVzXG4gICAgY2VsbFBhZGRpbmc6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZGVmYXVsdDogMC4xXG4gICAgfSxcbiAgICBjZWxsR3JpZENvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnIzAwMDAwMCdcbiAgICB9LFxuICAgIGNlbGxHcmlkT3BhY2l0eToge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRlZmF1bHQ6IDAuMjVcbiAgICB9LFxuICAgIGNlbGxHcmlkT2Zmc2V0OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IDYgLy8gZXF1YWwgdG8gdGlja1NpemVcbiAgICB9LFxuICAgIGNlbGxCYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICdyZ2JhKDAsMCwwLDApJ1xuICAgIH0sXG4gICAgdGV4dENlbGxXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogOTAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIG1hcmtzXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzaW5nbGVCYXJPZmZzZXQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICAvLyBzY2FsZXNcbiAgICB0aW1lU2NhbGVMYWJlbExlbmd0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZXNjcmlwdGlvbjogJ01heCBsZW5ndGggZm9yIHZhbHVlcyBpbiBkYXlTY2FsZUxhYmVsIGFuZCBtb250aFNjYWxlTGFiZWwuICBaZXJvIG1lYW5zIHVzaW5nIGZ1bGwgbmFtZXMgaW4gZGF5U2NhbGVMYWJlbC9tb250aFNjYWxlTGFiZWwuJ1xuICAgIH0sXG4gICAgZGF5U2NhbGVMYWJlbDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAgICAgZGVzY3JpcHRpb246ICdBeGlzIGxhYmVscyBmb3IgZGF5IG9mIHdlZWssIHN0YXJ0aW5nIGZyb20gU3VuZGF5LicgK1xuICAgICAgICAnKENvbnNpc3RlbnQgd2l0aCBKYXZhc2NyaXB0IC0tIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL2dldERheS4nXG4gICAgfSxcbiAgICBtb250aFNjYWxlTGFiZWw6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgZGVzY3JpcHRpb246ICdBeGlzIGxhYmVscyBmb3IgbW9udGguJ1xuICAgIH0sXG4gICAgLy8gb3RoZXJcbiAgICBjaGFyYWN0ZXJXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNlxuICAgIH0sXG4gICAgbWF4U21hbGxOdW1iZXI6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZGVmYXVsdDogMTAwMDAsXG4gICAgICBkZXNjcmlwdGlvbjogJ21heGltdW0gbnVtYmVyIHRoYXQgYSBmaWVsZCB3aWxsIGJlIGNvbnNpZGVyZWQgc21hbGxOdW1iZXIuJytcbiAgICAgICAgICAgICAgICAgICAnVXNlZCBmb3IgYXhpcyBsYWJlbGxpbmcuJ1xuICAgIH0sXG4gICAgc21hbGxOdW1iZXJGb3JtYXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0QzIE51bWJlciBmb3JtYXQgZm9yIGF4aXMgbGFiZWxzIGFuZCB0ZXh0IHRhYmxlcyAnK1xuICAgICAgICAgICAgICAgICAgICdmb3IgbnVtYmVyIDw9IG1heFNtYWxsTnVtYmVyLiBVc2VkIGZvciBheGlzIGxhYmVsbGluZy4nXG4gICAgfSxcbiAgICBsYXJnZU51bWJlckZvcm1hdDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnLjNzJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRDMgTnVtYmVyIGZvcm1hdCBmb3IgYXhpcyBsYWJlbHMgYW5kIHRleHQgdGFibGVzICcgK1xuICAgICAgICAgICAgICAgICAgICdmb3IgbnVtYmVyID4gbWF4U21hbGxOdW1iZXIuJ1xuICAgIH0sXG4gICAgdGltZUZvcm1hdDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnJVktJW0tJWQnLFxuICAgICAgZGVzY3JpcHRpb246ICdEYXRlIGZvcm1hdCBmb3IgYXhpcyBsYWJlbHMuJ1xuICAgIH0sXG4gICAgdXNlUmF3RG9tYWluOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVXNlIHRoZSByYXcgZGF0YSByYW5nZSBhcyBzY2FsZSBkb21haW4gaW5zdGVhZCBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAnYWdncmVnYXRlZCBkYXRhIGZvciBhZ2dyZWdhdGUgYXhpcy4gJyArXG4gICAgICAgICAgICAgICAgICAgJ1RoaXMgb3B0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBzdW0gb3IgY291bnQgYWdncmVnYXRlJyArXG4gICAgICAgICAgICAgICAgICAgJ2FzIHRoZXkgbWlnaHQgaGF2ZSBhIHN1YnN0YW50aWFsbHkgbGFyZ2VyIHNjYWxlIHJhbmdlLicgK1xuICAgICAgICAgICAgICAgICAgICdCeSBkZWZhdWx0LCB1c2UgdmFsdWUgZnJvbSBjb25maWcudXNlUmF3RG9tYWluLidcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAdHlwZSBPYmplY3QgU2NoZW1hIG9mIGEgdmVnYS1saXRlIHNwZWNpZmljYXRpb24gKi9cbnNjaGVtYS5zY2hlbWEgPSB7XG4gICRzY2hlbWE6ICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnLFxuICBkZXNjcmlwdGlvbjogJ1NjaGVtYSBmb3IgVmVnYS1saXRlIHNwZWNpZmljYXRpb24nLFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgcmVxdWlyZWQ6IFsnbWFya3R5cGUnLCAnZW5jb2RpbmcnLCAnZGF0YSddLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBtYXJrdHlwZTogc2NoZW1hLm1hcmt0eXBlLFxuICAgIGVuY29kaW5nOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbDogY29sLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmZpZzogY29uZmlnXG4gIH1cbn07XG5cbnNjaGVtYS5lbmNUeXBlcyA9IHV0aWwua2V5cyhzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jb2RpbmcucHJvcGVydGllcyk7XG5cbi8qKiBJbnN0YW50aWF0ZSBhIHZlcmJvc2Ugdmwgc3BlYyBmcm9tIHRoZSBzY2hlbWEgKi9cbnNjaGVtYS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2NoZW1hLnV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnNjaGVtYSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NoZW1hdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBpc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn07XG5cbnNjaGVtYXV0aWwuZXh0ZW5kID0gZnVuY3Rpb24oaW5zdGFuY2UsIHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hdXRpbC5tZXJnZShzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYSksIGluc3RhbmNlKTtcbn07XG5cbi8vIGluc3RhbnRpYXRlIGEgc2NoZW1hXG5zY2hlbWF1dGlsLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oc2NoZW1hKSB7XG4gIHZhciB2YWw7XG4gIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIHNjaGVtYSkge1xuICAgIHZhbCA9IHNjaGVtYS5kZWZhdWx0O1xuICAgIHJldHVybiB1dGlsLmlzT2JqZWN0KHZhbCkgPyB1dGlsLmR1cGxpY2F0ZSh2YWwpIDogdmFsO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBpbnN0YW5jZSA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIHZhbCA9IHNjaGVtYXV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluc3RhbmNlW25hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIHJlbW92ZSBhbGwgZGVmYXVsdHMgZnJvbSBhbiBpbnN0YW5jZVxuc2NoZW1hdXRpbC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBkZWZhdWx0cykge1xuICB2YXIgY2hhbmdlcyA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIGluc3RhbmNlKSB7XG4gICAgdmFyIGRlZiA9IGRlZmF1bHRzW3Byb3BdO1xuICAgIHZhciBpbnMgPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAvLyBOb3RlOiBkb2VzIG5vdCBwcm9wZXJseSBzdWJ0cmFjdCBhcnJheXNcbiAgICBpZiAoIWRlZmF1bHRzIHx8IGRlZiAhPT0gaW5zKSB7XG4gICAgICBpZiAodHlwZW9mIGlucyA9PT0gJ29iamVjdCcgJiYgIXV0aWwuaXNBcnJheShpbnMpICYmIGRlZikge1xuICAgICAgICB2YXIgYyA9IHNjaGVtYXV0aWwuc3VidHJhY3QoaW5zLCBkZWYpO1xuICAgICAgICBpZiAoIWlzRW1wdHkoYykpXG4gICAgICAgICAgY2hhbmdlc1twcm9wXSA9IGM7XG4gICAgICB9IGVsc2UgaWYgKCF1dGlsLmlzQXJyYXkoaW5zKSB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gaW5zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbnNjaGVtYXV0aWwubWVyZ2UgPSBmdW5jdGlvbigvKmRlc3QqLCBzcmMwLCBzcmMxLCAuLi4qLyl7XG4gIHZhciBkZXN0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKHZhciBpPTEgOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QgPSBtZXJnZShkZXN0LCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufTtcblxuLy8gcmVjdXJzaXZlbHkgbWVyZ2VzIHNyYyBpbnRvIGRlc3RcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ29iamVjdCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICBmb3IgKHZhciBwIGluIHNyYykge1xuICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNyY1twXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNbcF0gIT09ICdvYmplY3QnIHx8IHNyY1twXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IHNyY1twXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0W3BdICE9PSAnb2JqZWN0JyB8fCBkZXN0W3BdID09PSBudWxsKSB7XG4gICAgICBkZXN0W3BdID0gbWVyZ2Uoc3JjW3BdLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDoge30sIHNyY1twXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlKGRlc3RbcF0sIHNyY1twXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0O1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3V0aWwnKTtcblxudXRpbC5leHRlbmQodXRpbCwgcmVxdWlyZSgnZGF0YWxpYi9zcmMvZ2VuZXJhdGUnKSk7XG51dGlsLmV4dGVuZCh1dGlsLCByZXF1aXJlKCdkYXRhbGliL3NyYy9zdGF0cycpKTtcbnV0aWwuZXh0ZW5kKHV0aWwsIHJlcXVpcmUoJy4vbG9nZ2VyJykoJ1tWTCBFcnJvcl0nKSk7XG51dGlsLmJpbiA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2JpbnMvYmlucycpO1xuXG51dGlsLmlzaW4gPSBmdW5jdGlvbihpdGVtLCBhcnJheSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xuXG51dGlsLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2guY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgZi5jYWxsKHRoaXNBcmcsIG9ialtrXSwgayAsIG9iaik7XG4gICAgfVxuICB9XG59O1xuXG51dGlsLnJlZHVjZSA9IGZ1bmN0aW9uKG9iaiwgZiwgaW5pdCwgdGhpc0FyZykge1xuICBpZiAob2JqLnJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlLmNhbGwodGhpc0FyZywgZiwgaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGluaXQgPSBmLmNhbGwodGhpc0FyZywgaW5pdCwgb2JqW2tdLCBrLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxufTtcblxudXRpbC5tYXAgPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5tYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcC5jYWxsKHRoaXNBcmcsIGYpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgb3V0cHV0LnB1c2goIGYuY2FsbCh0aGlzQXJnLCBvYmpba10sIGssIG9iaikpO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5hbnkgPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgdmFyIGkgPSAwLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYgKGYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG51dGlsLmFsbCA9IGZ1bmN0aW9uKGFyciwgZikge1xuICB2YXIgaSA9IDAsIGs7XG4gIGZvciAoayBpbiBhcnIpIHtcbiAgICBpZiAoIWYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG51dGlsLmdldGJpbnMgPSBmdW5jdGlvbihzdGF0cywgbWF4Ymlucykge1xuICByZXR1cm4gdXRpbC5iaW4oe1xuICAgIG1pbjogc3RhdHMubWluLFxuICAgIG1heDogc3RhdHMubWF4LFxuICAgIG1heGJpbnM6IG1heGJpbnNcbiAgfSk7XG59O1xuXG4vKipcbiAqIHhbcFswXV0uLi5bcFtuXV0gPSB2YWxcbiAqIEBwYXJhbSBub2F1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5zZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCB2YWwsIG5vYXVnbWVudCkge1xuICBmb3IgKHZhciBpPTA7IGk8cC5sZW5ndGgtMTsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICB4W3BbaV1dID0gdmFsO1xufTtcblxuXG4vKipcbiAqIHJldHVybnMgeFtwWzBdXS4uLltwW25dXVxuICogQHBhcmFtIGF1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5nZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIW5vYXVnbWVudCAmJiAhKHBbaV0gaW4geCkpe1xuICAgICAgeCA9IHhbcFtpXV0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHhbcFtpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdmwgPSB7fTtcblxudXRpbC5leHRlbmQodmwsIGNvbnN0cywgdXRpbCk7XG5cbnZsLkVuY29kaW5nID0gcmVxdWlyZSgnLi9FbmNvZGluZycpO1xudmwuY29tcGlsZXIgPSByZXF1aXJlKCcuL2NvbXBpbGVyL2NvbXBpbGVyJyk7XG52bC5jb21waWxlID0gdmwuY29tcGlsZXIuY29tcGlsZTtcbnZsLmRhdGEgPSByZXF1aXJlKCcuL2RhdGEnKTtcbnZsLmVuYyA9IHJlcXVpcmUoJy4vZW5jJyk7XG52bC5lbmNEZWYgPSByZXF1aXJlKCcuL2VuY2RlZicpO1xudmwuc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG52bC50b1Nob3J0aGFuZCA9IHZsLkVuY29kaW5nLnNob3J0aGFuZDtcbnZsLmZvcm1hdCA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpLmZvcm1hdDtcblxubW9kdWxlLmV4cG9ydHMgPSB2bDsiXX0=\n","// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n","module.exports = require('./colorbrewer.js');\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.hasOwnProperty(format) ? rgbn(named[format])\n        : null;\n  }function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n  };\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }var ____prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.rgb = function() {\n    return this;\n  };\n\n  ____prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  ____prototype.toString = function() {\n    return _format(this.r, this.g, this.b);\n  };\n\n  function _format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var ___prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  ___prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }var __prototype = lab.prototype = Lab.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }var _prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return _format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  var interpolateCubehelix = interpolateCubehelixGamma(1);\n  var interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.interpolateCubehelix = interpolateCubehelix;\n  exports.interpolateCubehelixLong = interpolateCubehelixLong;\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"¥\", \"\"]\n  };\n\n  var ruRu = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0руб.\"]\n  };\n\n  var ptBr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  };\n\n  var plPl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"zł\"]\n  };\n\n  var nlNl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"€\\xa0\", \"\"]\n  };\n\n  var mkMk = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0ден.\"]\n  };\n\n  var jaJp = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"円\"]\n  };\n\n  var itIt = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"€\", \"\"]\n  };\n\n  var heIl = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"₪\", \"\"]\n  };\n\n  var frFr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var frCa = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  };\n\n  var fiFi = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var esEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var enUs = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var enGb = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"£\", \"\"]\n  };\n\n  var enCa = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var deDe = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n  var caEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0€\"]\n  };\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer “value” part that can be\n          // grouped, and fractional or exponential “suffix” part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"ja-JP\", jaJp)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.formatPrefix = defaultLocale.formatPrefix;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"上午\", \"下午\"],\n    days: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    shortDays: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    months: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"],\n    shortMonths: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"воскресенье\", \"понедельник\", \"вторник\", \"среда\", \"четверг\", \"пятница\", \"суббота\"],\n    shortDays: [\"вс\", \"пн\", \"вт\", \"ср\", \"чт\", \"пт\", \"сб\"],\n    months: [\"января\", \"февраля\", \"марта\", \"апреля\", \"мая\", \"июня\", \"июля\", \"августа\", \"сентября\", \"октября\", \"ноября\", \"декабря\"],\n    shortMonths: [\"янв\", \"фев\", \"мар\", \"апр\", \"май\", \"июн\", \"июл\", \"авг\", \"сен\", \"окт\", \"ноя\", \"дек\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Terça\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sábado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sáb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Março\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziałek\", \"Wtorek\", \"Środa\", \"Czwartek\", \"Piątek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"Śr.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Styczeń\", \"Luty\", \"Marzec\", \"Kwiecień\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpień\", \"Wrzesień\", \"Październik\", \"Listopad\", \"Grudzień\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Paźdz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"недела\", \"понеделник\", \"вторник\", \"среда\", \"четврток\", \"петок\", \"сабота\"],\n    shortDays: [\"нед\", \"пон\", \"вто\", \"сре\", \"чет\", \"пет\", \"саб\"],\n    months: [\"јануари\", \"февруари\", \"март\", \"април\", \"мај\", \"јуни\", \"јули\", \"август\", \"септември\", \"октомври\", \"ноември\", \"декември\"],\n    shortMonths: [\"јан\", \"фев\", \"мар\", \"апр\", \"мај\", \"јун\", \"јул\", \"авг\", \"сеп\", \"окт\", \"ное\", \"дек\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Lunedì\", \"Martedì\", \"Mercoledì\", \"Giovedì\", \"Venerdì\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e ב%B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"ראשון\", \"שני\", \"שלישי\", \"רביעי\", \"חמישי\", \"שישי\", \"שבת\"],\n    shortDays: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"],\n    months: [\"ינואר\", \"פברואר\", \"מרץ\", \"אפריל\", \"מאי\", \"יוני\", \"יולי\", \"אוגוסט\", \"ספטמבר\", \"אוקטובר\", \"נובמבר\", \"דצמבר\"],\n    shortMonths: [\"ינו׳\", \"פבר׳\", \"מרץ\", \"אפר׳\", \"מאי\", \"יוני\", \"יולי\", \"אוג׳\", \"ספט׳\", \"אוק׳\", \"נוב׳\", \"דצמ׳\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"janv.\", \"févr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"août\", \"sept.\", \"oct.\", \"nov.\", \"déc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"jan\", \"fév\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"aoû\", \"sep\", \"oct\", \"nov\", \"déc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"kesäkuu\", \"heinäkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kesä\", \"Heinä\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"miércoles\", \"jueves\", \"viernes\", \"sábado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mié\", \"jue\", \"vie\", \"sáb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"März\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"març\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"març\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.dsv = {}));\n}(this, function (exports) { 'use strict';\n\n  var dsv = function(delimiter) {\n    var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n\n    function parse(text, f) {\n      var o;\n      return parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function(\"d\", \"return {\" + row.map(function(name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n        o = f ? function(row, i) { return f(a(row), i); } : a;\n      });\n    }\n\n    function parseRows(text, f) {\n      var EOL = {}, // sentinel value for end-of-line\n          EOF = {}, // sentinel value for end-of-file\n          rows = [], // output rows\n          N = text.length,\n          I = 0, // current character index\n          n = 0, // the current line number\n          t, // the current token\n          eol; // is the current token followed by EOL?\n\n      function token() {\n        if (I >= N) return EOF; // special case: end of file\n        if (eol) return eol = false, EOL; // special case: end of line\n\n        // special case: quotes\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n        }\n\n        // common case: find next delimiter or newline\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; // \\n\n          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n          else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n\n        // special case: last token before EOF\n        return text.slice(j);\n      }\n\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n\n      return rows;\n    }\n\n    function format(rows) {\n      if (Array.isArray(rows[0])) return formatRows(rows); // deprecated; use formatRows\n      var fieldSet = Object.create(null), fields = [];\n\n      // Compute unique fields in order of discovery.\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!((field += \"\") in fieldSet)) {\n            fields.push(fieldSet[field] = field);\n          }\n        }\n      });\n\n      return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    }\n\n    function formatRows(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    }\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(text) {\n      return reFormat.test(text) ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n    }\n\n    return {\n      parse: parse,\n      parseRows: parseRows,\n      format: format,\n      formatRows: formatRows\n    };\n  }\n\n  exports.csv = dsv(\",\");\n  exports.tsv = dsv(\"\\t\");\n\n  exports.dsv = dsv;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"上午\", \"下午\"],\n    days: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    shortDays: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n    months: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"],\n    shortMonths: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"воскресенье\", \"понедельник\", \"вторник\", \"среда\", \"четверг\", \"пятница\", \"суббота\"],\n    shortDays: [\"вс\", \"пн\", \"вт\", \"ср\", \"чт\", \"пт\", \"сб\"],\n    months: [\"января\", \"февраля\", \"марта\", \"апреля\", \"мая\", \"июня\", \"июля\", \"августа\", \"сентября\", \"октября\", \"ноября\", \"декабря\"],\n    shortMonths: [\"янв\", \"фев\", \"мар\", \"апр\", \"май\", \"июн\", \"июл\", \"авг\", \"сен\", \"окт\", \"ноя\", \"дек\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Terça\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sábado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sáb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Março\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziałek\", \"Wtorek\", \"Środa\", \"Czwartek\", \"Piątek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"Śr.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Styczeń\", \"Luty\", \"Marzec\", \"Kwiecień\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpień\", \"Wrzesień\", \"Październik\", \"Listopad\", \"Grudzień\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Paźdz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y г. %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"недела\", \"понеделник\", \"вторник\", \"среда\", \"четврток\", \"петок\", \"сабота\"],\n    shortDays: [\"нед\", \"пон\", \"вто\", \"сре\", \"чет\", \"пет\", \"саб\"],\n    months: [\"јануари\", \"февруари\", \"март\", \"април\", \"мај\", \"јуни\", \"јули\", \"август\", \"септември\", \"октомври\", \"ноември\", \"декември\"],\n    shortMonths: [\"јан\", \"фев\", \"мар\", \"апр\", \"мај\", \"јун\", \"јул\", \"авг\", \"сеп\", \"окт\", \"ное\", \"дек\"]\n  };\n\n  var jaJp = {\n    dateTime: \"%Y %b %e %a %X\",\n    date: \"%Y/%m/%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"日曜日\", \"月曜日\", \"火曜日\", \"水曜日\", \"木曜日\", \"金曜日\", \"土曜日\"],\n    shortDays: [\"日\", \"月\", \"火\", \"水\", \"木\", \"金\", \"土\"],\n    months: [\"睦月\", \"如月\", \"弥生\", \"卯月\", \"皐月\", \"水無月\", \"文月\", \"葉月\", \"長月\", \"神無月\", \"霜月\", \"師走\"],\n    shortMonths: [\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Lunedì\", \"Martedì\", \"Mercoledì\", \"Giovedì\", \"Venerdì\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e ב%B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"ראשון\", \"שני\", \"שלישי\", \"רביעי\", \"חמישי\", \"שישי\", \"שבת\"],\n    shortDays: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"],\n    months: [\"ינואר\", \"פברואר\", \"מרץ\", \"אפריל\", \"מאי\", \"יוני\", \"יולי\", \"אוגוסט\", \"ספטמבר\", \"אוקטובר\", \"נובמבר\", \"דצמבר\"],\n    shortMonths: [\"ינו׳\", \"פבר׳\", \"מרץ\", \"אפר׳\", \"מאי\", \"יוני\", \"יולי\", \"אוג׳\", \"ספט׳\", \"אוק׳\", \"נוב׳\", \"דצמ׳\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"janv.\", \"févr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"août\", \"sept.\", \"oct.\", \"nov.\", \"déc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"],\n    shortMonths: [\"jan\", \"fév\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"aoû\", \"sep\", \"oct\", \"nov\", \"déc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"kesäkuu\", \"heinäkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kesä\", \"Heinä\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"miércoles\", \"jueves\", \"viernes\", \"sábado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mié\", \"jue\", \"vie\", \"sáb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"März\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"març\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"març\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"ja-JP\", jaJp)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));","var util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x, key));\n};\n\nproto._newcell = function(x, key) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x, key),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_add) this._on_add(x, cell);\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_rem) this._on_rem(x, cell);\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      // consolidate collector values\n      if (cell.collect) {\n        cell.data.values();\n      }\n      // update tuple properties\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      // add output tuple\n      result.push(cell.tuple);\n    } else {\n      delete this._cells[k];\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function(output) {\n  var changes = output || {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??\n      delete this._cells[k];\n      if (this._on_drop) this._on_drop(cell);\n    } else {\n      if (this._on_keep) this._on_keep(cell);\n      if (flag & Flags.ADD_CELL) {\n        changes.add.push(cell.tuple);\n      } else if (flag & Flags.MOD_CELL) {\n        changes.mod.push(cell.tuple);\n      }\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;","var util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m ? get(m) : +Infinity;\n};\n\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;\n","var util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n","var util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.valid > 1 ? this.dev / this.valid : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  ctr.fields = agg.map(util.$('out'));\n  return ctr;\n}\n\ntypes.create = create;\nmodule.exports = types;","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var bins = require('./bins'),\n    gen  = require('../generate'),\n    type = require('../import/type'),\n    util = require('../util'),\n    stats = require('../stats');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};","var d3_time = require('d3-time'),\n    d3_timeF = require('d3-time-format'),\n    d3_numberF = require('d3-format'),\n    numberF = d3_numberF, // defaults to EN-US\n    timeF = d3_timeF;     // defaults to EN-US\n\nfunction numberLocale(l) {\n  var f = d3_numberF.localeFormat(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  numberF = f;\n}\n\nfunction timeLocale(l) {\n  var f = d3_timeF.localeFormat(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  timeF = f;\n}\n\nmodule.exports = {\n  // Update number formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-format\n  numberLocale: numberLocale,\n  number:       function(f) { return numberF.format(f); },\n  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },\n\n  // Update time formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-time-format\n  timeLocale:   timeLocale,\n  time:         function(f) { return timeF.format(f); },  \n  utc:          function(f) { return timeF.utcFormat(f); },\n\n  // Set number and time locale simultaneously.\n  locale:       function(l) { numberLocale(l); timeLocale(l); },\n\n  // automatic formatting functions\n  auto: {\n    number:   numberAutoFormat,\n    time:     function() { return timeAutoFormat(); },\n    utc:      function() { return utcAutoFormat(); }\n  }\n};\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction intervals(domain, count) {\n  if (!domain.length) domain = [0];\n  if (count == null) count = 10;\n\n  var start = domain[0],\n      stop = domain[domain.length - 1];\n\n  if (stop < start) { error = stop; stop = start; start = error; }\n\n  var span = (stop - start) || (count = 1, start || stop || 1),\n      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),\n      error = span / count / step;\n\n  // Filter ticks to get closer to the desired count.\n  if (error >= e10) step *= 10;\n  else if (error >= e5) step *= 5;\n  else if (error >= e2) step *= 2;\n\n  // Round start and stop values to step interval.\n  return [\n    Math.ceil(start / step) * step,\n    Math.floor(stop / step) * step + step / 2, // inclusive\n    step\n  ];\n}\n\nfunction numberAutoFormat(domain, count, f) {\n  var range = intervals(domain, count);\n  if (f == null) {\n    f = ',.' + d3_numberF.precisionFixed(range[2]) + 'f';\n  } else {\n    switch (f = d3_numberF.formatSpecifier(f), f.type) {\n      case 's': {\n        var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));\n        if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);\n        return numberF.formatPrefix(f, value);\n      }\n      case '':\n      case 'e':\n      case 'g':\n      case 'p':\n      case 'r': {\n        if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');\n        break;\n      }\n      case 'f':\n      case '%': {\n        if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - (f.type === '%') * 2;\n        break;\n      }\n    }\n  }\n  return numberF.format(f);\n}\n\nfunction timeAutoFormat() {\n  var f = timeF.format,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.second(date) < d ? formatMillisecond\n        : d3_time.minute(date) < d ? formatSecond\n        : d3_time.hour(date) < d ? formatMinute\n        : d3_time.day(date) < d ? formatHour\n        : d3_time.month(date) < d ?\n          (d3_time.week(date) < d ? formatDay : formatWeek)\n        : d3_time.year(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n\nfunction utcAutoFormat() {\n  var f = timeF.utcFormat,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.utcSecond(date) < d ? formatMillisecond\n        : d3_time.utcMinute(date) < d ? formatSecond\n        : d3_time.utcHour(date) < d ? formatMinute\n        : d3_time.utcDay(date) < d ? formatHour\n        : d3_time.utcMonth(date) < d ?\n          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)\n        : d3_time.utcYear(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../../util');\nvar d3_dsv = require('d3-dsv');\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3_dsv.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;","var dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\n\nvar reader = function(data, format) {\n  var topojson = reader.topojson;\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n};\n\nreader.topojson = (typeof window !== \"undefined\" ? window['topojson'] : typeof global !== \"undefined\" ? global['topojson'] : null);\nmodule.exports = reader;","var json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}","// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (!load.useXHR && startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (load.useXHR) {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    } else {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + opt.url);\n  } else if (load.useXHR) {\n    // on client, use xhr\n    return xhr(url, callback);\n  } else if (startsWith(url, fileProtocol)) {\n    // on server, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // on server, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs on server\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  fs.readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  \n  var options = {url: url, encoding: null, gzip: true};\n  require('request')(options, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      error = error ||\n        'Load failed with response code ' + response.statusCode + '.';\n      callback(error, null);\n    }\n  });\n}\n\nfunction startsWith(string, searchString) {\n  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nload.useXHR = (typeof XMLHttpRequest !== 'undefined');\n\nmodule.exports = load;\n","var util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) { callback(error, null); return; }\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (!callback) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\n\nvar dl = {\n  version:    '1.4.6',\n  load:       require('./import/load'),\n  read:       require('./import/read'),\n  type:       require('./import/type'),\n  Aggregator: require('./aggregate/aggregator'),\n  groupby:    require('./aggregate/groupby'),\n  bins:       require('./bins/bins'),\n  $bin:       require('./bins/histogram').$bin,\n  histogram:  require('./bins/histogram').histogram,\n  format:     require('./format'),\n  print:      require('./print'),\n  template:   require('./template'),\n  time:       require('./time')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;","var util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var util = require('./util'),\n    format = require('./format');\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  /* jshint evil: true */\n  return (new Function('d', src)).bind(context);\n}\n\ntemplate.source = source;\ntemplate.context = context;\nmodule.exports = template;\n\n// Clear cache of format objects.\n// This can *break* prior template functions, so invoke with care!\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\n// Generate property access code for use within template source.\n// object: the name of the object (variable) containing template data\n// property: the property access string, verbatim from template tag\ntemplate.property = function(object, property) {\n  var src = util.field(property).map(util.str).join('][');\n  return object + '[' + src + ']';\n};\n\n// Generate source code for a template function.\n// text: the template text\n// variable: the name of the data object variable ('obj' by default)\n// properties: optional hash for collecting all accessed properties\nfunction source(text, variable, properties) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable, properties) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable, properties) {\n  var filters = text.match(filter_re);\n  var prop = filters.shift().trim();\n  var stringCast = true;\n\n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n\n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n\n  function number_format(fmt, key) {\n    a = template_format(args[0], key, fmt);\n    stringCast = false;\n    src = 'this.formats['+a+']('+src+')';\n  }\n  \n  function time_format(fmt, key) {\n    a = template_format(args[0], key, fmt);\n    stringCast = false;\n    src = 'this.formats['+a+']('+date()+')';\n  }\n\n  if (properties) properties[prop] = 1;\n  var src = template.property(variable, prop);\n\n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1)\n        .match(args_re)\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        number_format(format.number, 'number');\n        break;\n      case 'time':\n        time_format(format.time, 'time');\n        break;\n      case 'time-utc':\n        time_format(format.utc, 'time-utc');\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g,\n    filter_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^\\|\"]+|[^\\|\\']+)+/g,\n    args_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^,\"]+|[^,\\']+)+/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, key, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  key = key + ':' + pattern;\n  if (!context.format_map[key]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[key] = i;\n  }\n  return context.format_map[key];\n}\n","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n","var buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","var ts = Date.now();\n\nfunction write(msg) {\n  msg = '[Vega Log] ' + msg;\n  console.log(msg);\n}\n\nfunction error(msg) {\n  msg = '[Vega Err] ' + msg;\n  console.error(msg);\n}\n\nfunction debug(input, args) {\n  if (!debug.enable) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  var state = {\n    prevTime:  Date.now() - ts,\n    stamp: input.stamp\n  };\n\n  if (input.add) {\n    state.add = input.add.length;\n    state.mod = input.mod.length;\n    state.rem = input.rem.length;\n    state.reflow = !!input.reflow;\n  }\n\n  log.apply(console, (args.push(JSON.stringify(state)), args));\n  ts = Date.now();\n}\n\nmodule.exports = {\n  log:   write,\n  error: error,\n  debug: (debug.enable = false, debug)\n};\n","var DEPS = require('./Dependencies').ALL;\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.dirty = a ? a.dirty : [];\n  b.request = a ? a.request : null;\n  for (var d, i=0, n=DEPS.length; i<n; ++i) {\n    b[d=DEPS[i]] = a ? a[d] : {};\n  }\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy\n};","var log = require('vega-logging'),\n    Tuple = require('./Tuple'),\n    Base = require('./Node').prototype;\n\nfunction Collector(graph) {\n  Base.init.call(this, graph);\n  this._data = [];\n  this.router(true).collector(true);\n}\n\nvar prototype = (Collector.prototype = Object.create(Base));\nprototype.constructor = Collector;\n\nprototype.data = function() {\n  return this._data;\n};\n\nprototype.evaluate = function(input) {\n  log.debug(input, [\"collecting\"]);\n\n  if (input.rem.length) {\n    this._data = Tuple.idFilter(this._data, input.rem);\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  if (input.reflow) {\n    input.mod = input.mod.concat(\n      Tuple.idFilter(this._data, input.add, input.mod, input.rem));\n    input.reflow = false;\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;","var log = require('vega-logging'),\n    ChangeSet = require('./ChangeSet'), \n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Node = require('./Node'); // jshint ignore:line\n\nfunction DataSource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet  = facet;\n  this._input  = ChangeSet.create();\n  this._output = null; // Output changeset\n\n  this._inputNode  = null;\n  this._outputNode = null;\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline.\n  this._mutates = false;  // Does any pipeline operator mutate tuples?\n}\n\nvar prototype = DataSource.prototype;\n\nprototype.name = function(name) {\n  if (!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nprototype.source = function(src) {\n  if (!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nprototype.insert = function(tuples) {\n  this._input.add = this._input.add.concat(tuples.map(Tuple.ingest));\n  return this;\n};\n\nprototype.remove = function(where) {\n  var remove = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(remove);\n  return this;\n};\n\nprototype.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = Tuple.idMap(mod);\n\n  this._input.fields[field] = 1;\n\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      Tuple.set(x, field, next);\n      if (ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n\n  return this;\n};\n\nprototype.values = function(data) {\n  if (!arguments.length) return this._collector.data();\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nprototype.mutates = function(m) {\n  if (!arguments.length) return this._mutates;\n  this._mutates = this._mutates || m;\n  return this;\n};\n\nprototype.last = function() {\n  return this._output;\n};\n\nprototype.fire = function(input) {\n  if (input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nprototype.pipeline = function(pipeline) {\n  if (!arguments.length) return this._pipeline;\n\n  var graph = this._graph,\n      status;\n\n  pipeline.unshift(this._inputNode = DataSourceInput(this));\n  status = graph.preprocess(pipeline);\n\n  if (status.router) {\n    pipeline.push(status.collector = new Collector(graph));\n  }\n\n  pipeline.push(this._outputNode = DataSourceOutput(this));\n  this._collector = status.collector;\n  this._mutates = !!status.mutates;\n  graph.connect(this._pipeline = pipeline);\n\n  return this;\n};\n\nprototype.synchronize = function() {\n  this._graph.synchronize(this._pipeline);\n  return this;\n};\n\nprototype.listener = function() { \n  return DataSourceListener(this).addListener(this._inputNode);\n};\n\nprototype.addListener = function(l) {\n  if (l instanceof DataSource) {\n    this._collector.addListener(l.listener());\n  } else {\n    this._outputNode.addListener(l);      \n  }\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  this._outputNode.removeListener(l);\n};\n\nprototype.listeners = function(ds) {\n  return (ds ? this._collector : this._outputNode).listeners();\n};\n\n// Input node applies the datasource's delta, and propagates it to \n// the rest of the pipeline. It receives touches to reflow data.\nfunction DataSourceInput(ds) {\n  var input = new Node(ds._graph)\n    .router(true)\n    .collector(true);\n\n  input.data = function() {\n    return ds._data;\n  };\n\n  input.evaluate = function(input) {\n    log.debug(input, ['input', ds._name]);\n\n    var delta = ds._input, \n        out = ChangeSet.create(input), f;\n\n    // Delta might contain fields updated through API\n    for (f in delta.fields) {\n      out.fields[f] = 1;\n    }\n\n    // update data\n    if (delta.rem.length) {\n      ds._data = Tuple.idFilter(ds._data, delta.rem);\n    }\n\n    if (delta.add.length) {\n      ds._data = ds._data.concat(delta.add);\n    }\n\n    if (delta.sort) {\n      ds._data.sort(delta.sort);\n    }\n\n    // if reflowing, add any other tuples not currently in changeset\n    if (input.reflow) {\n      delta.mod = delta.mod.concat(\n        Tuple.idFilter(ds._data, delta.add, delta.mod, delta.rem));\n    }\n\n    // reset change list\n    ds._input = ChangeSet.create();\n\n    out.add = delta.add; \n    out.mod = delta.mod;\n    out.rem = delta.rem;\n    out.facet = ds._facet;\n    return out;\n  };\n\n  return input;\n}\n\n// Output node captures the last changeset seen by this datasource\n// (needed for joins and builds) and materializes any nested data.\n// If this datasource is faceted, materializes the values in the facet.\nfunction DataSourceOutput(ds) {\n  var output = new Node(ds._graph)\n    .router(true)\n    .reflows(true)\n    .collector(true);\n\n  output.data = function() {\n    return ds._collector ? ds._collector.data() : ds._data;\n  };\n\n  output.evaluate = function(input) {\n    log.debug(input, ['output', ds._name]);\n\n    var out = ChangeSet.create(input, true);\n\n    if (ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    out.data[ds._name] = 1;\n    return out;\n  };\n\n  return output;\n}\n\nfunction DataSourceListener(ds) {\n  var l = new Node(ds._graph).router(true);\n\n  l.evaluate = function(input) {\n    // Tuple derivation carries a cost. So only derive if the pipeline has\n    // operators that mutate, and thus would override the source data.\n    if (ds.mutates()) {  \n      var map = ds._srcMap || (ds._srcMap = {}), // to propagate tuples correctly\n          output = ChangeSet.create(input);\n\n      output.add = input.add.map(function(t) {\n        return (map[t._id] = Tuple.derive(t));\n      });\n\n      output.mod = input.mod.map(function(t) {\n        return Tuple.rederive(t, map[t._id]);\n      });\n\n      output.rem = input.rem.map(function(t) { \n        var o = map[t._id];\n        return (map[t._id] = null, o);\n      });\n\n      return (ds._input = output);\n    } else {\n      return (ds._input = input);\n    }\n  };\n\n  return l;\n}\n\nmodule.exports = DataSource;\n","var deps = module.exports = {\n  ALL: ['data', 'fields', 'scales', 'signals']\n};\ndeps.ALL.forEach(function(k) { deps[k.toUpperCase()] = k; });\n","var dl = require('datalib'),\n    Heap = require('./Heap'),\n    ChangeSet = require('./ChangeSet'),\n    DataSource = require('./DataSource'),\n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Signal = require('./Signal'),\n    Deps = require('./Dependencies');\n\nfunction Graph() {\n}\n\nvar prototype = Graph.prototype;\n\nprototype.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nprototype.rank = function() {\n  return ++this._rank;\n};\n\nprototype.values = function(type, names, hash) {\n  var data = (type === Deps.SIGNALS ? this._signals : this._data),\n      n = (names !== undefined ? names : dl.keys(data)),\n      vals, i;\n\n  if (Array.isArray(n)) {\n    vals = hash || {};\n    for (i=0; i<n.length; ++i) {\n      vals[n[i]] = data[n[i]].values();\n    }\n    return vals;\n  } else {\n    return data[n].values();\n  }\n};\n\n// Retain for backwards-compatibility\nprototype.dataValues = function(names) {\n  return this.values(Deps.DATA, names);\n};\n\n// Retain for backwards-compatibility\nprototype.signalValues = function(names) {\n  return this.values(Deps.SIGNALS, names);\n};\n\nprototype.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if (!arguments.length) {\n    var all = [], key;\n    for (key in db) { all.push(db[key]); }\n    return all;\n  } else if (arguments.length === 1) {\n    return db[name];\n  } else {\n    return (db[name] = new DataSource(this, name, facet).pipeline(pipeline));\n  }\n};\n\nprototype.signal = function(name, init) {\n  if (arguments.length === 1) {\n    var m = this;\n    return Array.isArray(name) ?\n      name.map(function(n) { return m._signals[n]; }) :\n      this._signals[name];\n  } else {\n    return (this._signals[name] = new Signal(this, name, init));\n  }\n};\n\nprototype.signalRef = function(ref) {\n  if (!Array.isArray(ref)) {\n    ref = dl.field(ref);\n  }\n\n  var value = this.signal(ref[0]).value();\n  if (ref.length > 1) {\n    for (var i=1, n=ref.length; i<n; ++i) {\n      value = value[ref[i]];\n    }\n  }\n  return value;\n};\n\n// Stamp should be specified with caution. It is necessary for inline datasources,\n// which need to be populated during the same cycle even though propagation has\n// passed that part of the dataflow graph.  \nprototype.propagate = function(pulse, node, stamp) {\n  var pulses = {},\n      listeners, next, nplse, tpls, ntpls, i, len;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(function(a, b) {\n    // Sort on qrank (queue-rank).\n    // Rank can change during propagation due to rewiring.\n    return a._qrank - b._qrank;\n  });\n\n  if (pulse.stamp) throw Error('Pulse already has a non-zero stamp.');\n\n  pulse.stamp = stamp || ++this._stamp;\n  pulses[node._id] = pulse;\n  pq.push(node.qrank(true));\n\n  while (pq.size() > 0) {\n    node  = pq.peek();\n    pulse = pulses[node._id];\n\n    if (node.rank() !== node.qrank()) {\n      // A node's rank might change during a propagation. Re-queue if so.\n      pq.replace(node.qrank(true));\n    } else {\n      // Evaluate node and propagate pulse.\n      pq.pop();\n      pulses[node._id] = null;\n      listeners = node._listeners;\n      pulse = this.evaluate(pulse, node);\n\n      // Propagate the pulse. \n      if (pulse !== this.doNotPropagate) {\n        // Ensure reflow pulses always send reflow pulses even if skipped.\n        if (!pulse.reflow && node.reflows()) {\n          pulse = ChangeSet.create(pulse, true);\n        }\n\n        for (i=0, len=listeners.length; i<len; ++i) {\n          next = listeners[i];\n\n          if ((nplse = pulses[next._id]) !== undefined) {\n            if (nplse === null) throw Error('Already propagated to node.');\n            if (nplse === pulse) continue;  // Re-queueing the same pulse.\n\n            // We've already queued this node. Ensure there should be at most one\n            // pulse with tuples (add/mod/rem), and the remainder will be reflows. \n            tpls  = pulse.add.length || pulse.mod.length || pulse.rem.length;\n            ntpls = nplse.add.length || nplse.mod.length || nplse.rem.length;\n\n            if (tpls && ntpls) throw Error('Multiple changeset pulses to same node');\n\n            // Combine reflow and tuples into a single pulse. \n            pulses[next._id] = tpls ? pulse : nplse;\n            pulses[next._id].reflow = pulse.reflow || nplse.reflow;\n          } else {\n            // First time we're seeing this node, queue it for propagation.\n            pq.push(next.qrank(true));\n            pulses[next._id] = pulse;\n          }\n        }\n      }\n    }\n  }\n};\n\n// Process a new branch of the dataflow graph prior to connection:\n// (1) Insert new Collector nodes as needed. \n// (2) Track + return mutation/routing status of the branch.\nprototype.preprocess = function(branch) {\n  var graph = this,\n      mutates = 0,\n      node, router, collector, collects;\n\n  for (var i=0; i<branch.length; ++i) {\n    node = branch[i];\n\n    // Batch nodes need access to a materialized dataset. \n    if (node.batch() && !node._collector) {\n      if (router || !collector) {\n        node = new Collector(graph);\n        branch.splice(i, 0, node);\n        router = false;\n      } else {\n        node._collector = collector;\n      }\n    }\n\n    if ((collects = node.collector())) collector = node;\n    router  = router  || node.router() && !collects;\n    mutates = mutates || node.mutates();\n\n    // A collector needs to be inserted after tuple-producing\n    // nodes for correct previous value tracking.\n    if (node.produces()) {\n      branch.splice(i+1, 0, new Collector(graph));\n      router = false;\n    }\n  }\n\n  return {router: router, collector: collector, mutates: mutates};\n};\n\nprototype.connect = function(branch) {\n  var collector, node, data, signals, i, n, j, m, x, y;\n\n  // connect the pipeline\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      if (!(x=this.data(y=data[j]))) {\n        throw new Error('Unknown data source ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      if (!(x=this.signal(y=signals[j]))) {\n        throw new Error('Unknown signal ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    if (i > 0) branch[i-1].addListener(node);\n  }\n\n  return branch;\n};\n\nprototype.disconnect = function(branch) {\n  var collector, node, data, signals, i, n, j, m;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      this.data(data[j]).removeListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      this.signal(signals[j]).removeListener(collector);\n    }\n\n    node.disconnect();\n  }\n\n  return branch;\n};\n\nprototype.synchronize = function(branch) {\n  var ids = {},\n      node, data, i, n, j, m, d, id;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (!node.collector()) continue;\n\n    for (j=0, data=node.data(), m=data.length; j<m; ++j) {\n      id = (d = data[j])._id;\n      if (ids[id]) continue; \n      Tuple.prev_update(d);\n      ids[id] = 1; \n    }\n  }\n\n  return this;\n};\n\nprototype.reevaluate = function(pulse, node) {\n  var reflowed = pulse.reflow && node.last() >= pulse.stamp,\n      run = node.router() || pulse.add.length || pulse.rem.length;\n\n  return run || !reflowed || node.reevaluate(pulse);\n};\n\nprototype.evaluate = function(pulse, node) {\n  if (!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse;\n};\n\nmodule.exports = Graph;\n","function Heap(comparator) {\n  this.cmp = comparator;\n  this.nodes = [];\n}\n\nvar prototype = Heap.prototype;\n\nprototype.size = function() {\n  return this.nodes.length;\n};\n\nprototype.clear = function() {\n  return (this.nodes = [], this);\n};\n\nprototype.peek = function() {\n  return this.nodes[0];\n};\n\nprototype.push = function(x) {\n  var array = this.nodes;\n  array.push(x);\n  return _siftdown(array, 0, array.length-1, this.cmp);\n};\n\nprototype.pop = function() {\n  var array = this.nodes,\n      last = array.pop(),\n      item;\n\n  if (array.length) {\n    item = array[0];\n    array[0] = last;\n    _siftup(array, 0, this.cmp);\n  } else {\n    item = last;\n  }\n  return item;\n};\n\nprototype.replace = function(item) {\n  var array = this.nodes,\n      retval = array[0];\n  array[0] = item;\n  _siftup(array, 0, this.cmp);\n  return retval;\n};\n\nprototype.pushpop = function(item) {\n  var array = this.nodes, ref = array[0];\n  if (array.length && this.cmp(ref, item) < 0) {\n    array[0] = item;\n    item = ref;\n    _siftup(array, 0, this.cmp);\n  }\n  return item;\n};\n\nfunction _siftdown(array, start, idx, cmp) {\n  var item, parent, pidx;\n\n  item = array[idx];\n  while (idx > start) {\n    pidx = (idx - 1) >> 1;\n    parent = array[pidx];\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n    break;\n  }\n  return (array[idx] = item);\n}\n\nfunction _siftup(array, idx, cmp) {\n  var start = idx,\n      end = array.length,\n      item = array[idx],\n      cidx = 2 * idx + 1, ridx;\n\n  while (cidx < end) {\n    ridx = cidx + 1;\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = 2 * idx + 1;\n  }\n  array[idx] = item;\n  return _siftdown(array, start, idx, cmp);\n}\n\nmodule.exports = Heap;\n","var DEPS = require('./Dependencies').ALL,\n    nodeID = 0;\n\nfunction Node(graph) {\n  if (graph) this.init(graph);\n}\n\nvar Flags = Node.Flags = {\n  Router:     0x01, // Responsible for propagating tuples, cannot be skipped.\n  Collector:  0x02, // Holds a materialized dataset, pulse node to reflow.\n  Produces:   0x04, // Produces new tuples. \n  Mutates:    0x08, // Sets properties of incoming tuples.\n  Reflows:    0x10, // Forwards a reflow pulse.\n  Batch:      0x20  // Performs batch data processing, needs collector.\n};\n\nvar prototype = Node.prototype;\n\nprototype.init = function(graph) {\n  this._id = ++nodeID;\n  this._graph = graph;\n  this._rank  = graph.rank(); // Topological sort by rank\n  this._qrank = null; // Rank when enqueued for propagation\n  this._stamp = 0;    // Last stamp seen\n\n  this._listeners = [];\n  this._listeners._ids = {}; // To prevent duplicate listeners\n\n  // Initialize dependencies.\n  this._deps = {};\n  for (var i=0, n=DEPS.length; i<n; ++i) {\n    this._deps[DEPS[i]] = [];\n  }\n\n  // Initialize status flags.\n  this._flags = 0;\n\n  return this;\n};\n\nprototype.rank = function() {\n  return this._rank;\n};\n\nprototype.qrank = function(/* set */) {\n  if (!arguments.length) return this._qrank;\n  return (this._qrank = this._rank, this);\n};\n\nprototype.last = function(stamp) { \n  if (!arguments.length) return this._stamp;\n  return (this._stamp = stamp, this);\n};\n\n// -- status flags ---\n\nprototype._setf = function(v, b) {\n  if (b) { this._flags |= v; } else { this._flags &= ~v; }\n  return this;\n};\n\nprototype.router = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Router);\n  return this._setf(Flags.Router, state);\n};\n\nprototype.collector = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Collector);\n  return this._setf(Flags.Collector, state);\n};\n\nprototype.produces = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Produces);\n  return this._setf(Flags.Produces, state);\n};\n\nprototype.mutates = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Mutates);\n  return this._setf(Flags.Mutates, state);\n};\n\nprototype.reflows = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Reflows);\n  return this._setf(Flags.Reflows, state);\n};\n\nprototype.batch = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Batch);\n  return this._setf(Flags.Batch, state);\n};\n\nprototype.dependency = function(type, deps) {\n  var d = this._deps[type],\n      n = d._names || (d._names = {});  // To prevent dupe deps\n\n  // Get dependencies of the given type\n  if (arguments.length === 1) {\n    return d;\n  }\n\n  if (deps === null) {\n    // Clear dependencies of the given type\n    d.splice(0, d.length);\n    d._names = {};\n  } else if (!Array.isArray(deps)) {\n    // Separate this case to avoid cost of array creation\n    if (n[deps]) return this;\n    d.push(deps);\n    n[deps] = 1;\n  } else {\n    for (var i=0, len=deps.length, dep; i<len; ++i) {\n      dep = deps[i];\n      if (n[dep]) continue;\n      d.push(dep);\n      n[dep] = 1;\n    }\n  }\n\n  return this;\n};\n\nprototype.listeners = function() {\n  return this._listeners;\n};\n\nprototype.addListener = function(l) {\n  if (!(l instanceof Node)) {\n    throw Error('Listener is not a Node');\n  }\n  if (this._listeners._ids[l._id]) return this;\n\n  this._listeners.push(l);\n  this._listeners._ids[l._id] = 1;\n  if (this._rank > l._rank) {\n    var q = [l],\n        g = this._graph, cur;\n    while (q.length) {\n      cur = q.shift();\n      cur._rank = g.rank();\n      q.unshift.apply(q, cur.listeners());\n    }\n  }\n\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  if (!this._listeners._ids[l._id]) return false;\n  \n  var idx = this._listeners.indexOf(l),\n      b = idx >= 0;\n\n  if (b) {\n    this._listeners.splice(idx, 1);\n    this._listeners._ids[l._id] = null;\n  }\n  return b;\n};\n\nprototype.disconnect = function() {\n  this._listeners = [];\n  this._listeners._ids = {};\n};\n\n// Evaluate this dataflow node for the current pulse.\n// Subclasses should override to perform custom processing.\nprototype.evaluate = function(pulse) {\n  return pulse;\n};\n\n// Should this node be re-evaluated for the current pulse?\n// Searches pulse to see if any dependencies have updated.\nprototype.reevaluate = function(pulse) {\n  var prop, dep, i, n, j, m;\n\n  for (i=0, n=DEPS.length; i<n; ++i) {\n    prop = DEPS[i];\n    dep = this._deps[prop];\n    for (j=0, m=dep.length; j<m; ++j) {\n      if (pulse[prop][dep[j]]) return true;\n    }\n  }\n\n  return false;\n};\n\nNode.reset = function() { nodeID = 0; };\n\nmodule.exports = Node;\n","var ChangeSet = require('./ChangeSet'),\n    Node = require('./Node'), // jshint ignore:line\n    Base = Node.prototype;\n\nfunction Signal(graph, name, initialValue) {\n  Base.init.call(this, graph);\n  this._name  = name;\n  this._value = initialValue;\n  this._verbose = false; // Verbose signals re-pulse the graph even if prev === val.\n  this._handlers = [];\n  return this;\n}\n\nvar prototype = (Signal.prototype = Object.create(Base));\nprototype.constructor = Signal;\n\nprototype.name = function() {\n  return this._name;\n};\n\nprototype.value = function(val) {\n  if (!arguments.length) return this._value;\n  return (this._value = val, this);\n};\n\n// Alias to value, for shared API with DataSource\nprototype.values = prototype.value;\n\nprototype.verbose = function(v) {\n  if (!arguments.length) return this._verbose;\n  return (this._verbose = !!v, this);\n};\n\nprototype.evaluate = function(input) {\n  return input.signals[this._name] ? input : this._graph.doNotPropagate;\n};\n\nprototype.fire = function(cs) {\n  if (!cs) cs = ChangeSet.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nprototype.on = function(handler) {\n  var signal = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    handler(signal.name(), signal.value());\n    return input;\n  };\n\n  this._handlers.push({\n    handler: handler,\n    node: node\n  });\n\n  return this.addListener(node);\n};\n\nprototype.off = function(handler) {\n  var h = this._handlers, i, x;\n\n  for (i=h.length; --i>=0;) {\n    if (!handler || h[i].handler === handler) {\n      x = h.splice(i, 1)[0];\n      this.removeListener(x.node);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = Signal;\n","var tupleID = 0;\n\nfunction ingest(datum) {\n  datum = (datum === Object(datum)) ? datum : {data: datum};\n  datum._id = ++tupleID;\n  if (datum._prev) datum._prev = null;\n  return datum;\n}\n\nfunction idMap(a, ids) {\n  ids = ids || {};\n  for (var i=0, n=a.length; i<n; ++i) {\n    ids[a[i]._id] = 1;\n  }\n  return ids;\n}\n\nfunction copy(t, c) {\n  c = c || {};\n  for (var k in t) {\n    if (k !== '_prev' && k !== '_id') c[k] = t[k];\n  }\n  return c;\n}\n\nmodule.exports = {\n  ingest: ingest,\n  idMap: idMap,\n\n  derive: function(d) {\n    return ingest(copy(d));\n  },\n\n  rederive: function(d, t) {\n    return copy(d, t);\n  },\n\n  set: function(t, k, v) {\n    return t[k] === v ? 0 : (t[k] = v, 1);\n  },\n\n  prev: function(t) {\n    return t._prev || t;\n  },\n\n  prev_init: function(t) {\n    if (!t._prev) { t._prev = {_id: t._id}; }\n  },\n\n  prev_update: function(t) {\n    var p = t._prev, k, v;\n    if (p) for (k in t) {\n      if (k !== '_prev' && k !== '_id') {\n        p[k] = ((v=t[k]) instanceof Object && v._prev) ? v._prev : v;\n      }\n    }\n  },\n\n  reset: function() { tupleID = 0; },\n\n  idFilter: function(data) {\n    var ids = {};\n    for (var i=arguments.length; --i>0;) {\n      idMap(arguments[i], ids);\n    }\n    return data.filter(function(x) { return !ids[x._id]; });\n  }\n};\n","module.exports = {\n  ChangeSet:    require('./ChangeSet'),\n  Collector:    require('./Collector'),\n  DataSource:   require('./DataSource'),\n  Dependencies: require('./Dependencies'),\n  Graph:        require('./Graph'),\n  Node:         require('./Node'),\n  Signal:       require('./Signal'),\n  Tuple:        require('./Tuple'),\n  debug:        require('vega-logging').debug\n};\n","function toMap(list) {\n  var map = {}, i, n;\n  for (i=0, n=list.length; i<n; ++i) map[list[i]] = 1;\n  return map;\n}\n\nfunction keys(object) {\n  var list = [], k;\n  for (k in object) list.push(k);\n  return list;\n}\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants'),\n      functions = (opt.functions || require('./functions'))(codegen),\n      idWhiteList = opt.idWhiteList ? toMap(opt.idWhiteList) : null,\n      idBlackList = opt.idBlackList ? toMap(opt.idBlackList) : null,\n      memberDepth = 0,\n      FIELD_VAR = opt.fieldVar || 'datum',\n      GLOBAL_VAR = opt.globalVar || 'signals',\n      globals = {},\n      fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      code: codegen(ast),\n      globals: keys(globals),\n      fields: keys(fields)\n    };\n    globals = {};\n    fields = {};\n    return retval;\n  }\n\n  function lookupGlobal(id) {\n    return GLOBAL_VAR + '[\"' + id + '\"]';\n  }\n\n  function codegen(ast) {\n    if (typeof ast === 'string') return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error('Unsupported type: ' + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    'Literal': function(n) {\n        return n.raw;\n      },\n    'Identifier': function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            globals[id] = 1;\n            return lookupGlobal(id);\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error('Illegal identifier: ' + id);\n        }\n        return id;\n      },\n    'Program': function(n) {\n        return n.body.map(codegen).join('\\n');\n      },\n    'MemberExpression': function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === FIELD_VAR) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? '.'+p : '['+p+']');\n      },\n    'CallExpression': function(n) {\n        if (n.callee.type !== 'Identifier') {\n          throw new Error('Illegal callee type: ' + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error('Unrecognized function: ' + callee);\n        return fn instanceof Function ?\n          fn(args) :\n          fn + '(' + args.map(codegen).join(',') + ')';\n      },\n    'ArrayExpression': function(n) {\n        return '[' + n.elements.map(codegen).join(',') + ']';\n      },\n    'BinaryExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'UnaryExpression': function(n) {\n        return '(' + n.operator + codegen(n.argument) + ')';\n      },\n    'ConditionalExpression': function(n) {\n        return '(' + codegen(n.test) +\n          '?' + codegen(n.consequent) +\n          ':' + codegen(n.alternate) +\n          ')';\n      },\n    'LogicalExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'ObjectExpression': function(n) {\n        return '{' + n.properties.map(codegen).join(',') + '}';\n      },\n    'Property': function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + ':' + codegen(n.value);\n      },\n    'ExpressionStatement': function(n) {\n        return codegen(n.expression);\n      }\n  };\n\n  codegen_wrap.functions = functions;\n  codegen_wrap.constants = constants;\n  return codegen_wrap;\n};\n","module.exports = {\n  'NaN':     'NaN',\n  'E':       'Math.E',\n  'LN2':     'Math.LN2',\n  'LN10':    'Math.LN10',\n  'LOG2E':   'Math.LOG2E',\n  'LOG10E':  'Math.LOG10E',\n  'PI':      'Math.PI',\n  'SQRT1_2': 'Math.SQRT1_2',\n  'SQRT2':   'Math.SQRT2'\n};","module.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + '(' + obj + ')';\n      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';\n    }\n    return obj + '.' + name + (type < 0 ? '' : type === 0 ?\n      '()' :\n      '(' + args.slice(1).map(codegen).join(',') + ')');\n  }\n\n  function fn(name, cast, type) {\n    return function(args) {\n      return fncall(name, args, cast, type);\n    };\n  }\n\n  var DATE = 'new Date',\n      STRING = 'String',\n      REGEXP = 'RegExp';\n\n  return {\n    // MATH functions\n    'isNaN':    'isNaN',\n    'isFinite': 'isFinite',\n    'abs':      'Math.abs',\n    'acos':     'Math.acos',\n    'asin':     'Math.asin',\n    'atan':     'Math.atan',\n    'atan2':    'Math.atan2',\n    'ceil':     'Math.ceil',\n    'cos':      'Math.cos',\n    'exp':      'Math.exp',\n    'floor':    'Math.floor',\n    'log':      'Math.log',\n    'max':      'Math.max',\n    'min':      'Math.min',\n    'pow':      'Math.pow',\n    'random':   'Math.random',\n    'round':    'Math.round',\n    'sin':      'Math.sin',\n    'sqrt':     'Math.sqrt',\n    'tan':      'Math.tan',\n\n    'clamp': function(args) {\n      if (args.length < 3)\n        throw new Error('Missing arguments to clamp function.');\n      if (args.length > 3)\n      throw new Error('Too many arguments to clamp function.');\n      var a = args.map(codegen);\n      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';\n    },\n\n    // DATE functions\n    'now':             'Date.now',\n    'datetime':        DATE,\n    'date':            fn('getDate', DATE, 0),\n    'day':             fn('getDay', DATE, 0),\n    'year':            fn('getFullYear', DATE, 0),\n    'month':           fn('getMonth', DATE, 0),\n    'hours':           fn('getHours', DATE, 0),\n    'minutes':         fn('getMinutes', DATE, 0),\n    'seconds':         fn('getSeconds', DATE, 0),\n    'milliseconds':    fn('getMilliseconds', DATE, 0),\n    'time':            fn('getTime', DATE, 0),\n    'timezoneoffset':  fn('getTimezoneOffset', DATE, 0),\n    'utcdate':         fn('getUTCDate', DATE, 0),\n    'utcday':          fn('getUTCDay', DATE, 0),\n    'utcyear':         fn('getUTCFullYear', DATE, 0),\n    'utcmonth':        fn('getUTCMonth', DATE, 0),\n    'utchours':        fn('getUTCHours', DATE, 0),\n    'utcminutes':      fn('getUTCMinutes', DATE, 0),\n    'utcseconds':      fn('getUTCSeconds', DATE, 0),\n    'utcmilliseconds': fn('getUTCMilliseconds', DATE, 0),\n\n    // shared sequence functions\n    'length':      fn('length', null, -1),\n    'indexof':     fn('indexOf', null),\n    'lastindexof': fn('lastIndexOf', null),\n\n    // STRING functions\n    'parseFloat':  'parseFloat',\n    'parseInt':    'parseInt',\n    'upper':       fn('toUpperCase', STRING, 0),\n    'lower':       fn('toLowerCase', STRING, 0),\n    'slice':       fn('slice', STRING),\n    'substring':   fn('substring', STRING),\n\n    // REGEXP functions\n    'regexp':  REGEXP,\n    'test':    fn('test', REGEXP),\n\n    // Control Flow functions\n    'if': function(args) {\n        if (args.length < 3)\n          throw new Error('Missing arguments to if function.');\n        if (args.length > 3)\n        throw new Error('Too many arguments to if function.');\n        var a = args.map(codegen);\n        return a[0]+'?'+a[1]+':'+a[2];\n      }\n  };\n};","var parser = require('./parser'),\n    codegen = require('./codegen');\n    \nvar expr = module.exports = {\n  parse: function(input, opt) {\n      return parser.parse('('+input+')', opt);\n    },\n  code: function(opt) {\n      return codegen(opt);\n    },\n  compiler: function(args, opt) {\n      args = args.slice();\n      var generator = codegen(opt),\n          len = args.length,\n          compile = function(str) {\n            var value = generator(expr.parse(str));\n            args[len] = '\"use strict\"; return (' + value.code + ');';\n            value.fn = Function.apply(null, args);\n            return value;\n          };\n      compile.codegen = generator;\n      return compile;\n    },\n  functions: require('./functions'),\n  constants: require('./constants')\n};\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* istanbul ignore next */\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();","var expr = require('vega-expression'),\n    args = ['datum', 'event', 'signals'];\n\nmodule.exports = expr.compiler(args, {\n  idWhiteList: args,\n  fieldVar:    args[0],\n  globalVar:   args[2],\n  functions:   function(codegen) {\n    var fn = expr.functions(codegen);\n    fn.eventItem = function() { return 'event.vg.item'; };\n    fn.eventGroup = 'event.vg.getGroup';\n    fn.eventX = 'event.vg.getX';\n    fn.eventY = 'event.vg.getY';\n    fn.open = 'window.open';\n    return fn;\n  }\n});","var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    log = require('vega-logging'),\n    ChangeSet = df.ChangeSet,\n    Tuple = df.Tuple,\n    Deps = df.Dependencies,\n    Transform = require('./Transform'),\n    Facetor = require('./Facetor');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph);\n\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    summarize: {\n      type: 'custom', \n      set: function(summarize) {\n        var signalDeps = {},\n            tx = this._transform,\n            i, len, f, fields, name, ops;\n\n        if (!dl.isArray(fields = summarize)) { // Object syntax from dl\n          fields = [];\n          for (name in summarize) {\n            ops = dl.array(summarize[name]);\n            fields.push({field: name, ops: ops});\n          }\n        }\n\n        function sg(x) { if (x.signal) signalDeps[x.signal] = 1; }\n\n        for (i=0, len=fields.length; i<len; ++i) {\n          f = fields[i];\n          if (f.field.signal) { signalDeps[f.field.signal] = 1; }\n          dl.array(f.ops).forEach(sg);\n          dl.array(f.as).forEach(sg);\n        }\n\n        tx._fields = fields;\n        tx._aggr = null;\n        tx.dependency(Deps.SIGNALS, dl.keys(signalDeps));\n        return tx;\n      }\n    }\n  });\n\n  this._aggr  = null; // dl.Aggregator\n  this._input = null; // Used by Facetor._on_keep.\n  this._args  = null; // To cull re-computation.\n  this._fields = [];\n  this._out = [];\n\n  this._type = TYPES.TUPLE; \n  this._acc = {groupby: dl.true, value: dl.true};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Aggregate.prototype = Object.create(Transform.prototype));\nprototype.constructor = Aggregate;\n\nvar TYPES = Aggregate.TYPES = {\n  VALUE: 1, \n  TUPLE: 2, \n  MULTI: 3\n};\n\nAggregate.VALID_OPS = [\n  'values', 'count', 'valid', 'missing', 'distinct', \n  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev', \n  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max', \n  'argmin', 'argmax'\n];\n\nprototype.type = function(type) { \n  return (this._type = type, this); \n};\n\nprototype.accessors = function(groupby, value) {\n  var acc = this._acc;\n  acc.groupby = dl.$(groupby) || dl.true;\n  acc.value = dl.$(value) || dl.true;\n};\n\nprototype.aggr = function() {\n  if (this._aggr) return this._aggr;\n\n  var g = this._graph,\n      hasGetter = false,\n      args = [],\n      groupby = this.param('groupby').field,\n      value = function(x) { return x.signal ? g.signalRef(x.signal) : x; };\n\n  // Prepare summarize fields.\n  var fields = this._fields.map(function(f) {\n    var field = {\n      name: value(f.field),\n      as:   dl.array(f.as),\n      ops:  dl.array(value(f.ops)).map(value),\n      get:  f.get\n    };\n    hasGetter = hasGetter || field.get != null;\n    args.push(field.name);\n    return field;\n  });\n\n  // If there is an arbitrary getter, all bets are off.\n  // Otherwise, we can check argument fields to cull re-computation.\n  groupby.forEach(function(g) {\n    if (g.get) hasGetter = true;\n    args.push(g.name || g);\n  });\n  this._args = hasGetter || !fields.length ? null : args;\n\n  if (!fields.length) fields = {'*': 'values'};\n\n  // Instatiate our aggregator instance.\n  // Facetor is a special subclass that can facet into data pipelines.\n  var aggr = this._aggr = new Facetor()\n    .groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  // Collect output fields sets by this aggregate.\n  this._out = getFields(aggr);\n\n  // If we are processing tuples, key them by '_id'.\n  if (this._type !== TYPES.VALUE) { aggr.key('_id'); }\n\n  return aggr;\n};\n\nfunction getFields(aggr) {\n  // Collect the output fields set by this aggregate.\n  var f = [], i, n, j, m, dims, vals, meas;\n\n  dims = aggr._dims;\n  for (i=0, n=dims.length; i<n; ++i) {\n    f.push(dims[i].name);\n  }\n\n  vals = aggr._aggr;\n  for (i=0, n=vals.length; i<n; ++i) {\n    meas = vals[i].measures.fields;\n    for (j=0, m=meas.length; j<m; ++j) {\n      f.push(meas[j]);\n    }\n  }\n\n  return f;\n}\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['aggregate']);\n\n  var output = ChangeSet.create(input),\n      aggr = this.aggr(),\n      out = this._out,\n      args = this._args,\n      reeval = true,\n      p = Tuple.prev,\n      add, rem, mod, i;\n\n  // Upon reset, retract prior tuples and re-initialize.\n  if (reset) {\n    output.rem.push.apply(output.rem, aggr.result());\n    aggr.clear();\n    this._aggr = null;\n    aggr = this.aggr();\n  }\n\n  // Get update methods according to input type.\n  if (this._type === TYPES.TUPLE) {\n    add = function(x) { aggr._add(x); Tuple.prev_init(x); };\n    rem = function(x) { aggr._rem(p(x)); };\n    mod = function(x) { aggr._mod(x, p(x)); };\n  } else {\n    var gby = this._acc.groupby,\n        val = this._acc.value,\n        get = this._type === TYPES.VALUE ? val : function(x) {\n          return { _id: x._id, groupby: gby(x), value: val(x) };\n        };\n    add = function(x) { aggr._add(get(x)); Tuple.prev_init(x); };\n    rem = function(x) { aggr._rem(get(p(x))); };\n    mod = function(x) { aggr._mod(get(x), get(p(x))); };\n  }\n\n  input.add.forEach(add);\n  if (reset) {\n    // A signal change triggered reflow. Add everything.\n    // No need for rem, we cleared the aggregator.\n    input.mod.forEach(add);\n  } else {\n    input.rem.forEach(rem);\n\n    // If possible, check argument fields to see if we need to re-process mods.\n    if (args) for (i=0, reeval=false; i<args.length; ++i) {\n      if (input.fields[args[i]]) { reeval = true; break; }\n    }\n    if (reeval) input.mod.forEach(mod);\n  }\n\n  // Indicate output fields and return aggregate tuples.\n  for (i=0; i<out.length; ++i) {\n    output.fields[out[i]] = 1;\n  }\n  return (aggr._input = input, aggr.changes(output));\n};\n\nmodule.exports = Aggregate;","var dl = require('datalib'),\n    Aggregator = dl.Aggregator,\n    Base = Aggregator.prototype,\n    df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    facetID = 0;\n\nfunction Facetor() {\n  Aggregator.call(this);\n  this._facet = null;\n  this._facetID = ++facetID;\n}\n\nvar prototype = (Facetor.prototype = Object.create(Base));\nprototype.constructor = Facetor;\n\nprototype.facet = function(f) {\n  return arguments.length ? (this._facet = f, this) : this._facet;\n};\n\nprototype._ingest = function(t) { \n  return Tuple.ingest(t, null);\n};\n\nprototype._assign = Tuple.set;\n\nfunction disconnect_cell(facet) {\n  log.debug({}, ['disconnecting cell', this.tuple._id]);\n  var pipeline = this.ds.pipeline();\n  facet.removeListener(pipeline[0]);\n  facet._graph.removeListener(pipeline[0]);\n  facet._graph.disconnect(pipeline);\n}\n\nprototype._newcell = function(x, key) {\n  var cell  = Base._newcell.call(this, x, key),\n      facet = this._facet;\n\n  if (facet) {\n    var graph = facet._graph,\n        tuple = cell.tuple,\n        pipeline = facet.param('transform');\n    cell.ds = graph.data(tuple._facetID, pipeline, tuple);\n    cell.disconnect = disconnect_cell;\n    facet.addListener(pipeline[0]);\n  }\n\n  return cell;\n};\n\nprototype._newtuple = function(x, key) {\n  var t = Base._newtuple.call(this, x);\n  if (this._facet) {\n    Tuple.set(t, 'key', key);\n    Tuple.set(t, '_facetID', this._facetID + '_' + key);\n  }\n  return t;\n};\n\nprototype.clear = function() {\n  if (this._facet) {\n    for (var k in this._cells) {\n      this._cells[k].disconnect(this._facet);\n    }\n  }\n  return Base.clear.call(this);\n};\n\nprototype._on_add = function(x, cell) {\n  if (this._facet) cell.ds._input.add.push(x);\n};\n\nprototype._on_rem = function(x, cell) {\n  if (this._facet) cell.ds._input.rem.push(x);\n};\n\nprototype._on_mod = function(x, prev, cell0, cell1) {\n  if (this._facet) { // Propagate tuples\n    if (cell0 === cell1) {\n      cell0.ds._input.mod.push(x);\n    } else {\n      cell0.ds._input.rem.push(x);\n      cell1.ds._input.add.push(x);\n    }\n  }\n};\n\nprototype._on_drop = function(cell) {\n  if (this._facet) cell.disconnect(this._facet);\n};\n\nprototype._on_keep = function(cell) {\n  // propagate sort, signals, fields, etc.\n  if (this._facet) df.ChangeSet.copy(this._input, cell.ds._input);\n};\n\nmodule.exports = Facetor;","var dl = require('datalib'),\n    Deps = require('vega-dataflow').Dependencies,\n    expr = require('../parse/expr');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i,\n    valType   = /value/i;\n\nfunction Parameter(name, type, transform) {\n  this._name = name;\n  this._type = type;\n  this._transform = transform;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar prototype = Parameter.prototype;\n\nfunction get() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  var val = isArray ? this._value : this._value[0],\n      acc = isArray ? this._accessors : this._accessors[0];\n\n  if (!dl.isValid(acc) && valType.test(this._type)) {\n    return val;\n  } else {\n    return isData ? { name: val, source: acc } :\n    isField ? { field: val, accessor: acc } : val;\n  }\n}\n\nprototype.get = function() {\n  var graph = this._transform._graph, \n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return get.call(this);\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return get.call(this); // TODO: support signal as dataTypes\n  }\n\n  for (s in this._signals) {\n    idx = this._signals[s];\n    val = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return get.call(this);\n};\n\nprototype.set = function(value) {\n  var p = this,\n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        p._transform.dependency(Deps.FIELDS,  e.fields);\n        p._transform.dependency(Deps.SIGNALS, e.globals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        p._accessors[i] = dl.accessor(v);\n        p._transform.dependency(Deps.FIELDS, dl.field(v));\n      } else if (isData) {\n        p._resolution = true;\n        p._transform.dependency(Deps.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      p._accessors[i] = dl.accessor(v.field);\n      p._transform.dependency(Deps.FIELDS, dl.field(v.field));\n      return v.field;\n    } else if (v.signal !== undefined) {\n      p._resolution = true;\n      p._signals[v.signal] = i;\n      p._transform.dependency(Deps.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return p._transform;\n};\n\nmodule.exports = Parameter;","var df = require('vega-dataflow'),\n    Base = df.Node.prototype, // jshint ignore:line\n    Deps = df.Dependencies,\n    Parameter = require('./Parameter');\n\nfunction Transform(graph) {\n  if (graph) Base.init.call(this, graph);\n}\n\nTransform.addParameters = function(proto, params) {\n  proto._parameters = proto._parameters || {};\n  for (var name in params) {\n    var p = params[name],\n        param = new Parameter(name, p.type, proto);\n\n    proto._parameters[name] = param;\n\n    if (p.type === 'custom') {\n      if (p.set) param.set = p.set.bind(param);\n      if (p.get) param.get = p.get.bind(param);\n    }\n\n    if (p.hasOwnProperty('default')) param.set(p.default);\n  }\n};\n\nvar prototype = (Transform.prototype = Object.create(Base));\nprototype.constructor = Transform;\n\nprototype.param = function(name, value) {\n  var param = this._parameters[name];\n  return (param === undefined) ? this :\n    (arguments.length === 1) ? param.get() : param.set(value);\n};\n\n// Perform transformation. Subclasses should override.\nprototype.transform = function(input/*, reset */) {\n  return input;\n};\n\nprototype.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp &&\n    this.dependency(Deps.SIGNALS).reduce(function(c, s) {\n      return c += input.signals[s] ? 1 : 0;\n    }, 0);\n  return this.transform(input, reset);\n};\n\nprototype.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;","'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlEncDef = require('./encdef'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.encDef = function(et) {\n    return this._enc[et];\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    return vlEncDef.fieldRef(this._enc[et], opt);\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlEncDef.isCount(this._enc[et])) {\n      return vlEncDef.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.encDef(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlEncDef.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var encDef = this.encDef(et);\n    return encDef && vlEncDef.isType(encDef, type);\n  };\n\n\n  proto.isTypes = function(et, type) {\n    var encDef = this.encDef(et);\n    return encDef && vlEncDef.isTypes(encDef, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlEncDef.isOrdinalScale(encoding.encDef(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlEncDef.isDimension(encoding.encDef(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlEncDef.isMeasure(encoding.encDef(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  proto.dataTable = function() {\n    return this.isAggregate() ? AGGREGATE : RAW;\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  /**\n   * Check if the encoding should be stacked and return the stack dimenstion and value fields.\n   * @return {Object} An object containing two properties:\n   * - dimension - the dimension field\n   * - value - the value field\n   */\n  proto.stack = function() {\n    var stack = (this.has(COLOR) && this.encDef(COLOR).stack) ? COLOR :\n          (this.has(DETAIL) && this.encDef(DETAIL).stack) ? DETAIL :\n          null;\n\n    var properties = stack && this.encDef(stack).stack !== true ?\n                       this.encDef(stack).stack :\n                       {};\n\n    if ((this.is('bar') || this.is('area')) && stack && this.isAggregate()) {\n\n      var isXMeasure = this.isMeasure(X);\n      var isYMeasure = this.isMeasure(Y);\n\n      if (isXMeasure && !isYMeasure) {\n        return {\n          groupby: Y,\n          value: X,\n          stack: stack,\n          properties: properties\n        };\n      } else if (isYMeasure && !isXMeasure) {\n        return {\n          groupby: X,\n          value: Y,\n          stack: stack,\n          properties: properties\n        };\n      }\n    }\n    return null; // no stack encoding\n  };\n\n\n\n  proto.details = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType !== X && encType !== Y)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.facets = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType == ROW || encType == COL)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlEncDef.cardinality(this.encDef(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function() {\n    return this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data().values;\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  // TODO: rename def to axisDef and avoid side effects where possible.\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.encDef(name).axis.layer\n  };\n\n  var orient = axis.orient(encoding, name, stats);\n  if (orient) {\n    def.orient = orient;\n  }\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, encoding, name, stats);\n  def = axis.labels.angle(def, encoding, name);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if ((encoding.isDimension(X) || encoding.isType(X, T)) &&\n        !('angle' in getter(def, ['properties', 'labels']))) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.encDef(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, encoding, name, layout);\n  def = axis.title(def, encoding, name, layout, opt);\n\n  if (isRow || isCol) {\n    def = axis.hideTicks(def);\n  }\n\n  return def;\n};\n\naxis.orient = function(encoding, name, stats) {\n  var orient = encoding.encDef(name).axis.orient;\n  if (orient) {\n    return orient;\n  } else if (name === COL) {\n    return 'top';\n  } else if (name === X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    // x-axis for long y - put on top\n    return 'top';\n  }\n  return undefined;\n};\n\naxis.grid = function(def, encoding, name, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  var _grid = encoding.axis(name).grid;\n\n  // If `grid` is unspecified, the default value is `true` for ROW and COL. For X\n  // and Y, the default value is `true` for quantitative and time fields and `false` otherwise.\n  var grid = _grid === undefined ?\n    (name === ROW || name === COL || encoding.isTypes(name, [Q, T])) :\n    _grid;\n\n  if (grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      var yOffset = encoding.config('cellGridOffset');\n\n      // TODO(#677): this should depend on orient\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col',\n          field: 'data'\n        },\n        y: {\n          value: -yOffset,\n        },\n        y2: {\n          field: {group: 'mark.group.height'},\n          offset: yOffset\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        strokeOpacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      var xOffset = encoding.config('cellGridOffset');\n\n      // TODO(#677): this should depend on orient\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row',\n          field: 'data'\n        },\n        x: {\n          value: def.offset - xOffset\n        },\n        x2: {\n          field: {group: 'mark.group.width'},\n          offset: def.offset + xOffset,\n          // default value(s) -- vega doesn't do recursive merge\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        strokeOpacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        strokeOpacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, encoding, name, layout) {\n  var ax = encoding.encDef(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.encDef(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, encoding, name, stats) {\n  var fieldStats = stats[encoding.encDef(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.encDef(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{ datum.data | truncate:' +\n      encoding.axis(name).maxLabelLength + '}}'\n    );\n  }\n\n  return def;\n};\n\naxis.labels.angle = function(def, encoding, name) {\n  var angle = encoding.axis(name).labelAngle;\n  if (typeof angle === 'undefined') return def;\n\n  setter(def, ['properties', 'labels', 'angle', 'value'], angle);\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n","'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\n/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.data = require('./data');\ncompiler.facet = require('./facet');\ncompiler.layout = require('./layout');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\n/**\n * Create a Vega specification from a Vega-lite Encoding object.\n */\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats) {\n    if (encoding.hasValues()) {\n        stats = summary(encoding.data().values).reduce(function(s, p) {\n        s[p.field] = p;\n        return s;\n      }, {});\n    } else {\n      console.error('No stats provided and data is not embedded.');\n    }\n  }\n\n  var layout = compiler.layout(encoding, stats);\n\n  var spec = {\n      width: layout.width,\n      height: layout.height,\n      padding: 'auto',\n      data: compiler.data(encoding),\n      // global scales contains only time unit scales\n      scales: compiler.time.scales(encoding),\n      marks: [{\n        name: 'cell',\n        type: 'group',\n        properties: {\n          enter: {\n            width: layout.cellWidth ?\n                     {value: layout.cellWidth} :\n                     {field: {group: 'width'}},\n            height: layout.cellHeight ?\n                    {value: layout.cellHeight} :\n                    {field: {group: 'height'}}\n          }\n        }\n      }]\n    };\n\n  var group = spec.marks[0];\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    mdefs = group.marks = marks.def(encoding, layout, style, stats),\n    mdef = mdefs[mdefs.length - 1];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  var stack = encoding.stack();\n  if (stack) {\n    // modify mdef.{from,properties}\n    compiler.stack(encoding, mdef, stack);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n  var details = encoding.details();\n\n  if (details.length > 0 && lineType) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, encoding);\n  }\n\n  // auto-sort line/area values\n  if (lineType && encoding.config('autoSortLine')) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) {\n      mdef.from = {};\n    }\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // get a flattened list of all scale names that are used in the vl spec\n  var singleScaleNames = [].concat.apply([], mdefs.map(function(markProps) {\n    return scale.names(markProps.properties.update);\n  }));\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, spec, singleScaleNames, stats);\n    spec.legends = legend.defs(encoding, style);\n  } else {\n    group.scales = scale.defs(singleScaleNames, encoding, layout, stats);\n    group.axes = [];\n    if (encoding.has(X)) {\n      group.axes.push(axis.def(X, encoding, layout, stats));\n    }\n    if (encoding.has(Y)) {\n      group.axes.push(axis.def(Y, encoding, layout, stats));\n    }\n\n    group.legends = legend.defs(encoding, style);\n  }\n\n  return spec;\n};\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = data;\n\nvar vlEncDef = require('../encdef'),\n  util = require('../util'),\n  time = require('./time');\n\n/**\n * Create Vega's data array from a given encoding.\n *\n * @param  {Encoding} encoding\n * @return {Array} Array of Vega data.\n *                 This always includes a \"raw\" data table.\n *                 If the encoding contains aggregate value, this will also create\n *                 aggregate table as well.\n */\nfunction data(encoding) {\n  var def = [data.raw(encoding)];\n\n  var aggregate = data.aggregate(encoding);\n  if (aggregate) {\n    def.push(data.aggregate(encoding));\n  }\n\n  // TODO add \"having\" filter here\n\n  // append non-positive filter at the end for the data table\n  data.filterNonPositive(def[def.length - 1], encoding);\n\n  // Stack\n  var stack = encoding.stack();\n  if (stack) {\n    def.push(data.stack(encoding, stack));\n  }\n\n  return def;\n}\n\ndata.raw = function(encoding) {\n  var raw = {name: RAW};\n\n  // Data source (url or inline)\n  if (encoding.hasValues()) {\n    raw.values = encoding.data().values;\n    raw.format = {type: 'json'};\n  } else {\n    raw.url = encoding.data().url;\n    raw.format = {type: encoding.data().formatType};\n  }\n\n  // Set data's format.parse if needed\n  var parse = data.raw.formatParse(encoding);\n  if (parse) {\n    raw.format.parse = parse;\n  }\n\n  raw.transform = data.raw.transform(encoding);\n  return raw;\n};\n\ndata.raw.formatParse = function(encoding) {\n  var parse;\n\n  encoding.forEach(function(encDef) {\n    if (encDef.type == T) {\n      parse = parse || {};\n      parse[encDef.name] = 'date';\n    } else if (encDef.type == Q) {\n      if (vlEncDef.isCount(encDef)) return;\n      parse = parse || {};\n      parse[encDef.name] = 'number';\n    }\n  });\n\n  return parse;\n};\n\n/**\n * Generate Vega transforms for the raw data table.  This can include\n * transforms for time unit, binning and filtering.\n */\ndata.raw.transform = function(encoding) {\n  // null filter comes first so transforms are not performed on null values\n  // time and bin should come before filter so we can filter by time and bin\n  return data.raw.transform.nullFilter(encoding).concat(\n    data.raw.transform.formula(encoding),\n    data.raw.transform.time(encoding),\n    data.raw.transform.bin(encoding),\n    data.raw.transform.filter(encoding)\n  );\n};\n\ndata.raw.transform.time = function(encoding) {\n  return encoding.reduce(function(transform, encDef, encType) {\n    if (encDef.type === T && encDef.timeUnit) {\n      var fieldRef = encoding.fieldRef(encType, {nofn: true, datum: true});\n\n      transform.push({\n        type: 'formula',\n        field: encoding.fieldRef(encType),\n        expr: time.formula(encDef.timeUnit, fieldRef)\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.bin = function(encoding) {\n  return encoding.reduce(function(transform, encDef, encType) {\n    if (encoding.bin(encType)) {\n      transform.push({\n        type: 'bin',\n        field: encDef.name,\n        output: {start: encoding.fieldRef(encType)},\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n    return transform;\n  }, []);\n};\n\n/**\n * @return {Array} An array that might contain a filter transform for filtering null value based on filterNul config\n */\ndata.raw.transform.nullFilter = function(encoding) {\n  var filteredFields = util.reduce(encoding.fields(),\n    function(filteredFields, fieldList, fieldName) {\n      if (fieldName === '*') return filteredFields; //count\n\n      // TODO(#597) revise how filterNull is structured.\n      if ((encoding.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (encoding.config('filterNull').T && fieldList.containsType[T]) ||\n          (encoding.config('filterNull').O && fieldList.containsType[O]) ||\n          (encoding.config('filterNull').N && fieldList.containsType[N])) {\n        filteredFields.push(fieldName);\n      }\n      return filteredFields;\n    }, []);\n\n  return filteredFields.length > 0 ?\n    [{\n      type: 'filter',\n      test: filteredFields.map(function(fieldName) {\n        return 'datum.' + fieldName + '!==null';\n      }).join(' && ')\n    }] : [];\n};\n\ndata.raw.transform.filter = function(encoding) {\n  var filter = encoding.data().filter;\n  return filter ? [{\n      type: 'filter',\n      test: filter\n  }] : [];\n};\n\ndata.raw.transform.formula = function(encoding) {\n  var formulas = encoding.data().formulas;\n  if (formulas === undefined) {\n    return [];\n  }\n\n  return formulas.reduce(function(transform, formula) {\n    formula.type = 'formula';\n    transform.push(formula);\n    return transform;\n  }, []);\n};\n\ndata.aggregate = function(encoding) {\n  /* dict set for dimensions */\n  var dims = {};\n\n  /* dictionary mapping field name => dict set of aggregation functions */\n  var meas = {};\n\n  var hasAggregate = false;\n\n  encoding.forEach(function(encDef, encType) {\n    if (encDef.aggregate) {\n      hasAggregate = true;\n      if (encDef.aggregate === 'count') {\n        meas['*'] = meas['*'] || {};\n        meas['*'].count = true;\n      } else {\n        meas[encDef.name] = meas[encDef.name] || {};\n        meas[encDef.name][encDef.aggregate] = true;\n      }\n    } else {\n      dims[encDef.name] = encoding.fieldRef(encType);\n    }\n  });\n\n  var groupby = util.vals(dims);\n\n  // short-format summarize object for Vega's aggregate transform\n  // https://github.com/vega/vega/wiki/Data-Transforms#-aggregate\n  var summarize = util.reduce(meas, function(summarize, fnDictSet, field) {\n    summarize[field] = util.keys(fnDictSet);\n    return summarize;\n  }, {});\n\n  if (hasAggregate) {\n    return {\n      name: AGGREGATE,\n      source: RAW,\n      transform: [{\n        type: 'aggregate',\n        groupby: groupby,\n        summarize: summarize\n      }]\n    };\n  }\n\n  return null;\n};\n\n/**\n * Add stacked data source, for feeding the shared scale.\n */\ndata.stack = function(encoding, stack) {\n  var dim = stack.groupby;\n  var val = stack.value;\n  var facets = encoding.facets();\n\n  var stacked = {\n    name: STACKED,\n    source: encoding.dataTable(),\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      summarize: [{ops: ['sum'], field: encoding.fieldRef(val)}]\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      summarize: [{\n        ops: ['max'],\n        // we want max of sum from above transform\n        field: encoding.fieldRef(val, {prefn: 'sum_'})\n      }]\n    });\n  }\n  return stacked;\n};\n\ndata.filterNonPositive = function(dataTable, encoding) {\n  encoding.forEach(function(encDef, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: encoding.fieldRef(encType, {datum: 1}) + ' > 0'\n      });\n    }\n  });\n};\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  var group = {\n    name: name || undefined,\n    type: 'group',\n    properties: {\n      enter: {\n        width: opt.width || {field: {group: 'width'}},\n        height: opt.height || {field: {group: 'height'}}\n      }\n    }\n  };\n\n  if (opt.from) {\n    group.from = opt.from;\n  }\n  if (opt.x) {\n    group.properties.enter.x = opt.x;\n  }\n  if (opt.y) {\n    group.properties.enter.y = opt.y;\n  }\n  if (opt.axes) {\n    group.axes = opt.axes;\n  }\n\n  return group;\n}\n\nfunction faceting(group, encoding, layout, spec, singleScaleNames, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: encoding.fieldRef(ROW)};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', groupby: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? [axis.def(X, encoding, layout, stats)] : undefined,\n        x: hasCol ? {scale: COL, field: encoding.fieldRef(COL)} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(ROW, encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push(axis.def(X, encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: encoding.fieldRef(COL)};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', groupby: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? [axis.def(Y, encoding, layout, stats)] : undefined,\n      y: hasRow && {scale: ROW, field: encoding.fieldRef(ROW)},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(COL, encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push(axis.def(Y, encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(singleScaleNames),\n    encoding,\n    layout,\n    stats,\n    true\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', groupby: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.encDef(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.encDef(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.encDef(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.encDef(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\n// TODO(#600) revise this\nfunction getMaxLength(encoding, stats, et) {\n  var encDef = encoding.encDef(et),\n    fieldStats = stats[encDef.name];\n\n  if (encDef.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.encDef(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.encDef(et).aggregate === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar time = require('./time'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter;\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding, style) {\n  var defs = [];\n\n  if (encoding.has(COLOR) && encoding.encDef(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR\n    }, style));\n  }\n\n  if (encoding.has(SIZE) && encoding.encDef(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE\n    }, style));\n  }\n\n  if (encoding.has(SHAPE) && encoding.encDef(SHAPE).legend) {\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE\n    }, style));\n  }\n  return defs;\n};\n\nlegend.def = function(name, encoding, def, style) {\n  var timeUnit = encoding.encDef(name).timeUnit;\n\n  def.title = legend.title(name, encoding);\n  def.orient = encoding.encDef(name).legend.orient;\n\n  def = legend.style(name, encoding, def, style);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    setter(def, ['properties', 'labels', 'text', 'scale'], 'time-'+ timeUnit);\n  }\n\n  return def;\n};\n\nlegend.style = function(name, e, def, style) {\n  var symbols = getter(def, ['properties', 'symbols']),\n    marktype = e.marktype();\n\n  switch (marktype) {\n    case 'bar':\n    case 'tick':\n    case 'text':\n      symbols.stroke = {value: 'transparent'};\n      symbols.shape = {value: 'square'};\n      break;\n\n    case 'circle':\n    case 'square':\n      symbols.shape = {value: marktype};\n      /* fall through */\n    case 'point':\n      // fill or stroke\n      if (e.encDef(SHAPE).filled) {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.fill = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.fill = {value: e.value(COLOR)};\n        }\n        symbols.stroke = {value: 'transparent'};\n      } else {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.stroke = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.stroke = {value: e.value(COLOR)};\n        }\n        symbols.fill = {value: 'transparent'};\n        symbols.strokeWidth = {value: e.config('strokeWidth')};\n      }\n\n      break;\n    case 'line':\n    case 'area':\n      // TODO use shape here after implementing #508\n      break;\n  }\n\n  var opacity = e.encDef(COLOR).opacity || style.opacity;\n  if (opacity) {\n    symbols.opacity = {value: opacity};\n  }\n  return def;\n};\n\nlegend.title = function(name, encoding) {\n  var leg = encoding.encDef(name).legend;\n\n  if (leg.title) return leg.title;\n\n  return encoding.fieldTitle(name);\n};\n","'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(encoding, layout, style, stats) {\n\n  var defs = [],\n    mark = marks[encoding.marktype()],\n    from = encoding.dataTable();\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: from},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: from},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {field: {group: 'height'}};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {\n        field: {group: 'height'},\n        offset: -e.config('singleBarOffset')\n      };\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.encDef(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // fill or stroke\n  if (e.encDef(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.encDef(COLOR).opacity || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {field: {group: 'height'}};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.encDef(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {field: {group: 'height'}};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.encDef(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.encDef(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.encDef(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    encDef = e.encDef(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: encDef.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: encDef.color};\n\n  var opacity = e.encDef(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.encDef(TEXT).name],\n        numberFormat = encDef.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT, {datum: true}) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: encDef.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: encDef.placeholder};\n  }\n\n  p.font = {value: encDef.font.family};\n  p.fontWeight = {value: encDef.font.weight};\n  p.fontStyle = {value: encDef.font.style};\n  p.baseline = {value: encDef.baseline};\n\n  return p;\n}\n","'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolate = require('d3-color').interpolateHsl,\n  schema = require('../schema/schema');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, facet) {\n  return names.reduce(function(a, name) {\n    var scaleDef = {};\n\n    scaleDef.name = name;\n    scaleDef.type = scale.type(name, encoding);\n    scaleDef.domain = scale.domain(encoding, name, scaleDef.type, stats, facet);\n\n    // add `reverse` if applicable\n    var reverse = scale.reverse(encoding, name);\n    if (reverse) {\n      scaleDef.reverse = reverse;\n    }\n\n    scaleDef = scale.range(scaleDef, encoding, layout, stats);\n\n    return (a.push(scaleDef), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.encDef(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        // TODO: revise this\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (encoding, name, type, stats, facet) {\n  var encDef = encoding.encDef(name);\n\n  // special case for temporal scale\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encDef.timeUnit, name);\n    if (range) return range;\n  }\n\n  // For binned, produce fixed stepped domain.\n  // TODO(#614): this must be changed in vg2\n  if (encDef.bin) {\n\n    var fieldStat = stats[encDef.name],\n      bins = util.getbins(fieldStat, encDef.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  // For stack, use STACKED data.\n  var stack = encoding.stack();\n  if (stack && name === stack.value) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        // If faceted, scale is determined by the max of sum in each facet.\n        prefn: (facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n\n  var useRawDomain = scale._useRawDomain(encoding, name);\n  var sort = scale.sort(encoding, name, type);\n\n  if (useRawDomain) {\n    return {\n      data: RAW,\n      field: encoding.fieldRef(name, {noAggregate:true})\n    };\n  } else if (sort) { // have sort\n    return {\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: sort.op ? RAW : encoding.dataTable(),\n      field: encoding.fieldRef(name),\n      sort: sort\n    };\n  } else {\n    return {\n      data: encoding.dataTable(),\n      field: encoding.fieldRef(name)\n    };\n  }\n};\n\nscale.sort = function(encoding, name, type) {\n  var sort = encoding.encDef(name).sort;\n  if (sort === 'ascending' || sort === 'descending') {\n    return true;\n  }\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (type === 'ordinal' && util.isObject(sort)) {\n    return {\n      op: sort.op,\n      field: sort.field\n    };\n  }\n  return undefined;\n};\n\nscale.reverse = function(encoding, name) {\n  var sort = encoding.encDef(name).sort;\n  return sort && (sort === 'descending' || (sort.order === 'descending'));\n};\n\n/**\n * Determine if useRawDomain should be activated for this scale.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `useRawDomain` is enabled either through scale or config\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nscale._useRawDomain = function (encoding, name) {\n  var encDef = encoding.encDef(name);\n\n  // scale value\n  var scaleUseRawDomain = encoding.scale(name).useRawDomain;\n\n  // Determine if useRawDomain is enabled. If scale value is specified, use scale value.\n  // Otherwise, use config value.\n  var useRawDomainEnabled = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain');\n\n  var notCountOrSum = !encDef.aggregate ||\n    (encDef.aggregate !=='count' && encDef.aggregate !== 'sum');\n\n  return  useRawDomainEnabled &&\n    notCountOrSum && (\n      // Q always uses quantitative scale except when it's binned and thus uses ordinal scale.\n      (\n        encoding.isType(name, Q) &&\n        !encDef.bin // TODO(#614): this must be changed once bin is reimplemented\n      ) ||\n      // TODO: revise this\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (\n        encoding.isType(name, T) &&\n        (!encDef.timeUnit || !time.isOrdinalFn(encDef.timeUnit))\n      )\n    );\n};\n\n\nscale.range = function (scaleDef, encoding, layout, stats) {\n  var spec = encoding.scale(scaleDef.name),\n    encDef = encoding.encDef(scaleDef.name),\n    timeUnit = encDef.timeUnit;\n\n  switch (scaleDef.name) {\n    case X:\n      scaleDef.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (scaleDef.type === 'ordinal') {\n        scaleDef.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(scaleDef.name,T) && timeUnit === 'year') {\n          scaleDef.zero = false;\n        } else {\n          scaleDef.zero = spec.zero === undefined ? true : spec.zero;\n        }\n      }\n      scaleDef.round = true;\n      if (scaleDef.type === 'time') {\n        scaleDef.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        scaleDef.nice = true;\n      }\n      break;\n    case Y:\n      if (scaleDef.type === 'ordinal') {\n        scaleDef.range = layout.cellHeight ?\n          (encDef.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        scaleDef.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        scaleDef.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(scaleDef.name,T) && timeUnit === 'year') {\n          scaleDef.zero = false;\n        } else {\n          scaleDef.zero = spec.zero === undefined ? true : spec.zero;\n        }\n      }\n\n      scaleDef.round = true;\n\n      if (scaleDef.type === 'time') {\n        scaleDef.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        scaleDef.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      scaleDef.bandWidth = layout.cellHeight;\n      scaleDef.round = true;\n      scaleDef.nice = true;\n      break;\n    case COL: // support only ordinal\n      scaleDef.bandWidth = layout.cellWidth;\n      scaleDef.round = true;\n      scaleDef.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        scaleDef.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        scaleDef.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        scaleDef.range = [10, 0.8 * bandSize*bandSize];\n      }\n      scaleDef.round = true;\n      scaleDef.zero = false;\n      break;\n    case SHAPE:\n      scaleDef.range = 'shapes';\n      break;\n    case COLOR:\n      scaleDef.range = scale.color(scaleDef, encoding, stats);\n      if (scaleDef.type !== 'ordinal') scaleDef.zero = false;\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ scaleDef.name);\n  }\n\n  // FIXME(kanitw): Jul 29, 2015 - consolidate this with above\n  switch (scaleDef.name) {\n    case ROW:\n    case COL:\n      scaleDef.padding = encoding.config('cellPadding');\n      scaleDef.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (scaleDef.type === 'ordinal') { //&& !s.bandWidth\n        scaleDef.points = true;\n        scaleDef.padding = encoding.encDef(scaleDef.name).band.padding;\n      }\n  }\n\n  return scaleDef;\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette,\n      quantitativeRange = colorScale.quantitativeRange;\n\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n        return scale.color.palette(range, cardinality, type);\n      } else {\n        if (ordinalPalette) {\n          return scale.color.palette(ordinalPalette, cardinality, type);\n        }\n        return scale.color.interpolate(quantitativeRange[0], quantitativeRange[1], cardinality);\n      }\n    } else { //time or quantitative\n      return [quantitativeRange[0], quantitativeRange[1]];\n    }\n  }\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  // FIXME(kanitw): Jul 29, 2015 - check range is string\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  // TODO add our own set of custom ordinal color palette\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range];\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    var ps = cardinality < 3 ? 3 : Math.max.apply(null, util.keys(palette)),\n      from = 0 , to = ps - 1;\n    // FIXME add config for from / to\n\n    return scale.color.interpolate(palette[ps][from], palette[ps][to], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n\n  var interpolator = interpolate(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = stacking;\n\nfunction stacking(encoding, mdef, stack) {\n  var groupby = stack.groupby;\n  var field = stack.value;\n\n  var valName = encoding.fieldRef(field);\n  var startField = valName + '_start';\n  var endField = valName + '_end';\n\n  // add stack transform to mark\n  var transform = {\n    type: 'stack',\n    groupby: [encoding.fieldRef(groupby)],\n    field: encoding.fieldRef(field),\n    sortby: [(stack.properties.reverse ? '-' : '') + encoding.fieldRef(stack.stack)],\n    output: {start: startField, end: endField}\n  };\n\n  if (stack.properties.offset) {\n    transform.offset = stack.properties.offset;\n  }\n\n  mdef.from.transform = [transform];\n\n  // TODO(#276): This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[field] = mdef.properties.enter[field] = {\n    scale: field,\n    field: startField\n  };\n  mdef.properties.update[field + '2'] = mdef.properties.enter[field + '2'] = {\n    scale: field,\n    field: endField\n  };\n\n  return field; //return stack encoding\n}\n","'use strict';\n\nrequire('../globals');\n\nvar vlEncDef = require('../encdef');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(encDef, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlEncDef.isOrdinalScale(encDef))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, encoding) {\n  var m = group.marks;\n  var g = {\n    name: 'subfacet',\n    type: 'group',\n    from: mdef.from,\n    properties: {\n      enter: {\n        width: {field: {group: 'width'}},\n        height: {field: {group: 'height'}}\n      }\n    },\n    marks: m\n  };\n\n  group.marks = [g];\n  delete mdef.from; // (move to the new g)\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.push({type: 'facet', groupby: details});\n\n  // TODO: understand why we need this sort transform and write comment\n  var stack = encoding.stack();\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n","'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nvar time = module.exports = {};\n\n// 'Wednesday September 17 04:00:00 2014'\n// Wednesday is the longest date\n// September is the longest month (8 in javascript as it is zero-indexed).\nvar LONG_DATE = new Date(Date.UTC(2014, 8, 17));\n\ntime.cardinality = function(encDef, stats, filterNull, type) {\n  var timeUnit = encDef.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[encDef.name],\n        yearstat = stats['year_' + encDef.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.formula = function(timeUnit, fieldRef) {\n  // TODO(kanitw): add formula to other time format\n  var fn = 'utc' + timeUnit;\n  return fn + '(' + fieldRef + ')';\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // TODO(#600) revise this\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\n/**\n * @param  {Object} encoding\n * @return {Array}  scales for time unit names\n */\ntime.scales = function(encoding) {\n  var scales = encoding.reduce(function(scales, encDef) {\n    var timeUnit = encDef.timeUnit;\n    if (encDef.type === T && timeUnit && !scales[timeUnit]) {\n      var scale = time.scale.def(encDef.timeUnit, encoding);\n      if (scale) scales[timeUnit] = scale;\n    }\n    return scales;\n  }, {});\n\n  return util.vals(scales);\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n","'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlEncDef = require('./encdef'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlEncDef.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlEncDef.fromShorthand(field);\n    return m;\n  }, {});\n};\n","'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.noAggregate -- exclude aggregation function\n *   opt.datum - include 'datum.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.datum ? 'datum.' : '') + (opt.prefn || ''),\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else if (!opt.nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!opt.nofn && !opt.noAggregate && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!opt.nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  }  else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.missing > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","'use strict';\n\n// TODO(kanitw): chat with Vega team and possibly move this to vega-logging\nmodule.exports = function(prefix) {\n  // Borrowed some ideas from http://stackoverflow.com/a/15653260/866989\n  // and https://github.com/patik/console.log-wrapper/blob/master/consolelog.js\n  var METHODS = ['error', 'info', 'debug', 'warn', 'log'];\n\n  return METHODS.reduce(function(logger, fn) {\n    var cfn = console[fn] ? fn : 'log';\n    if (console[cfn].bind === 'undefined') { // IE < 10\n        logger[fn] = Function.prototype.bind.call(console[cfn], console, prefix);\n    }\n    else {\n        logger[fn] = console[cfn].bind(console, prefix);\n    }\n    return logger;\n  }, {});\n};","// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nvar VALID_AGG_OPS = require('vega/src/transforms/Aggregate').VALID_OPS;\n\n// TODO(#620) refer to vega schema\n// var vgStackSchema = require('vega/src/transforms/Stack').schema;\n\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: VALID_AGG_OPS,\n  supportedEnums: {\n    Q: VALID_AGG_OPS,\n    O: ['median','min','max'],\n    N: [],\n    T: ['mean', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        /* Common Scale Properties */\n        type: schema.scale_type,\n\n        /* Quantitative Scale Properties */\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n\n        /* Vega-lite only Properties */\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        /* Vega Axis Properties */\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        grid: {\n          type: 'boolean',\n          default: undefined,\n          description: 'A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks. One of \"front\" (default) or \"back\".'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks: {\n          type: 'integer',\n          default: 5,\n          minimum: 0,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        /* Vega Axis Properties that are automatically populated by Vega-lite */\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        /* Vega-lite only */\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        },\n        labelAngle: {\n          type: 'integer',\n          default: undefined, // auto\n          minimum: 0,\n          maximum: 360,\n          description: 'Angle by which to rotate labels. Set to 0 to force horizontal.'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          minimum: 0,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      default: 'ascending',\n      supportedTypes: toMap([N, O]),\n      oneOf: [\n        {\n          type: 'string',\n          enum: ['ascending', 'descending', 'unsorted']\n        },\n        { // sort by aggregation of another field\n          type: 'object',\n          required: ['field', 'op'],\n          properties: {\n            field: {\n              type: 'string',\n              description: 'The field name to aggregate over.'\n            },\n            op: {\n              type: 'string',\n              enum: VALID_AGG_OPS,\n              description: 'The field name to aggregate over.'\n            },\n            order: {\n              type: 'string',\n              enum: ['ascending', 'descending']\n            }\n          }\n        }\n      ]\n\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'object',\n      description: 'Properties of a legend.',\n      properties: {\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the legend. (Shows field name and its function by default.)'\n        },\n        orient: {\n          type: 'string',\n          default: 'right',\n          description: 'The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".'\n        }\n      }\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0,\n      description: 'Size of marks.'\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: '#4682b4',\n      description: 'Color to be used for marks.'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'Color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette.'\n            //FIXME\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: undefined,\n          description: 'Color palette to encode ordinal variables.',\n          enum: util.keys(colorbrewer)\n        },\n        quantitativeRange: {\n          type: 'array',\n          default: ['#AFC6A3', '#09622A'], // tableau greens\n          // default: ['#ccece6', '#00441b'], // BuGn.9 [2-8]\n          description: 'Color range to encode quantitative variables.',\n          minItems: 2,\n          maxItems: 2,\n          items: {\n            type: 'string',\n            role: 'color'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar stackMixin = {\n  type: 'object',\n  properties: {\n    stack: {\n      type: ['boolean', 'object'],\n      default: true,\n      description: 'Enable stacking (for bar and area marks only).',\n      properties: {\n        reverse: {\n          type: 'boolean',\n          default: false,\n          description: 'Whether to reverse the stack\\'s sortby.'\n        },\n        offset: {\n          type: 'string',\n          default: undefined,\n          enum: ['zero', 'center', 'normalize']\n          // TODO(#620) refer to Vega spec once it doesn't throw error\n          // enum: vgStackSchema.properties.offset.oneOf[0].enum\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle',\n      description: 'Mark to be used.'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, stackMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, stackMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    },\n    // we generate a vega filter transform\n    filter: {\n      type: 'string',\n      default: undefined,\n      description: 'A string containing the filter Vega expression. Use `datum` to refer to the current data object.'\n    },\n    // we generate a vega formula transform\n    formulas: {\n      type: 'array',\n      default: undefined,\n      description: 'Array of formula transforms. Formulas are applied before filter.',\n      items: {\n        type: 'object',\n        properties: {\n          field: {\n            type: 'string',\n            description: 'The property name in which to store the computed formula value.'\n          },\n          expr: {\n            type: 'string',\n            description: 'A string containing an expression for the formula. Use the variable `datum` to to refer to the current data object.'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    // TODO(#597) revise this config\n    filterNull: {\n      type: 'object',\n      properties: {\n        N: {type:'boolean', default: false},\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    autoSortLine: {\n      type: 'boolean',\n      default: true\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.25\n    },\n    cellGridOffset: {\n      type: 'number',\n      default: 6 // equal to tickSize\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'rgba(0,0,0,0)'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.extend(util, require('./logger')('[VL Error]'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\n","'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.encDef = require('./encdef');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\nvl.format = require('d3-format').format;\n\nmodule.exports = vl;"],"sourceRoot":"/source/"}